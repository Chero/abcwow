Index: src/game/AreaTrigger.cpp
===================================================================
--- src/game/AreaTrigger.cpp	(revision 5)
+++ src/game/AreaTrigger.cpp	(working copy)
@@ -39,6 +39,7 @@
 	AREA_TRIGGER_FAILURE_NO_GROUP		= 7,
 	AREA_TRIGGER_FAILURE_NO_KEY         = 8,
 	AREA_TRIGGER_FAILURE_LEVEL_HEROIC	= 9,
+	AREA_TRIGGER_FAILURE_NO_ATTUNE_ITEM	=10,
 };
 
 const char * AreaTriggerFailureMessages[] = {
@@ -47,11 +48,12 @@
 	"You must have The Burning Crusade Expansion to access this content.",
 	"Heroic mode unavailable for this instance.",
 	"You must be in a raid group to pass through here.",
-	"You do not have the required attunement to pass through here.", //TODO: Replace attunment with real itemname
+	"You do not have the required attunement quest to pass through here.",
 	"You must be at least level %u to pass through here.",
 	"You must be in a party to pass through here.",
-	"You do not have the required attunement to pass through here.", //TODO: Replace attunment with real itemname
+	"Heroic Difficulty requires the %s.",
 	"You must be level 70 to enter heroic mode.",
+	"You do not have %s to pass through here.",
 };
 
 inline uint32 CheckTriggerPrerequsites(AreaTrigger * pAreaTrigger, WorldSession * pSession, Player * pPlayer, MapInfo * pMapInfo)
@@ -82,7 +84,7 @@
 		return AREA_TRIGGER_FAILURE_NO_ATTUNE;
 
 	if(pMapInfo && pMapInfo->required_item && !pPlayer->GetItemInterface()->GetItemCount(pMapInfo->required_item, true))
-		return AREA_TRIGGER_FAILURE_NO_ATTUNE;
+		return AREA_TRIGGER_FAILURE_NO_ATTUNE_ITEM;
 
 	if (pPlayer->iInstanceType == MODE_HEROIC && 
 		pMapInfo->type == INSTANCE_MULTIMODE && 
@@ -126,9 +128,11 @@
 				if(reason != AREA_TRIGGER_FAILURE_OK)
 				{
 					const char * pReason = AreaTriggerFailureMessages[reason];
-					WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 50);
+					WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 60);
 					data << uint32(0);
                     
+					MapInfo * pMapInfo = WorldMapInfoStorage.LookupEntry(pAreaTrigger->Mapid);
+
 					switch (reason)
 					{
 					case AREA_TRIGGER_FAILURE_LEVEL:
@@ -136,6 +140,19 @@
 						snprintf(msg,50,pReason,pAreaTrigger->required_level);
 						data << msg;
 						break;
+					case AREA_TRIGGER_FAILURE_NO_ATTUNE_ITEM:
+					case AREA_TRIGGER_FAILURE_NO_KEY:
+						if (pMapInfo && (pMapInfo->heroic_key_1 || pMapInfo->required_item))
+ 						{
+							ItemPrototype *itemProto = ItemPrototypeStorage.LookupEntry(pMapInfo->required_item ? pMapInfo->required_item : pMapInfo->heroic_key_1);
+							if(itemProto)
+							{
+ 								char msg[60];
+ 								snprintf(msg,60,pReason,itemProto->Name1);
+								data << msg;
+ 							} data << pReason;
+ 						}
+						break;
 					default:
 						data << pReason;
 						break;
Index: src/game/BattlegroundMgr.cpp
===================================================================
--- src/game/BattlegroundMgr.cpp	(revision 5)
+++ src/game/BattlegroundMgr.cpp	(working copy)
@@ -252,6 +252,7 @@
 						tempPlayerVec[0].pop_front();
 						arena->AddPlayer(plr, team);
 						ErasePlayerFromList(plr->GetGUIDLow(), &m_queuedPlayers[i][j]);
+						team = arena->GetFreeTeam();
 					}
 				}
 				else
@@ -385,15 +386,14 @@
 
 			Arena * ar = ((Arena*)CreateInstance(i,LEVEL_GROUP_70));
 			GroupMembersSet::iterator itx;
-			int32 team;
 			ar->rated_match=true;
 
 			for(itx = group1->GetSubGroup(0)->GetGroupMembersBegin(); itx != group1->GetSubGroup(0)->GetGroupMembersEnd(); ++itx)
 			{
 				if(itx->player)
 				{
-					if( (team = ar->GetFreeTeam()) != -1 )
-                        ar->AddPlayer(itx->player, team);
+					if(ar->HasFreeSlots(0))
+                        ar->AddPlayer(itx->player, 0);
 				}
 			}
 
@@ -401,8 +401,8 @@
 			{
 				if(itx->player)
 				{
-					if( (team = ar->GetFreeTeam()) != -1 )
-						ar->AddPlayer(itx->player, team);
+					if(ar->HasFreeSlots(1))
+						ar->AddPlayer(itx->player, 1);
 				}
 			}
 		}
@@ -683,6 +683,8 @@
 {
 	m_mainLock.Acquire();
 
+	plr->m_bgTeam = team;
+
 	/* This is called when the player is added, not when they port. So, they're essentially still queued, but not inside the bg yet */
 	m_pendPlayers[team].insert(plr->GetGUIDLow());
 
@@ -796,7 +798,7 @@
 		/* arenas follow a different procedure. */
 		static const uint32 arena_map_ids[3] = { 559, 562, 572 };
 		uint32 mapid = arena_map_ids[sRand.randInt(2)];
-		mapid=562;
+		//mapid=562;
 		uint32 players_per_side;
 		mgr = sInstanceMgr.CreateBattlegroundInstance(mapid);
 		if(mgr == NULL)
@@ -990,7 +992,7 @@
 			data << uint8(0xC);
 			data << uint32(6);
 			data << uint16(0x1F90);
-			data << uint32(11);
+			data << InstanceID;
 			data << uint8(RatedMatch);		// 1 = rated match
 		}
 		else
Index: src/game/Creature.cpp
===================================================================
--- src/game/Creature.cpp	(revision 5)
+++ src/game/Creature.cpp	(working copy)
@@ -840,7 +840,7 @@
 		ModUInt32Value(UNIT_FIELD_LEVEL, info->lvl_mod_a);
 
 	for(uint32 i = 0; i < 7; ++i)
-		SetUInt32Value(UNIT_FIELD_RESISTANCES+i,proto->Resistances[i]);
+		SetUInt32Value(UNIT_FIELD_RESISTANCES+i,(mode ? (uint32)(proto->Resistances[i]*1.5f)  : proto->Resistances[i]));
 
 	SetUInt32Value(UNIT_FIELD_BASEATTACKTIME,proto->AttackTime);
 	SetFloatValue(UNIT_FIELD_MINDAMAGE, (mode ? proto->MinDamage * 1.5f  : proto->MinDamage));
Index: src/game/DayWatcherThread.cpp
===================================================================
--- src/game/DayWatcherThread.cpp	(revision 5)
+++ src/game/DayWatcherThread.cpp	(working copy)
@@ -178,6 +178,7 @@
 	Player * plr;
 	uint32 guid, arenapoints, orig_arenapoints;
 	ArenaTeam * team;
+	uint32 arenapointsPerTeam[3] = {0,0,0};
 	long double X, Y;
 	if(result)
 	{
@@ -246,10 +247,13 @@
 					}
 					
 					if(Y > 1.0)
-						arenapoints += long2int32(double(ceil(Y)));
+						arenapointsPerTeam[i] += long2int32(double(ceil(Y)));
 				}
 			}
 
+			arenapointsPerTeam[0] = max(arenapointsPerTeam[0],arenapointsPerTeam[1]);
+			arenapoints += max(arenapointsPerTeam[0],arenapointsPerTeam[2]);
+
 			if(orig_arenapoints != arenapoints)
 			{
 				plr = objmgr.GetPlayer(guid);
Index: src/game/Item.cpp
===================================================================
--- src/game/Item.cpp	(revision 5)
+++ src/game/Item.cpp	(working copy)
@@ -694,6 +694,7 @@
 						TS.procChance = Entry->min[c];
 					Log.Debug("Enchant","Setting procChance to %u%%.", TS.procChance);
 					TS.deleted = false;
+					TS.ProcType = (GetProto()->Class == ITEM_CLASS_WEAPON)? 1 : 2;
 					TS.spellId = Entry->spell[c];
 					m_owner->m_procSpells.push_back(TS);
 				}
Index: src/game/ItemInterface.cpp
===================================================================
--- src/game/ItemInterface.cpp	(revision 5)
+++ src/game/ItemInterface.cpp	(working copy)
@@ -1322,7 +1322,13 @@
 
 	if((slot < INVENTORY_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET) || (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET))
 	{
-		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat())
+		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat()
+			&& proto->InventoryType != INVTYPE_WEAPON && proto->InventoryType != INVTYPE_WEAPONMAINHAND
+			&& proto->InventoryType != INVTYPE_RANGED && proto->InventoryType != INVTYPE_WEAPONOFFHAND
+			&& proto->InventoryType != INVTYPE_SHIELD && proto->InventoryType != INVTYPE_2HWEAPON
+			&& proto->InventoryType != INVTYPE_AMMO && proto->InventoryType != INVTYPE_THROWN
+			&& proto->InventoryType != INVTYPE_RANGEDRIGHT
+			)
 			return INV_ERR_CANT_DO_IN_COMBAT;
 
 		// Check to see if we have the correct race
Index: src/game/Object.cpp
===================================================================
--- src/game/Object.cpp	(revision 5)
+++ src/game/Object.cpp	(working copy)
@@ -2078,6 +2078,7 @@
 		Unit* caster = (Unit*)(this);
 		caster->RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_START_ATTACK);
 		int32 plus_damage = 0;
+		int32 plus_damage_victim = 0;
 		
 		if(caster->IsPlayer())
 		{
@@ -2086,10 +2087,10 @@
 		}
 //------------------------------by school---------------------------------------------------
 		plus_damage += caster->GetDamageDoneMod(school);
-		plus_damage += pVictim->DamageTakenMod[school];
+		plus_damage_victim += pVictim->DamageTakenMod[school];
 //------------------------------by victim type----------------------------------------------
 		if(((Creature*)pVictim)->GetCreatureName() && caster->IsPlayer()&& !pVictim->IsPlayer())
-			plus_damage += static_cast<Player*>(caster)->IncreaseDamageByType[((Creature*)pVictim)->GetCreatureName()->Type];
+			plus_damage_victim += static_cast<Player*>(caster)->IncreaseDamageByType[((Creature*)pVictim)->GetCreatureName()->Type];
 //==========================================================================================
 //==============================+Spell Damage Bonus Modifications===========================
 //==========================================================================================
@@ -2107,6 +2108,7 @@
 		if (spellInfo->NameHash == 0x695C4940 || spellInfo->NameHash == 0x3DD5C872 || spellInfo->NameHash == 0xddaf1ac7 || spellInfo->NameHash == 0xCB75E5D1)
 			dmgdoneaffectperc *= float (1.0f - (( td / 15000.0f ) / (( td / 15000.0f ) + dmgdoneaffectperc)));
 
+		float dmgdonepercdownrank = 1.0f;
 		if(spellInfo->baseLevel > 0 && spellInfo->maxLevel > 0)
 		{
 		   float downrank1 = 1.0f;
@@ -2115,12 +2117,20 @@
 		   float downrank2 = ( float(spellInfo->maxLevel + 5.0f) / float(static_cast<Player*>(this)->getLevel()) );
 		   if (downrank2 >= 1 || downrank2 < 0)
 		         downrank2 = 1.0f;
-			dmgdoneaffectperc *= downrank1 * downrank2;
+			dmgdonepercdownrank *= downrank1 * downrank2;
 		}
 //==========================================================================================
 //==============================Bonus Adding To Main Damage=================================
 //==========================================================================================
-		int32 bonus_damage = float2int32(plus_damage * dmgdoneaffectperc);
+		int32 bonus_damage = 0;
+		if(spellInfo->dmg_bonus)
+		{
+			bonus_damage = float2int32((plus_damage * spellInfo->dmg_bonus * dmgdonepercdownrank)/100);
+			bonus_damage += (int32)(plus_damage_victim * dmgdonepercdownrank);
+		}
+		else
+			bonus_damage = float2int32((plus_damage + plus_damage_victim) * dmgdoneaffectperc * dmgdonepercdownrank);
+
 		bonus_damage +=pVictim->DamageTakenMod[school];
 		if(spellInfo->SpellGroupType)
 		{
Index: src/game/ObjectMgr.cpp
===================================================================
--- src/game/ObjectMgr.cpp	(revision 7)
+++ src/game/ObjectMgr.cpp	(working copy)
@@ -1876,6 +1876,37 @@
 	} while(result->NextRow());
 	delete result;
 	Log.Notice("ObjectMgr", "%u spell fixes loaded.", fixed_count);
+
+/*##########################################################################################*/
+
+	// Loads data from spell_data_extra table
+	result = WorldDatabase.Query("SELECT * FROM spell_data_extra");
+	if(result == 0) return;
+
+	uint32 override_count = 0;
+	do
+	{
+		Field * fields = result->Fetch();
+		uint32 spell_id = fields[0].GetUInt32();
+		SpellEntry * sp = dbcSpell.LookupEntry(spell_id);
+		if(sp == 0) 
+			continue;
+
+		if (fields[1].GetUInt32() != NULL)
+			sp->dmg_bonus = fields[1].GetUInt32();
+		else
+			sp->dmg_bonus = 0;
+			
+		if(fields[2].GetUInt32() != NULL)
+			sp->proc_interval = fields[2].GetUInt32();
+		else
+			sp->proc_interval = 0;
+
+		override_count++;
+	} while (result->NextRow());
+
+	delete result;
+	Log.Notice("ObjectMgr", "%u spell data extra loaded.", override_count);
 }
 
 void ObjectMgr::LoadSpellOverride()
@@ -2503,9 +2534,13 @@
 			replimit = i->mob_rep_reward;
 		}
 
-		if(!value || (replimit && pPlayer->GetStanding(i->faction[team]) >= replimit))
+		if(!value)
 			continue;
 
+		if (pPlayer->iInstanceType != MODE_HEROIC)
+			if(replimit && pPlayer->GetStanding(i->faction[team]) >= replimit)
+				continue;
+
 		//value *= sWorld.getRate(RATE_KILLREPUTATION);
 		value = float2int32(float(value) * sWorld.getRate(RATE_KILLREPUTATION));
 		pPlayer->ModStanding(i->faction[team], value);
Index: src/game/Player.cpp
===================================================================
--- src/game/Player.cpp	(revision 5)
+++ src/game/Player.cpp	(working copy)
@@ -86,6 +86,7 @@
 
 	m_healthfromspell	   = 0;
 	m_manafromspell		 = 0;
+	m_mana_from_base_int = 0;
 	m_healthfromitems	   = 0;
 	m_manafromitems		 = 0;
 
@@ -2920,7 +2921,13 @@
 		SetUInt32Value(PLAYER_GUILD_TIMESTAMP, (uint32)UNIXTIME);
 
 #undef get_next_field
-
+
+	LevelInfo * Info = objmgr.GetLevelInfo(getRace(), getClass(), getLevel());
+	LevelInfo * InfoFirst = objmgr.GetLevelInfo(getRace(), getClass(), 1);
+
+	if(Info != 0 && InfoFirst != 0)
+		SetBaseManaFromInt((Info->Stat[3] - InfoFirst->Stat[3])*15);
+	
 	// load properties
 	_LoadTutorials(results[1].result);
 	_LoadItemCooldown(results[2].result);
@@ -3396,6 +3403,7 @@
 				ts.caster=this->GetGUID();
 				ts.procFlags=PROC_ON_MELEE_ATTACK;
 				ts.deleted = false;
+				ts.ProcType = (item->GetProto()->Class == ITEM_CLASS_WEAPON)? 1 : 2;
 				this->m_procSpells.push_front(ts);			
 			}
 		}
@@ -5230,6 +5238,22 @@
 	}
 }
 
+void Player::removeDeletedSpellByHashName(uint32 hash)
+{
+	SpellSet::iterator it,iter;
+	
+	for(iter= mDeletedSpells.begin();iter != mDeletedSpells.end();)
+	{
+		it = iter++;
+		uint32 SpellID = *it;
+		SpellEntry *e = dbcSpell.LookupEntry(SpellID);
+		if(e->NameHash == hash)
+		{
+			mDeletedSpells.erase(it);
+		}
+	}
+}
+
 void Player::removeSpellByHashName(uint32 hash)
 {
 	SpellSet::iterator it,iter;
@@ -5482,11 +5506,14 @@
 							//remove higher ranks of this spell too (like earth shield lvl 1 is talent and the rest is thought from trainer) 
 							SpellEntry *spellInfo2;
 							spellInfo2 = dbcSpell.LookupEntry( spellInfo->EffectTriggerSpell[k] );
-							if(spellInfo2)
-								removeSpellByHashName(spellInfo2->NameHash);
-						}
+							if(spellInfo2) {
+ 								removeSpellByHashName(spellInfo2->NameHash);
+								removeDeletedSpellByHashName(spellInfo2->NameHash);
+							}
+ 						}
 					//remove them all in 1 shot
 					removeSpellByHashName(spellInfo->NameHash);
+					removeDeletedSpellByHashName(spellInfo->NameHash);
 				}
 			}
 			else
Index: src/game/Player.h
===================================================================
--- src/game/Player.h	(revision 5)
+++ src/game/Player.h	(working copy)
@@ -856,6 +856,7 @@
 	void smsg_InitialSpells();
 	void addSpell(uint32 spell_idy);
 	void removeSpellByHashName(uint32 hash);
+	void removeDeletedSpellByHashName(uint32 hash);
 	bool removeSpell(uint32 SpellID, bool MoveToDeleted, bool SupercededSpell, uint32 SupercededSpellID);
 
     // PLEASE DO NOT INLINE!
@@ -1162,8 +1163,10 @@
 	void SetHitFromSpell(float value) { m_hitfromspell = value; }
 	inline uint32 GetHealthFromSpell() { return m_healthfromspell; }
 	inline uint32 GetManaFromSpell() { return m_manafromspell; }
+	inline uint32 GetBaseManaFromInt() { return m_mana_from_base_int; }
 	void SetHealthFromSpell(uint32 value) { m_healthfromspell = value;}
 	void SetManaFromSpell(uint32 value) { m_manafromspell = value;}
+	void SetBaseManaFromInt(uint32 value) { m_mana_from_base_int = value;}
 	uint32 CalcTalentResetCost(uint32 resetnum);
 	void SendTalentResetConfirm();
 	uint32 GetTalentResetTimes() { return m_talentresettimes; }
@@ -1808,6 +1811,7 @@
 	//stats mods
 	uint32 m_healthfromspell;
 	uint32 m_manafromspell;
+	uint32 m_mana_from_base_int;
 	uint32 m_healthfromitems;
 	uint32 m_manafromitems;
 	
Index: src/game/Spell.cpp
===================================================================
--- src/game/Spell.cpp	(revision 5)
+++ src/game/Spell.cpp	(working copy)
@@ -1259,10 +1259,11 @@
 								HandleEffects((*i),x);
                             }
 						}
-						else if(m_spellInfo->Effect[x] == SPELL_EFFECT_TELEPORT_UNITS)
-                        {
-							HandleEffects(m_caster->GetGUID(),x);
-                        }
+						else 
+                         {
+							if(m_spellInfo->Effect[x] == SPELL_EFFECT_TELEPORT_UNITS)
+								HandleEffects(m_caster->GetGUID(),x);
+                         }
 					}
 				}
 	
@@ -2007,8 +2008,12 @@
 	int32 cost;
 	if(m_spellInfo->ManaCostPercentage)//Percentage spells cost % of !!!BASE!!! mana
 	{
-		if(m_spellInfo->powerType==POWER_TYPE_MANA)
-			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)*m_spellInfo->ManaCostPercentage)/100;
+		uint32 base_manafrom_int = 0;
+		if(p_caster)
+			base_manafrom_int = p_caster->GetBaseManaFromInt();
+
+		if(m_spellInfo->powerType==POWER_TYPE_MANA)
+			cost = ((m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA) - base_manafrom_int)*m_spellInfo->ManaCostPercentage)/100;
 		else
 			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_HEALTH)*m_spellInfo->ManaCostPercentage)/100;
 	}
@@ -2018,7 +2023,14 @@
 	}
 
 	if(m_spellInfo->powerType==POWER_TYPE_HEALTH)
-		cost -= m_spellInfo->baseLevel;//FIX for life tap	
+	{
+		// For Life Tap don't do repeat damage process
+		if (m_spellInfo->NameHash == 0x0807C866) return true;
+
+		// The caster doesnt have enough health to use this spell...stop casting
+		if (u_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= (uint32)cost) 
+			return false;
+	}
 	else if(u_caster)
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
@@ -2105,8 +2117,12 @@
 	int32 cost;
 	if(m_spellInfo->ManaCostPercentage)//Percentage spells cost % of !!!BASE!!! mana
 	{
-		if(m_spellInfo->powerType==POWER_TYPE_MANA)
-			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)*m_spellInfo->ManaCostPercentage)/100;
+		uint32 base_manafrom_int = 0;
+		if(p_caster)
+			base_manafrom_int = p_caster->GetBaseManaFromInt();
+
+		if(m_spellInfo->powerType==POWER_TYPE_MANA)
+			cost = ((m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA) - base_manafrom_int)*m_spellInfo->ManaCostPercentage)/100;
 		else
 			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_HEALTH)*m_spellInfo->ManaCostPercentage)/100;
 	}
@@ -2116,7 +2132,14 @@
 	}
 	
 	if(m_spellInfo->powerType==POWER_TYPE_HEALTH)
-			cost -= m_spellInfo->baseLevel;//FIX for life tap	
+	{
+		// For Life Tap don't do repeat damage process
+		if (m_spellInfo->NameHash == 0x0807C866) return true;
+
+		// The caster doesnt have enough health to use this spell...stop casting
+		if (u_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= (uint32)cost) 
+			return false;
+	}
 	else if(u_caster)
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
@@ -3535,7 +3558,10 @@
 			healdoneaffectperc *= downrank1 * downrank2;
 		}
 
-		amount += float2int32(u_caster->HealDoneMod[m_spellInfo->School] * healdoneaffectperc);
+		if(!m_spellInfo->dmg_bonus)
+			amount += float2int32(u_caster->HealDoneMod[m_spellInfo->School] * healdoneaffectperc);
+		else
+			amount += float2int32((u_caster->HealDoneMod[m_spellInfo->School]*m_spellInfo->dmg_bonus)/100);
 		amount += (amount*u_caster->HealDonePctMod[m_spellInfo->School])/100;
 		amount += unitTarget->HealTakenMod[m_spellInfo->School];//amt of health that u RECIVE, not heal
 		amount += float2int32(unitTarget->HealTakenPctMod[m_spellInfo->School]*amount);
Index: src/game/SpellAuras.cpp
===================================================================
--- src/game/SpellAuras.cpp	(revision 5)
+++ src/game/SpellAuras.cpp	(working copy)
@@ -563,6 +563,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.ProcType = 0;
 			m_target->m_procSpells.push_front(pts);
 		}
 		else
@@ -1073,7 +1074,7 @@
 			c->RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_START_ATTACK);
 			
 			float bonus_damage = (float)c->GetDamageDoneMod(school);
-			bonus_damage += float(m_target->DamageTakenMod[school]);
+			float bonus_damage_victim = (float)(m_target->DamageTakenMod[school]);
 			if(c->IsPlayer())
 			{
 				bonus_damage += static_cast<Player*>(c)->SpellDmgDoneByInt[school] * c->GetUInt32Value(UNIT_FIELD_STAT3);
@@ -1089,10 +1090,18 @@
 			if(GetDuration())
 			{
 				float ticks= float((amp) ? GetDuration()/amp : 0);
-				float fbonus = float(bonus);
-				fbonus += (ticks) ? bonus_damage/ticks : 0;
-				fbonus *= float(GetDuration()) / 15000.0f;
-				bonus = float2int32(fbonus);
+				if (m_spellProto->dmg_bonus && m_spellProto->Effect[0] != SPELL_EFFECT_SCHOOL_DAMAGE && 
+					m_spellProto->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE && m_spellProto->Effect[2] != SPELL_EFFECT_SCHOOL_DAMAGE )
+				{
+					bonus += (ticks) ? ((bonus_damage*m_spellProto->dmg_bonus*0.01)+bonus_damage_victim)/ticks : 0;
+				}
+				else
+				{
+					bonus += (ticks) ? (bonus_damage+bonus_damage_victim)/ticks : 0;
+					if(!m_spellProto->ChannelInterruptFlags)
+						bonus *= float(GetDuration()) / 15000.0f;
+				}
+				bonus = float2int32(bonus);
 			}
 			else bonus = 0;
 
@@ -1313,6 +1322,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.ProcType = 0;
 			m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1685,6 +1695,7 @@
 				pts.procCharges = GetSpellProto()->procCharges;
 				pts.LastTrigger = 0;
 				pts.deleted = false;
+				pts.ProcType = 0;
 				m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1862,6 +1873,7 @@
 		if(p_target)
 		{
 			m_target->setAItoUse(true);
+			static_cast<Player*>(m_target)->EventAttackStop();
 		}
 		//m_target->m_pacified++;
 		m_target->m_special_state |= UNIT_STATE_FEAR;
@@ -1902,6 +1914,7 @@
 	Unit * c = GetUnitCaster();
 
 	int bonus = 0;
+	int bonus_target = 0;
 
 	if(c && c->IsPlayer())
 	{
@@ -1912,7 +1925,7 @@
 		if (static_cast<Player*>(c)->IsInFeralForm() && static_cast<Player*>(c)->GetShapeShift() == FORM_TREE)
 			bonus += float2int32(0.25f*((Player*)c)->GetUInt32Value(UNIT_FIELD_STAT4));
 	}
-	bonus += m_target->HealTakenMod[GetSpellProto()->School];
+	bonus_target += m_target->HealTakenMod[GetSpellProto()->School];
 
 	int amp = m_spellProto->EffectAmplitude[mod->i];
 	if(!amp) 
@@ -1921,8 +1934,16 @@
 	if(GetDuration())
 	{
 		int ticks= (amp) ? GetDuration()/amp : 0;
-		bonus= (ticks) ? bonus/ticks : 0;
-		bonus = float2int32(float(bonus*GetDuration() / 15000.0f));
+		if (!m_spellProto->dmg_bonus)
+		{
+			bonus = (ticks) ? (bonus+bonus_target)/ticks : 0;
+			if(!m_spellProto->ChannelInterruptFlags)
+				bonus = float2int32(float(bonus*GetDuration() / 15000.0f));
+		}
+		else
+		{
+			bonus = (ticks) ? ((bonus*m_spellProto->dmg_bonus/100)+bonus_target)/ticks : 0;
+		}
 	}
 	else bonus = 0;
 
@@ -3467,6 +3488,7 @@
 		pts.procCharges = GetSpellProto()->procCharges;
 		pts.LastTrigger = 0;
 		pts.deleted = false;
+		pts.ProcType = 0;
 
 		if(m_spellProto->NameHash == 0xE4573D4A)
 		{
Index: src/game/SpellAuras.h
===================================================================
--- src/game/SpellAuras.h	(revision 5)
+++ src/game/SpellAuras.h	(working copy)
@@ -304,7 +304,7 @@
 //    SpellEntry *ospinfo;
 //    SpellEntry *spinfo;
     uint32 LastTrigger;
-	uint32 ProcType; //0=talents/spells 1=weapon 2=armor  TODO: implement.
+	uint32 ProcType; //0=talents/spells 1=weapon 2=armor
     bool deleted;
 };
 
Index: src/game/SpellEffects.cpp
===================================================================
--- src/game/SpellEffects.cpp	(revision 5)
+++ src/game/SpellEffects.cpp	(working copy)
@@ -510,6 +510,7 @@
 
 		uint32 damage = m_spellInfo->EffectBasePoints[i]+1;
 		uint32 man = (damage *(100+playerTarget->m_lifetapbonus))/100;
+		if (p_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= damage) return;
 		p_caster->DealDamage(playerTarget,damage,0,0,spellId);
 		playerTarget->ModUInt32Value(UNIT_FIELD_POWER1,man);
 		if(playerTarget->GetUInt32Value(UNIT_FIELD_POWER1) > playerTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1))
@@ -1079,6 +1080,7 @@
 			ILotP.procFlags = PROC_ON_CRIT_ATTACK | PROC_TAGRGET_SELF;
 			ILotP.deleted = false;
 			ILotP.caster = u_caster->GetGUID();
+			ILotP.ProcType = 0;
 			ILotP.LastTrigger = 0;
 			u_caster->m_procSpells.push_back(ILotP);
 		}
Index: src/game/Unit.cpp
===================================================================
--- src/game/Unit.cpp	(revision 5)
+++ src/game/Unit.cpp	(working copy)
@@ -372,6 +372,7 @@
 
 	//Get Highest Level Player, Calc Xp and give it to each group member
 	Player *pHighLvlPlayer = NULL;
+	Player *pHighLvlPlayerNot70 = NULL;
 	Player *pGroupGuy = NULL;
 	  int active_player_count=0;
 	Player *active_player_list[MAX_GROUP_SIZE_RAID];//since group is small we can afford to do this ratehr then recheck again the whole active player set
@@ -413,13 +414,16 @@
 				active_player_list[active_player_count]=pGroupGuy;
 				active_player_count++;
 				total_level += pGroupGuy->getLevel();
-				if(pHighLvlPlayer)
-				{
-					if(pGroupGuy->getLevel() > pHighLvlPlayer->getLevel())
-						pHighLvlPlayer = pGroupGuy;
-				}
-				else 
-					pHighLvlPlayer = pGroupGuy;
+				if(pHighLvlPlayerNot70)
+ 				{
+					if(pGroupGuy->getLevel() < 70)
+					{
+						if (pGroupGuy->getLevel() > pHighLvlPlayerNot70->getLevel())
+							pHighLvlPlayerNot70 = pGroupGuy;
+					}
+ 				}
+				else if(pGroupGuy->getLevel() < 70)
+					pHighLvlPlayerNot70 = pGroupGuy;
 			}
 		}
 	}
@@ -444,12 +448,17 @@
 		}
 		else if(pGroup->GetGroupType() == GROUP_TYPE_RAID)
 			xp_mod=0.5f;
-		if(pHighLvlPlayer == 0) pHighLvlPlayer = pGroup->GetLeader();
+		if(pHighLvlPlayerNot70 == 0 || !pHighLvlPlayerNot70) pHighLvlPlayerNot70 = pGroup->GetLeader();
 
-		xp = CalculateXpToGive(pVictim, pHighLvlPlayer);
+		xp = CalculateXpToGive(pVictim, pHighLvlPlayerNot70);
 		//i'm not sure about this formula is correct or not. Maybe some brackets are wrong placed ?
 		for(int i=0;i<active_player_count;i++)
-			active_player_list[i]->GiveXP( float2int32(((xp*active_player_list[i]->getLevel()) / total_level)*xp_mod), pVictim->GetGUID(), true );
+		{
+			if (active_player_list[i]->getLevel() < 70)
+				active_player_list[i]->GiveXP( float2int32(((xp*active_player_list[i]->getLevel()) / total_level)*xp_mod), pVictim->GetGUID(), true );
+			else
+				active_player_list[i]->GiveXP( 0, pVictim->GetGUID(), true );
+		}
 	}
 		/* old code start before 2007 04 22
 		GroupMembersSet::iterator itr;
@@ -496,7 +505,6 @@
 	bool can_delete = !bProcInUse;
 	bProcInUse = true;
 
-	std::list<uint32> remove;
 	std::list<struct ProcTriggerSpell>::iterator itr,itr2;
 	for( itr = m_procSpells.begin();itr != m_procSpells.end();)  // Proc Trigger Spells for Victim
 	{
@@ -577,6 +585,20 @@
 				//these are player talents. Fuckem they pull the emu speed down 
 				if(IsPlayer())
 				{
+					if (itr2->ProcType == 1 && static_cast<Player*>(this)->IsInFeralForm()) 
+					{
+						switch (static_cast<Player*>(this)->GetShapeShift())
+						{
+							case FORM_CAT:	
+							case FORM_BEAR: 
+							case FORM_DIREBEAR:
+								continue;
+								break;
+							default:
+								break;
+						}
+					}
+
 					uint32 talentlevel=0;
 					switch(origId)
 					{
@@ -894,7 +916,6 @@
 								uint32 dmg = static_cast<Player*>(this)->GetMainMeleeDamage(AP_owerride);
 								SpellEntry *sp_for_the_logs = dbcSpell.LookupEntry(spellId);
 								Strike(victim,MELEE,sp_for_the_logs,dmg,0,0,true,false);
-								Strike(victim,MELEE,sp_for_the_logs,dmg,0,0,true,false);
 								//nothing else to be done for this trigger
 								continue;
 							}break;
Index: src/shared/Database/DBCStores.h
===================================================================
--- src/shared/Database/DBCStores.h	(revision 5)
+++ src/shared/Database/DBCStores.h	(working copy)
@@ -350,6 +350,7 @@
 	bool removable_by_immunity;
 	uint32 in_front_status;
 	bool is_melee_spell;
+	uint32 dmg_bonus;
 };
 
 struct ItemExtendedCostEntry
