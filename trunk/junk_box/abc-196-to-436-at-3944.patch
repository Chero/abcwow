Index: ascent-shared/AscentConfig.h
===================================================================
--- ascent-shared/AscentConfig.h	(revision 3944)
+++ ascent-shared/AscentConfig.h	(working copy)
@@ -40,6 +40,9 @@
  * As of last update, it was nowhere near complete. Only enable for dev use.
  * Default: Disabled
  */
+
+//#define ENABLE_COLLISION 1
+
 #ifdef ENABLE_COLLISION
 # define COLLISION 1
 #endif
Index: ascent-shared/Database/DBCStores.h
===================================================================
--- ascent-shared/Database/DBCStores.h	(revision 3944)
+++ ascent-shared/Database/DBCStores.h	(working copy)
@@ -195,7 +195,7 @@
     uint32 Flags3;                          //9
     uint32 Flags4;                          //10 // Flags to
     uint32 field11;                         //11 // Flags....
-    uint32 unk201_1;                        //12 // Flags 2.0.1 unknown one
+    uint32 FlagsTargets;                    //12 0x0020 - only one target can be XXX at given time.
     uint32 RequiredShapeShift;              //13 // Flags BitMask for shapeshift spells
     uint32 UNK14;                           //14-> this is wrong // Flags BitMask for which shapeshift forms this spell can NOT be used in.
     uint32 Targets;                         //15 - N / M
@@ -344,7 +344,6 @@
     /// CUSTOM: these fields are used for the modifications made in the world.cpp
     uint32 DiminishStatus;                  //
     uint32 proc_interval;                   //!!! CUSTOM, <Fill description for variable>
-    uint32 buffIndexType;					//!!! CUSTOM, <Fill description for variable>
     uint32 c_is_flags;						//!!! CUSTOM, store spell checks in a static way : isdamageind,ishealing
     uint32 buffType;                        //!!! CUSTOM, these are related to creating a item through a spell
     uint32 RankNumber;                      //!!! CUSTOM, this protects players from having >1 rank of a spell
@@ -358,6 +357,7 @@
     uint32 EffectSpellGroupRelation_high[3];     //!!! this is not contained in client dbc but server must have it
 	uint32 ThreatForSpell;
 	bool can_be_dispelled;					//!!! CUSTOM
+	uint32 dmg_bonus;						//!!! CUSTOM, spell co-efficiency ( dmg/healing % taken from gear )
 };
 
 struct ItemExtendedCostEntry
Index: ascent-world/AIInterface.cpp
===================================================================
--- ascent-world/AIInterface.cpp	(revision 3944)
+++ ascent-world/AIInterface.cpp	(working copy)
@@ -107,6 +107,7 @@
 	waiting_for_cooldown = false;
 	UnitToFollow_backup = NULL;
 	m_isGuard = false;
+	m_isNeutralGuard = false;
 	m_is_in_instance=false;
 	skip_reset_hp=false;
 }
@@ -327,10 +328,7 @@
 				if( pUnit == NULL ) return;
 
 				CALL_SCRIPT_EVENT(m_Unit, OnDamageTaken)(pUnit, float(misc1));
-				if(!modThreatByPtr(pUnit, misc1))
-				{
-					m_aiTargets.insert(TargetMap::value_type(pUnit, misc1));
-				}
+				modThreatByPtr(pUnit, misc1);
 				m_Unit->CombatStatus.OnDamageDealt(pUnit);
 			}break;
 		case EVENT_FOLLOWOWNER:
@@ -954,7 +952,7 @@
 #ifdef ENABLE_CREATURE_DAZE
 							//now if the target is facing his back to us then we could just cast dazed on him :P
 							//as far as i know dazed is casted by most of the creatures but feel free to remove this code if you think otherwise
-							if(m_nextTarget &&
+							if(m_nextTarget && m_Unit->m_factionDBC && m_Unit->m_faction &&
 								!(m_Unit->m_factionDBC->RepListId == -1 && m_Unit->m_faction->FriendlyMask==0 && m_Unit->m_faction->HostileMask==0) /* neutral creature */
 								&& m_nextTarget->IsPlayer() && !m_Unit->IsPet() && health_before_strike>m_nextTarget->GetUInt32Value(UNIT_FIELD_HEALTH)
 								&& Rand(m_Unit->get_chance_to_daze(m_nextTarget)))
@@ -1253,7 +1251,7 @@
 
 void AIInterface::AttackReaction(Unit* pUnit, uint32 damage_dealt, uint32 spellId)
 {
-	if( m_AIState == STATE_EVADE || m_fleeTimer != 0 || !pUnit || !pUnit->isAlive() || m_Unit->IsPacified() || m_Unit->IsStunned() || !m_Unit->isAlive() )
+	if( m_AIState == STATE_EVADE || m_fleeTimer != 0 || !pUnit || !pUnit->isAlive() || m_Unit->IsPacified() || m_Unit->IsFeared() || m_Unit->IsStunned() || !m_Unit->isAlive() )
 	{
 		return;
 	}
@@ -1277,7 +1275,6 @@
 {
 	if(!caster || !victim)
 	{
-		printf("!!!BAD POINTER IN AIInterface::HealReaction!!!\n");
 		return false;
 	}
 
@@ -1289,21 +1286,6 @@
 	if(m_aiTargets.find(victim) != m_aiTargets.end())
 		victimInList = 1;
 
-	/*for(i = m_aiTargets.begin(); i != m_aiTargets.end(); i++)
-	{
-		if(casterInList && victimInList)
-		{ // no need to check the rest, just break that
-			break;
-		}
-		if(i->target == victim)
-		{
-			victimInList = true;
-		}
-		if(i->target == caster)
-		{
-			casterInList = true;
-		}
-	}*/
 	if(!victimInList && !casterInList) // none of the Casters is in the Creatures Threat list
 	{
 		return false;
@@ -1313,10 +1295,6 @@
 		// get caster into combat if he's hostile
 		if(isHostile(m_Unit, caster))
 		{
-			//AI_Target trgt;
-			//trgt.target = caster;
-			//trgt.threat = amount;
-			//m_aiTargets.push_back(trgt);
 			m_aiTargets.insert(TargetMap::value_type(caster, amount));
 			return true;
 		}
@@ -1391,7 +1369,59 @@
 	{
 		return 0;
 	}
+	if (m_isNeutralGuard)
+	{
+		Player *tmpPlr;
+		for (std::set<Player*>::iterator itrPlr = m_Unit->GetInRangePlayerSetBegin(); itrPlr != m_Unit->GetInRangePlayerSetEnd(); ++itrPlr)
+		{
+			tmpPlr = (*itrPlr);
+			if (tmpPlr == NULL)
+				continue;
+			if (tmpPlr->GetTaxiState())
+				continue;
+			if (tmpPlr->bInvincible)
+				continue;
+			if (tmpPlr->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FEIGN_DEATH))
+				continue;
+			if (tmpPlr->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_9))
+				continue;
+			if (tmpPlr->m_invisible)
+				continue;
+			if (tmpPlr->CombatStatus.GetPrimaryAttackTarget() == NULL)
+				continue;
+			else
+			{
+				Unit *pPTarget = GetUnit()->GetMapMgr()->GetUnit( tmpPlr->CombatStatus.GetPrimaryAttackTarget() );
+				if( pPTarget != NULL && !pPTarget->IsPlayer() )
+					continue;
+				if (tmpPlr->DuelingWith == static_cast<Player*>(pPTarget))
+					continue;
+			}
 
+			dist = m_Unit->GetDistanceSq(tmpPlr);
+
+			if (dist > 2500.0f)
+				continue;
+			if (distance > dist)
+			{
+				distance = dist;
+				target = static_cast<Unit*>(tmpPlr);
+			}
+		}
+		if (target)
+		{
+			m_Unit->m_runSpeed = m_Unit->m_base_runSpeed * 2.0f;
+			AttackReaction(target, 1, 0);
+
+			WorldPacket data(SMSG_AI_REACTION, 12);
+			data << m_Unit->GetGUID() << uint32(2);		// Aggro sound
+			static_cast< Player* >( target )->GetSession()->SendPacket( &data );
+
+			return target;
+		}
+		distance = 999999.0f; //Reset Distance for normal check
+	}
+
 	for( itr = m_Unit->GetInRangeOppFactsSetBegin(); itr != m_Unit->GetInRangeOppFactsSetEnd(); )
 	{
 		it2 = itr;
@@ -1427,20 +1457,6 @@
 				continue;
 			}
 		}
-
-		/* neutral guard that attacks pvpers */
-		/*
-		if( m_Unit->IsNeutralGuard() )
-		{
-			if( pUnit->IsPlayer() && pUnit->CombatStatus.GetPrimaryAttackTarget() )
-			{
-				// get the target of the potential target :P
-				Unit * pPTarget = GetUnit()->GetMapMgr()->GetUnit( pUnit->CombatStatus.GetPrimaryAttackTarget() );
-				if( !pPTarget->IsPlayer() )
-					continue;
-			}
-		}
-		*/
 		/* is it a player? we have to check for our pvp flag. */
 //		if(m_U)
 		crange = _CalcCombatRange(pUnit,false);
@@ -2704,7 +2720,7 @@
 	}
 
 	//Fear Code
-	if(m_AIState == STATE_FEAR && UnitToFear != NULL && m_creatureState == STOPPED)
+	if(m_AIState == STATE_FEAR && UnitToFear != NULL && !m_Unit->IsPlayer() && m_creatureState == STOPPED)
 	{
 		if(getMSTime() > m_FearTimer)   // Wait at point for x ms ;)
 		{
@@ -2768,7 +2784,7 @@
 	}
 
 	// Wander AI movement code
-	if(m_AIState == STATE_WANDER && m_creatureState == STOPPED)
+	if(m_AIState == STATE_WANDER && !m_Unit->IsPlayer() && m_creatureState == STOPPED)
 	{
 		if(getMSTime() < m_WanderTimer) // is it time to move again?
 			return;
@@ -3601,6 +3617,43 @@
 	return false;
 }
 
+bool isNeutralGuard(uint32 id)
+{
+	switch(id)
+	{
+		// Ratchet
+	case 3502:
+		// Booty Bay
+	case 4624:
+		// Gadgetzan
+	case 9460:
+		// Moonglade
+	case 11822:
+		// Everlook
+	case 11190:
+		// Cenarion Refuge
+	case 17855:
+		// Throne of the elements
+	case 18099:
+	case 18101:
+	case 18102:
+		// Area 52
+	case 20484:
+	case 20485:
+		// Cosmowrench
+	case 22494:
+		// Mudsprocket
+	case 23636:
+		// Concert Bruiser
+	case 23721:
+		{
+			return true;
+		}
+		break;
+	}
+	return false;
+}
+
 void AIInterface::WipeCurrentTarget()
 {
 	TargetMap::iterator itr = m_aiTargets.find( m_nextTarget );
@@ -3659,11 +3712,11 @@
 {
 	__try
 	{
-		if( ptr->event_GetCurrentInstanceId() != m_Unit->event_GetCurrentInstanceId() ||
-			!ptr->isAlive() || m_Unit->GetDistanceSq(ptr) >= 6400.0f )
-		{
+		bool boss = false;
+		if (m_Unit->GetTypeId() == TYPEID_UNIT && static_cast<Creature*>(m_Unit)->GetCreatureName() && static_cast<Creature*>(m_Unit)->GetCreatureName()->Rank == 3)
+			boss = true;
+		if( ptr->event_GetCurrentInstanceId() != m_Unit->event_GetCurrentInstanceId() || !ptr->isAlive() || (!boss && m_Unit->GetDistanceSq(ptr) >= 6400.0f))
 			return false;
-		}
 	}
 	__except(EXCEPTION_EXECUTE_HANDLER)
 	{
Index: ascent-world/AIInterface.h
===================================================================
--- ascent-world/AIInterface.h	(revision 3944)
+++ ascent-world/AIInterface.h	(working copy)
@@ -183,6 +183,7 @@
 };
 
 bool isGuard(uint32 id);
+bool isNeutralGuard(uint32 id);
 uint32 getGuardId(uint32 id);
 
 #if ENABLE_SHITTY_STL_HACKS == 1
@@ -417,6 +418,7 @@
 
 	ASCENT_INLINE void SetWaypointMap( WayPointMap* m ) { m_waypoints = m; }
 	bool m_isGuard;
+	bool m_isNeutralGuard;
 //	bool m_fastMove;
 	void setGuardTimer(uint32 timer) { m_guardTimer = timer; }
 	virtual void _UpdateCombat(uint32 p_time);
Index: ascent-world/ArathiBasin.cpp
===================================================================
--- ascent-world/ArathiBasin.cpp	(revision 3944)
+++ ascent-world/ArathiBasin.cpp	(working copy)
@@ -406,6 +406,16 @@
 
 void ArathiBasin::OnStart()
 {
+	m_started = true;
+
+	for(uint32 i = 0; i < 2; ++i) {
+		for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr) {
+			Player *plr = objmgr.GetPlayer(*itr);
+			if ( plr != NULL )
+				plr->RemoveAura(BG_PREPARATION);
+		}
+	}
+
 	// open gates
 	for(list<GameObject*>::iterator itr = m_gates.begin(); itr != m_gates.end(); ++itr)
 	{
@@ -482,9 +492,12 @@
 	if((current_resources - m_lastHonorGainResources[Team]) >= RESOURCES_TO_GAIN_BH)
 	{
 		m_mainLock.Acquire();
-		for(set<Player*>::iterator itr = m_players[Team].begin(); itr != m_players[Team].end(); ++itr)
-			(*itr)->m_bgScore.BonusHonor += BASE_BH_GAIN;
-
+		for(set<uint32>::iterator itr = m_players[Team].begin(); itr != m_players[Team].end(); ++itr)
+		{
+			Player *plr = objmgr.GetPlayer(*itr);
+			if ( plr != NULL )
+				plr->m_bgScore.BonusHonor += BASE_BH_GAIN;
+		}
 		UpdatePvPData();
 		m_mainLock.Release();
 	}
@@ -509,13 +522,17 @@
 		SpellEntry * loser_spell = dbcSpell.LookupEntry(24952);
 		for(uint32 i = 0; i < 2; ++i)
 		{
-			for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+			for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
 			{
-				(*itr)->Root();
-				if(i == m_winningteam)
-					(*itr)->CastSpell((*itr), winner_spell, true);
-				else
-					(*itr)->CastSpell((*itr), loser_spell, true);
+				Player *plr = objmgr.GetPlayer(*itr);
+				if ( plr != NULL )
+				{
+					plr->Root();
+					if(i == m_winningteam)
+						plr->CastSpell(plr, winner_spell, true);
+					else
+						plr->CastSpell(plr, loser_spell, true);
+				}
 			}
 		}
 		m_mainLock.Release();
@@ -551,12 +568,13 @@
 
 void ArathiBasin::OnAddPlayer(Player * plr)
 {
-	// nothing?
+	if(!m_started)
+		plr->CastSpell(plr, BG_PREPARATION, true);
 }
 
 void ArathiBasin::OnRemovePlayer(Player * plr)
 {
-	// nothing?
+	plr->RemoveAura(BG_PREPARATION);
 }
 
 void ArathiBasin::HookFlagDrop(Player * plr, GameObject * obj)
Index: ascent-world/AreaTrigger.cpp
===================================================================
--- ascent-world/AreaTrigger.cpp	(revision 3944)
+++ ascent-world/AreaTrigger.cpp	(working copy)
@@ -129,7 +129,8 @@
 	}
 
 	// Hook for Scripted Areatriggers
-	_player->GetMapMgr()->HookOnAreaTrigger(_player, id);
+	if (_player->GetMapMgr())
+		_player->GetMapMgr()->HookOnAreaTrigger(_player, id);
 
 	switch(pAreaTrigger->Type)
 	{
Index: ascent-world/Arenas.cpp
===================================================================
--- ascent-world/Arenas.cpp	(revision 3944)
+++ ascent-world/Arenas.cpp	(working copy)
@@ -48,6 +48,9 @@
 		break;
 	}
 	rated_match=false;
+
+	for (uint32 i = 0; i < 2; ++i)
+		inscribe_teams[i] = 0;
 }
 
 Arena::~Arena()
@@ -99,14 +102,14 @@
 	if(rated_match && plr->m_arenaTeams[m_arenateamtype] != NULL)
 	{
 		ArenaTeam * t = plr->m_arenaTeams[m_arenateamtype];
-		ArenaTeamMember * tp = t->GetMember(plr->m_playerInfo);
-		if(doneteams.find(t) == doneteams.end())
+		if ( t != NULL && inscribe_teams[plr->m_bgTeam] == 0 )
 		{
 			t->m_stat_gamesplayedseason++;
 			t->m_stat_gamesplayedweek++;
-			doneteams.insert(t);
+			inscribe_teams[plr->m_bgTeam] = t->m_id;
 		}
 
+		ArenaTeamMember * tp = t->GetMember(plr->m_playerInfo);
 		if(tp != NULL)
 		{
 			tp->Played_ThisWeek++;
@@ -242,8 +245,10 @@
 {
 	/* remove arena readyness buff */
 	for(uint32 i = 0; i < 2; ++i) {
-		for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr) {
-			(*itr)->RemoveAura(ARENA_PREPARATION);
+		for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr) {
+			Player *plr = objmgr.GetPlayer(*itr);
+			if ( plr != NULL )
+				plr->RemoveAura(ARENA_PREPARATION);
 		}
 	}
 
@@ -266,9 +271,12 @@
 		return;
 
 	uint32 players[2] = {0,0};
-	for(uint32 i = 0; i < 2; ++i) {
-		for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr) {
-			if((*itr)->isAlive())
+	for(uint32 i = 0; i < 2; ++i)
+	{
+		for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+		{
+			Player *plr = objmgr.GetPlayer(*itr);
+			if ( plr != NULL && plr->isAlive() )
 				players[i]++;
 		}
 	}
@@ -300,90 +308,62 @@
 	sEventMgr.AddEvent(((CBattleground*)this), &CBattleground::Close, EVENT_BATTLEGROUND_CLOSE, 120000, 1,0);
 
 	/* update arena team stats */
-	doneteams.clear();
 	if(rated_match)
 	{
-		uint32 averageRating[2] = {0,0};
-		for(uint32 i = 0; i < 2; ++i) {
-			uint32 teamCount = 0;
-			for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
-			{
-				Player * plr = *itr;
-				if(plr->m_arenaTeams[m_arenateamtype] != NULL)
-				{
-					ArenaTeam * t = plr->m_arenaTeams[m_arenateamtype];
-					if(doneteams.find(t) == doneteams.end())
-					{
-						averageRating[i] += t->m_stat_rating;
-						teamCount++;
-						doneteams.insert(t);
-					}
-				}
-			}
-			if(teamCount)
-				averageRating[i] /= teamCount;
-		}
-		doneteams.clear();
-		for (uint32 i = 0; i < 2; ++i) {
+		ArenaTeam *teams[2];
+		teams[0] = objmgr.GetArenaTeamById(inscribe_teams[0]);
+		teams[1] = objmgr.GetArenaTeamById(inscribe_teams[1]);
+
+		if ( teams[0] == NULL || teams[1] == NULL )
+			return;
+
+		for (uint32 i = 0; i < 2; ++i)
+		{
 			uint32 j = i ? 0 : 1; // opposing side
 			bool outcome;
 
 			outcome = (i == m_winningteam);
 
-			// ---- Elo Rating System ----
-			// Expected Chance to Win for Team A vs Team B
-			//                     1
-			// -------------------------------------------
-			//                   (PB - PA)/400
-			//              1 + 10
-
-			double power = (int)(averageRating[j] - averageRating[i]) / 400.0f;
+			double power = (int)( teams[j]->m_stat_rating - teams[i]->m_stat_rating ) / 400.0f;
 			double divisor = pow(((double)(10.0)), power);
 			divisor += 1.0;
-
 			double winChance = 1.0 / divisor;
 
-			for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+			if (outcome)
 			{
-				Player * plr = *itr;
-				if(plr->m_arenaTeams[m_arenateamtype] != NULL)
+				teams[i]->m_stat_gameswonseason++;
+				teams[i]->m_stat_gameswonweek++;
+			}
+
+			double multiplier = (outcome ? 1.0 : 0.0) - winChance;
+			double deltaRating = 32.0 * multiplier;
+			if ( deltaRating < 0 && (-1.0 * deltaRating) > teams[i]->m_stat_rating )
+				teams[i]->m_stat_rating = 0;
+			else
+				teams[i]->m_stat_rating += long2int32(deltaRating);
+			objmgr.UpdateArenaTeamRankings();
+
+			teams[i]->SaveToDB();
+
+			for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+			{
+				Player *plr = objmgr.GetPlayer(*itr);
+				if( plr != NULL && plr->m_arenaTeams[m_arenateamtype] != NULL )
 				{
 					ArenaTeam * t = plr->m_arenaTeams[m_arenateamtype];
 					ArenaTeamMember * tp = t->GetMember(plr->m_playerInfo);
-					if(doneteams.find(t) == doneteams.end())
-					{
-						if (outcome)
-						{
-							t->m_stat_gameswonseason++;
-							t->m_stat_gameswonweek++;
-						}
-						// New Rating Calculation via Elo
-						// New Rating = Old Rating + K * (outcome - Expected Win Chance)
-						// outcome = 1 for a win and 0 for a loss (0.5 for a draw ... but we cant have that)
-						// K is the maximum possible change
-						// Through investigation, K was estimated to be 32 (same as chess)
-						double multiplier = (outcome ? 1.0 : 0.0) - winChance;
-						double deltaRating = 32.0 * multiplier;
-						if ( deltaRating < 0 && (-1.0 * deltaRating) > t->m_stat_rating )
-							t->m_stat_rating = 0;
-						else
-							t->m_stat_rating += long2int32(deltaRating);
-						objmgr.UpdateArenaTeamRankings();
 
-						doneteams.insert(t);
-					}
-
-					if(tp != NULL && outcome)
+					if( tp != NULL && outcome )
 					{
 						tp->Won_ThisWeek++;
 						tp->Won_ThisSeason++;
 					}
-
-					t->SaveToDB();
 				}
 			}
+
 		}
 	}
+
 }
 
 LocationVector Arena::GetStartingCoords(uint32 Team)
Index: ascent-world/Arenas.h
===================================================================
--- ascent-world/Arenas.h	(revision 3944)
+++ ascent-world/Arenas.h	(working copy)
@@ -22,7 +22,7 @@
 class Arena : public CBattleground
 {
 	set<GameObject*> m_gates;
-	set<ArenaTeam*> doneteams;
+	uint32 inscribe_teams[2];
 	bool m_started;
 	uint32 m_arenateamtype;
 public:
Index: ascent-world/ArenaTeam.cpp
===================================================================
--- ascent-world/ArenaTeam.cpp	(revision 3944)
+++ ascent-world/ArenaTeam.cpp	(working copy)
@@ -304,6 +304,16 @@
 	return NULL;
 }
 
+ArenaTeamMember * ArenaTeam::GetMemberByGuid(uint32 guid)
+{
+	for(uint32 i = 0; i < m_memberCount; ++i)
+	{
+		if(m_members[i].Info && m_members[i].Info->guid == guid)
+			return &m_members[i];
+	}
+	return NULL;
+}
+
 void WorldSession::HandleArenaTeamRosterOpcode(WorldPacket & recv_data)
 {
 	uint8 slot;
Index: ascent-world/ArenaTeam.h
===================================================================
--- ascent-world/ArenaTeam.h	(revision 3944)
+++ ascent-world/ArenaTeam.h	(working copy)
@@ -90,6 +90,7 @@
 	bool HasMember(uint32 guid);
 	void SetLeader(PlayerInfo * info);
 	ArenaTeamMember * GetMember(PlayerInfo * info);
+	ArenaTeamMember * GetMemberByGuid(uint32 guid);
 
 	uint32 GetPlayersPerTeam()
 	{
Index: ascent-world/BattlegroundCommands.cpp
===================================================================
--- ascent-world/BattlegroundCommands.cpp	(revision 3944)
+++ ascent-world/BattlegroundCommands.cpp	(working copy)
@@ -42,7 +42,7 @@
 bool ChatHandler::HandleBattlegroundCommand(const char* args, WorldSession *m_session)
 {
 	uint32 type = atoi(args);
-	if(type != 2 && type != 3 && type != 4 && type != 5)
+	if(type != 2 && type != 3 && type != 4 && type != 5 && type != 7)
 		return false;
 
 	Player * plr = getSelectedChar(m_session, true);
Index: ascent-world/BattlegroundHandler.cpp
===================================================================
--- ascent-world/BattlegroundHandler.cpp	(revision 3944)
+++ ascent-world/BattlegroundHandler.cpp	(working copy)
@@ -76,6 +76,8 @@
 			t = BATTLEGROUND_ARATHI_BASIN;
 		else if(strstr(pCreature->GetCreatureName()->SubName, "Warsong") != NULL)
 			t = BATTLEGROUND_WARSUNG_GULCH;
+		else if(strstr(pCreature->GetCreatureName()->SubName, "Eye") != NULL)
+			t = BATTLEGROUND_EYE_OF_THE_STORM;
 	}
 
     BattlegroundManager.HandleBattlegroundListPacket(this, t);
Index: ascent-world/BattlegroundMgr.cpp
===================================================================
--- ascent-world/BattlegroundMgr.cpp	(revision 3944)
+++ ascent-world/BattlegroundMgr.cpp	(working copy)
@@ -18,9 +18,6 @@
  */
 
 #include "StdAfx.h"
-
-#define ENABLE_AB
-//#define ENABLE_EOTS
 //#define ONLY_ONE_PERSON_REQUIRED_TO_JOIN_DEBUG
 
 initialiseSingleton(CBattlegroundManager);
@@ -41,19 +38,11 @@
 	NULL,						// 0
 	NULL,						// AV
 	&WarsongGulch::Create,		// WSG
-#ifdef ENABLE_AB
 	&ArathiBasin::Create,		// AB
-#else
-	NULL,						// AB
-#endif
 	NULL,						// 2v2
 	NULL,						// 3v3
 	NULL,						// 5v5
-#ifdef ENABLE_EOTS
 	&EyeOfTheStorm::Create,		// Netherstorm
-#else
-	NULL,						// Netherstorm
-#endif
 };
 
 CBattlegroundManager::CBattlegroundManager() : EventableObject()
@@ -113,7 +102,7 @@
 	uint32 instance;
 
 	pck >> guid >> bgtype >> instance;
-	if(bgtype >= BATTLEGROUND_NUM_TYPES)
+	if(bgtype >= BATTLEGROUND_NUM_TYPES || guid == 0 )
 		return;		// cheater!
 
 	/* Check the instance id */
@@ -271,11 +260,25 @@
 					}
 				}
 			}
+			
+			uint32 pInTeam = 1;
+			switch(i)
+			{
+			case BATTLEGROUND_ARENA_2V2:
+				pInTeam = 1;
+			break;
+			case BATTLEGROUND_ARENA_3V3:
+				pInTeam = 3;
+			break;
+			case BATTLEGROUND_ARENA_5V5:
+				pInTeam = 5;
+			break;
+			}
 
 			if(IS_ARENA(i))
 			{
 				// enough players to start a round?
-				if(tempPlayerVec[0].size() < 2)
+				if(tempPlayerVec[0].size() < 2*pInTeam )
 					continue;
 
 				if(CanCreateInstance(i,j))
@@ -287,7 +290,6 @@
 						plr = *tempPlayerVec[0].begin();
 						tempPlayerVec[0].pop_front();
 
-						plr->m_bgTeam=team;
 						arena->AddPlayer(plr, team);
 						team = arena->GetFreeTeam();
 
@@ -299,8 +301,7 @@
 			else
 			{
 #ifdef ONLY_ONE_PERSON_REQUIRED_TO_JOIN_DEBUG
-				if(tempPlayerVec[0].size() >= MINIMUM_PLAYERS_ON_EACH_SIDE_FOR_BG ||
-					tempPlayerVec[1].size() >= MINIMUM_PLAYERS_ON_EACH_SIDE_FOR_BG)
+				if(tempPlayerVec[0].size() >= 1 || tempPlayerVec[1].size() >= 1)
 #else
 				if(tempPlayerVec[0].size() >= MINIMUM_PLAYERS_ON_EACH_SIDE_FOR_BG &&
 					tempPlayerVec[1].size() >= MINIMUM_PLAYERS_ON_EACH_SIDE_FOR_BG)
@@ -318,7 +319,6 @@
 							{
 								plr = *tempPlayerVec[k].begin();
 								tempPlayerVec[k].pop_front();
-								plr->m_bgTeam=k;
 								bg->AddPlayer(plr, k);
 								ErasePlayerFromList(plr->GetGUIDLow(), &m_queuedPlayers[i][j]);
 							}
@@ -492,6 +492,7 @@
 	case  529: bflag = 0x0D1E; break;
 	case   30: bflag = 0x0A25; break;
 	case  559: bflag = 3698; break;
+	case  566: bflag = 0x0eec; bflag2 = 0; break;			// EOTS
 	
 	default:		/* arenas */
 		bflag  = 0x0E76;
@@ -515,37 +516,36 @@
 	m_nextPvPUpdateTime = 0;
 	m_countdownStage = 0;
 	m_ended = false;
+	m_started = false;
 	m_winningteam = 0;
 	m_startTime = (uint32)UNIXTIME;
 	m_lastResurrect = (uint32)UNIXTIME;
 	sEventMgr.AddEvent(this, &CBattleground::EventResurrectPlayers, EVENT_BATTLEGROUND_QUEUE_UPDATE, 30000, 0,0);
 
 	/* create raid groups */
-	/*for(uint32 i = 0; i < 2; ++i)
+	for(uint32 i = 0; i < 2; ++i)
 	{
-		m_groups[i] = new Group();
+		m_groups[i] = new Group(true);
 		m_groups[i]->m_disbandOnNoMembers = false;
 		m_groups[i]->ExpandToRaid();
-	}*/
+	}
 }
 
 CBattleground::~CBattleground()
 {
 	sEventMgr.RemoveEvents(this);
-	/*for(uint32 i = 0; i < 2; ++i)
+	for(uint32 i = 0; i < 2; ++i)
 	{
-		Player * plr;
 		PlayerInfo *inf;
 		for(uint32 j = 0; j < m_groups[i]->GetSubGroupCount(); ++j) {
 			for(GroupMembersSet::iterator itr = m_groups[i]->GetSubGroup(j)->GetGroupMembersBegin(); itr != m_groups[i]->GetSubGroup(j)->GetGroupMembersEnd();) {
-				plr = itr->player;
-				inf = itr->player_info;
-				++itr;
-				m_groups[i]->RemovePlayer(inf, plr, true);
+				inf = (*itr);
+ 				++itr;
+				m_groups[i]->RemovePlayer(inf);
 			}
 		}
 		delete m_groups[i];
-	}*/
+	}
 }
 
 void CBattleground::UpdatePvPData()
@@ -597,11 +597,15 @@
 			ArenaTeam * teams[2] = {NULL,NULL};
 			for(uint32 i = 0; i < 2; ++i)
 			{
-				for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+				for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
 				{
-					teams[i] = (*itr)->m_arenaTeams[ ((Arena*)this)->GetArenaTeamType() ];
-					if(teams[i])
-						break;
+					Player *plr = objmgr.GetPlayer(*itr);
+					if( plr != NULL )
+					{
+						teams[i] = plr->m_arenaTeams[ ((Arena*)this)->GetArenaTeamType() ];
+						if( teams[i] != NULL )
+							break;
+					}
 				}
 			}
 
@@ -634,16 +638,20 @@
 		*data << uint32(m_players[0].size() + m_players[1].size());
 		for(uint32 i = 0; i < 2; ++i)
 		{
-			for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+			for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
 			{
-				*data << (*itr)->GetGUID();
-				bs = &(*itr)->m_bgScore;
-				*data << bs->KillingBlows;
-				*data << uint8((*itr)->m_bgTeam);
-				*data << bs->DamageDone;
-				*data << bs->HealingDone;
-				*data << bs->Misc1;	/* rating change */
-				//(*itr)->Root();
+				Player *plr = objmgr.GetPlayer(*itr);
+				if( plr != NULL )
+				{
+					*data << plr->GetGUID();
+					bs = &plr->m_bgScore;
+					*data << bs->KillingBlows;
+					*data << uint8(plr->m_bgTeam);
+					*data << bs->DamageDone;
+					*data << bs->HealingDone;
+					*data << bs->Misc1;	/* rating change */
+					//(*itr)->Root();
+				}
 			}
 		}
 	}
@@ -661,20 +669,24 @@
 		*data << uint32(m_players[0].size() + m_players[1].size());
 		for(uint32 i = 0; i < 2; ++i)
 		{
-			for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+			for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
 			{
-				*data << (*itr)->GetGUID();
-				bs = &(*itr)->m_bgScore;
+				Player *plr = objmgr.GetPlayer(*itr);
+				if( plr != NULL )
+				{
+					*data << plr->GetGUID();
+					bs = &plr->m_bgScore;
 
-				*data << bs->KillingBlows;
-				*data << bs->HonorableKills;
-				*data << bs->Deaths;
-				*data << bs->BonusHonor;
-				*data << bs->DamageDone;
-				*data << bs->HealingDone;
-				*data << uint32(0x2);
-				*data << bs->Misc1;
-				*data << bs->Misc2;
+					*data << bs->KillingBlows;
+					*data << bs->HonorableKills;
+					*data << bs->Deaths;
+					*data << bs->BonusHonor;
+					*data << bs->DamageDone;
+					*data << bs->HealingDone;
+					*data << uint32(0x2);
+					*data << bs->Misc1;
+					*data << bs->Misc2;
+				}
 			}
 		}
 	}
@@ -684,6 +696,8 @@
 {
 	m_mainLock.Acquire();
 
+	plr->m_bgTeam = team;
+
 	/* This is called when the player is added, not when they port. So, they're essentially still queued, but not inside the bg yet */
 	m_pendPlayers[team].insert(plr->GetGUIDLow());
 
@@ -700,6 +714,9 @@
 void CBattleground::RemovePendingPlayer(Player * plr)
 {
 	m_mainLock.Acquire();
+
+	if( plr->m_bgTeam > 1 )
+		plr->m_bgTeam = plr->GetTeam();
 	m_pendPlayers[plr->m_bgTeam].erase(plr->GetGUIDLow());
 
 	/* send a null bg update (so they don't join) */
@@ -710,6 +727,15 @@
 	m_mainLock.Release();
 }
 
+void CBattleground::OnPlayerPushed(Player * plr)
+{
+	if(plr->GetGroup())
+		plr->GetGroup()->RemovePlayer(plr->m_playerInfo);
+
+	plr->ProcessPendingUpdates();
+	m_groups[plr->m_bgTeam]->AddMember( plr->m_playerInfo );
+}
+
 void CBattleground::PortPlayer(Player * plr, bool skip_teleport /* = false*/)
 {
 	m_mainLock.Acquire();
@@ -722,19 +748,21 @@
 		return;
 	}
 
+	if( plr->m_bgTeam > 1 )
+		plr->m_bgTeam = plr->GetTeam();
+
 	m_pendPlayers[plr->m_bgTeam].erase(plr->GetGUIDLow());
-	if(m_players[plr->m_bgTeam].find(plr) != m_players[plr->m_bgTeam].end())
+	if(m_players[plr->m_bgTeam].find(plr->GetGUIDLow()) != m_players[plr->m_bgTeam].end())
 	{
 		m_mainLock.Release();
 		return;
 	}
 
-	plr->SetTeam(plr->m_bgTeam);
 	WorldPacket data(SMSG_BATTLEGROUND_PLAYER_JOINED, 8);
 	data << plr->GetGUID();
 	DistributePacketToAll(&data);
 
-	m_players[plr->m_bgTeam].insert(plr);
+	m_players[plr->m_bgTeam].insert(plr->GetGUIDLow());
 
 	/* remove from any auto queue remove events */
 	sEventMgr.RemoveEvents(plr, EVENT_BATTLEGROUND_QUEUE_UPDATE);
@@ -761,14 +789,12 @@
 	UpdatePvPData();
 
 	/* add the player to the group */
-	/*if(plr->GetGroup())
+	if(plr->GetGroup())
 	{
 		// remove them from their group
-		plr->GetGroup()->RemovePlayer(plr->m_playerInfo, plr, true);
+		plr->GetGroup()->RemovePlayer(plr->m_playerInfo);
 	}
 
-	m_groups[plr->m_bgTeam]->AddMember(plr->m_playerInfo, plr);*/
-
 	if(!m_countdownStage)
 	{
 		m_countdownStage = 1;
@@ -799,9 +825,9 @@
 	if(Type == BATTLEGROUND_ARENA_2V2 || Type == BATTLEGROUND_ARENA_3V3 || Type == BATTLEGROUND_ARENA_5V5)
 	{
 		/* arenas follow a different procedure. */
-		static const uint32 arena_map_ids[3] = { 559, 562, 572 };
-		uint32 mapid = arena_map_ids[RandomUInt(2)];
-		mapid=562;
+		static const uint32 arena_map_ids[2] = { 562, 572 };
+//		static const uint32 arena_map_ids[3] = { 559, 562, 572 };
+		uint32 mapid = arena_map_ids[RandomUInt(1)];
 		uint32 players_per_side;
 		mgr = sInstanceMgr.CreateBattlegroundInstance(mapid);
 		if(mgr == NULL)
@@ -940,8 +966,12 @@
 	m_mainLock.Acquire();
 	for(int i = 0; i < 2; ++i)
 	{
-		for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
-			(*itr)->GetSession()->SendPacket(packet);
+		for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+		{
+			Player *plr = objmgr.GetPlayer(*itr);
+			if( plr != NULL && plr->GetSession())
+				plr->GetSession()->SendPacket(packet);
+		}
 	}
 	m_mainLock.Release();
 }
@@ -949,8 +979,12 @@
 void CBattleground::DistributePacketToTeam(WorldPacket * packet, uint32 Team)
 {
 	m_mainLock.Acquire();
-	for(set<Player*>::iterator itr = m_players[Team].begin(); itr != m_players[Team].end(); ++itr)
-		(*itr)->GetSession()->SendPacket(packet);
+	for(set<uint32>::iterator itr = m_players[Team].begin(); itr != m_players[Team].end(); ++itr)
+	{
+		Player *plr = objmgr.GetPlayer(*itr);
+		if( plr != NULL && plr->GetSession())
+			plr->GetSession()->SendPacket(packet);
+	}
 	m_mainLock.Release();
 }
 
@@ -1033,19 +1067,24 @@
 void CBattleground::RemovePlayer(Player * plr, bool logout)
 {
 	WorldPacket data(SMSG_BATTLEGROUND_PLAYER_LEFT, 30);
-	data << plr->GetGUID();
+	if ( plr->m_isGmInvisible == false )
+	{ //Dont show invisble gm's leaving the game.
+		data << plr->GetGUID();
+		DistributePacketToAll(&data);
+	}
 
 	m_mainLock.Acquire();
-	m_players[plr->m_bgTeam].erase(plr);
-	DistributePacketToAll(&data);
+	if( plr->m_bgTeam > 1 )
+		plr->m_bgTeam = plr->GetTeam();
+	m_players[plr->m_bgTeam].erase(plr->GetGUIDLow());
 
 	memset(&plr->m_bgScore, 0, sizeof(BGScore));
 	OnRemovePlayer(plr);
 	plr->m_bg = 0;
 
 	/* are we in the group? */
-	/*if(plr->GetGroup() == m_groups[plr->m_bgTeam])
-		plr->GetGroup()->RemovePlayer(plr->m_playerInfo, plr, true);*/
+	if( plr->GetGroup() != NULL && plr->GetGroup() == m_groups[plr->m_bgTeam])
+		plr->GetGroup()->RemovePlayer( plr->m_playerInfo );
 
 	// reset team
 	plr->ResetTeam();
@@ -1086,7 +1125,6 @@
 		sEventMgr.AddEvent( this, &CBattleground::Close, EVENT_BATTLEGROUND_CLOSE, 120000, 1, 0 ); // 2 mins
 	}
 
-	plr->m_bgTeam=plr->GetTeam();
 	m_mainLock.Release();
 }
 
@@ -1171,22 +1209,22 @@
 	m_ended = true;
 	for(uint32 i = 0; i < 2; ++i)
 	{
-		set<Player*>::iterator itr;
+		set<uint32>::iterator itr;
 		set<uint32>::iterator it2;
-		uint32 guid;
-		Player * plr;
 		for(itr = m_players[i].begin(); itr != m_players[i].end();)
 		{
-			plr = *itr;
+			uint32 guid = *itr;
 			++itr;
-			RemovePlayer(plr, false);
+			Player *plr = objmgr.GetPlayer(guid);
+			if ( plr != NULL )
+				RemovePlayer(plr, false);
 		}
         
 		for(it2 = m_pendPlayers[i].begin(); it2 != m_pendPlayers[i].end();)
 		{
-			guid = *it2;
+			uint32 guid = *it2;
 			++it2;
-			plr = objmgr.GetPlayer(guid);
+			Player *plr = objmgr.GetPlayer(guid);
 
 			if(plr)
 				RemovePendingPlayer(plr);
@@ -1306,7 +1344,6 @@
 	m_mainLock.Release();
 }
 
-#define RESURRECT_SPELL 21074   // Spirit Healer Res
 void CBattleground::EventResurrectPlayers()
 {
 	m_mainLock.Acquire();
@@ -1334,6 +1371,7 @@
 				plr->SetUInt32Value(UNIT_FIELD_HEALTH, plr->GetUInt32Value(UNIT_FIELD_MAXHEALTH));
 				plr->SetUInt32Value(UNIT_FIELD_POWER1, plr->GetUInt32Value(UNIT_FIELD_MAXPOWER1));
 				plr->SetUInt32Value(UNIT_FIELD_POWER4, plr->GetUInt32Value(UNIT_FIELD_MAXPOWER4));
+				plr->CastSpell(plr, BG_REVIVE_PREPARATION, true);
 			}
 		}
 		i->second.clear();
@@ -1380,29 +1418,36 @@
 		{
 			/* make sure all players are 70 */
 			uint32 maxplayers;
+			uint32 arenateamtype;
 			switch(BattlegroundType)
 			{
 			case BATTLEGROUND_ARENA_2V2:
 				maxplayers=2;
+				arenateamtype=0;
 				break;
 
 			case BATTLEGROUND_ARENA_3V3:
 				maxplayers=3;
+				arenateamtype=1;
 				break;
 
 			case BATTLEGROUND_ARENA_5V5:
 				maxplayers=5;
+				arenateamtype=2;
 				break;
 
 			default:
 				maxplayers=2;
+				arenateamtype=0;
 				break;
 			}
 
+			uint32 team_id = 0;
+
 			pGroup->Lock();
 			for(itx = pGroup->GetSubGroup(0)->GetGroupMembersBegin(); itx != pGroup->GetSubGroup(0)->GetGroupMembersEnd(); ++itx)
 			{
-				if(maxplayers==0)
+				if( maxplayers == 0 )
 				{
 					m_session->SystemMessage("You have too many players in your party to join this type of arena.");
 					pGroup->Unlock();
@@ -1418,16 +1463,49 @@
 
 				if((*itx)->m_loggedInPlayer)
 				{
+					ArenaTeam * t = (*itx)->m_loggedInPlayer->m_arenaTeams[arenateamtype];
+					if( t != NULL )
+					{
+						if ( team_id == 0 )
+							team_id = t->m_id;
+
+						if ( team_id != t->m_id )
+						{
+							m_session->SystemMessage("Sorry, not all your party members are in same arena team.");
+							pGroup->Unlock();
+							return;
+						}
+					}
+					else
+					{
+						m_session->SystemMessage("Sorry, not all your party members are in same arena team.");
+						pGroup->Unlock();
+						return;
+					}
+
+					if( (*itx)->m_loggedInPlayer->m_bgIsQueued )
+						BattlegroundManager.RemovePlayerFromQueues((*itx)->m_loggedInPlayer);
+
+					/*
 					if((*itx)->m_loggedInPlayer->m_bg || (*itx)->m_loggedInPlayer->m_bg || (*itx)->m_loggedInPlayer->m_bgIsQueued)
 					{
 						m_session->SystemMessage("One or more of your party members are already queued or inside a battleground.");
 						pGroup->Unlock();
 						return;
 					}
+					*/
 
 					--maxplayers;
 				}
+	
 			}
+			if( maxplayers > 0 )
+			{
+				m_session->SystemMessage("Sorry, you have too few valid arena members in your group.");
+				pGroup->Unlock();
+				return;
+			}
+
 			WorldPacket data(SMSG_GROUP_JOINED_BATTLEGROUND, 4);
 			data << uint32(6);		// all arenas
 
Index: ascent-world/BattlegroundMgr.h
===================================================================
--- ascent-world/BattlegroundMgr.h	(revision 3944)
+++ ascent-world/BattlegroundMgr.h	(working copy)
@@ -68,6 +68,10 @@
 #define AB_ALLIANCE_CAPTUREBASE			 0x6F3
 #define AB_MAX_SCORE						0x6F4
 
+#define BG_PREPARATION			44521
+#define BG_REVIVE_PREPARATION	44535
+#define RESURRECT_SPELL			21074   // Spirit Healer Res
+
 // WSG define's
 #define WSG_ALLIANCE_FLAG_CAPTURED		  0x922
 #define WSG_HORDE_FLAG_CAPTURED			 0x923
@@ -118,7 +122,8 @@
 		return 7;
 }
 #define MAX_LEVEL_GROUP 8
-#define MINIMUM_PLAYERS_ON_EACH_SIDE_FOR_BG 1
+#define MINIMUM_PLAYERS_ON_EACH_SIDE_FOR_BG 5
+#define PLAYERS_DIFF_ON_EACH_SIDE_IN_BG 3
 #define MAXIMUM_BATTLEGROUNDS_PER_LEVEL_GROUP 3
 #define LEVEL_GROUP_70 7
 
@@ -188,7 +193,8 @@
 
 public:
 	/* Team->Player Map */
-	set<Player*> m_players[2];
+	//set<Player*> m_players[2];
+	set<uint32> m_players[2];
 	void Lock() { m_mainLock.Acquire(); }
 	void Unlock() { m_mainLock.Release(); }
 
@@ -210,6 +216,7 @@
 
 	/* starting time */
 	uint32 m_startTime;
+	bool m_started;
 
 	/* countdown stuff */
 	uint32 m_countdownStage;
@@ -280,7 +287,25 @@
 	ASCENT_INLINE bool IsFull() { return !(HasFreeSlots(0) || HasFreeSlots(1)); }
 
 	/* Are we full? */
-	bool HasFreeSlots(uint32 Team) { m_mainLock.Acquire(); bool res = ((m_players[Team].size() + m_pendPlayers[Team].size()) < m_playerCountPerTeam); m_mainLock.Release(); return res; }
+	bool HasFreeSlots(uint32 Team)
+	{
+		m_mainLock.Acquire();
+		bool res = false;
+		int count = (int)(m_players[Team].size() + m_pendPlayers[Team].size());
+		if ( m_type >= BATTLEGROUND_ARENA_2V2 && m_type <= BATTLEGROUND_ARENA_5V5 )
+		{
+			res = ( (uint32)count < m_playerCountPerTeam );
+		}
+		else
+		{
+			uint32 opTeam = Team ? 0 : 1;
+			int count1 = (int)(m_players[opTeam].size() + m_pendPlayers[opTeam].size());
+			res = ( ((uint32)count < m_playerCountPerTeam) &&
+					( (count <= count1) || ( (uint32)abs(count - count1) < PLAYERS_DIFF_ON_EACH_SIDE_IN_BG ) ) );
+		}
+		m_mainLock.Release();
+		return res; 
+	}
 
 	/* Add Player */
 	void AddPlayer(Player * plr, uint32 team);
@@ -339,6 +364,7 @@
 
 	void BuildPvPUpdateDataPacket(WorldPacket * data);
 	virtual uint8 Rated() { return 0; }
+	void OnPlayerPushed(Player* plr);
 };
 
 #define BattlegroundManager CBattlegroundManager::getSingleton( )
Index: ascent-world/CharacterHandler.cpp
===================================================================
--- ascent-world/CharacterHandler.cpp	(revision 3944)
+++ ascent-world/CharacterHandler.cpp	(working copy)
@@ -336,7 +336,7 @@
 
 	//Same Faction limitation only applies to PVP and RPPVP realms :)
 	uint32 realmType = sLogonCommHandler.GetRealmType();
-	if( !HasGMPermissions() && realmType == REALM_PVP && _side < 0 )
+	if(!HasGMPermissions() && (realmType==REALMTYPE_PVP||realmType==REALMTYPE_RPPVP) && sWorld.PvpFactionLimitation)
 	{
 		if( ((pNewChar->GetTeam()== 0) && (_side == 1)) || ((pNewChar->GetTeam()== 1) && (_side == 0)) )
 		{
Index: ascent-world/ChatHandler.cpp
===================================================================
--- ascent-world/ChatHandler.cpp	(revision 3944)
+++ ascent-world/ChatHandler.cpp	(working copy)
@@ -341,10 +341,14 @@
 			// Check that the player isn't a gm with his status on
 			if(!_player->GetSession()->GetPermissionCount() && player->bGMTagOn && player->gmTargets.count(_player) == 0)
 			{
+				// Send CHAT_MSG_WHISPER_INFORM packet
+				WorldPacket *data2;
+				data2 = sChatHandler.FillMessageData(CHAT_MSG_WHISPER_INFORM, LANG_UNIVERSAL,msg.c_str(), player->GetGUID(), 0);
+				SendPacket(data2);
+				delete data2; 
 				// Build automated reply
 				string Reply = "This Game Master does not currently have an open ticket from you and did not receive your whisper. Please submit a new GM Ticket request if you need to speak to a GM. This is an automatic message.";
-				data = sChatHandler.FillMessageData( CHAT_MSG_WHISPER, LANG_UNIVERSAL, Reply.c_str(), player->GetGUID(), 3);
-				SendPacket(data);
+				data = sChatHandler.FillMessageData( CHAT_MSG_WHISPER, LANG_UNIVERSAL, Reply.c_str(), player->GetGUID(), 4); 				SendPacket(data);
 				delete data;
 				break;
 			}
@@ -367,7 +371,7 @@
 			delete data;
 			//Sent the to Users id as the channel, this should be fine as it's not used for wisper
 		  
-			data = sChatHandler.FillMessageData(CHAT_MSG_WHISPER_INFORM, LANG_UNIVERSAL,msg.c_str(), player->GetGUID(), player->bGMTagOn ? 4 : 0  );
+			data = sChatHandler.FillMessageData(CHAT_MSG_WHISPER_INFORM, LANG_UNIVERSAL,msg.c_str(), player->GetGUID(), 0  ); 
 			SendPacket(data);
 			delete data;
 
@@ -380,7 +384,7 @@
 			}
 			else if(player->HasFlag(PLAYER_FLAGS, 0x04))
 			{
-				// Has AFK flag, autorespond.
+				// Has DND flag, autorespond. 
 				data = sChatHandler.FillMessageData(CHAT_MSG_DND, LANG_UNIVERSAL, player->m_afk_reason.c_str(),player->GetGUID(), _player->bGMTagOn ? 4 : 0);
 				SendPacket(data);
 				delete data;
Index: ascent-world/CombatHandler.cpp
===================================================================
--- ascent-world/CombatHandler.cpp	(revision 3944)
+++ ascent-world/CombatHandler.cpp	(working copy)
@@ -36,7 +36,7 @@
 	// AttackSwing
 	sLog.outDebug( "WORLD: Recvd CMSG_ATTACKSWING Message" );
 
-	if(GetPlayer()->IsPacified() || GetPlayer()->IsStunned())
+	if(GetPlayer()->IsPacified() || GetPlayer()->IsStunned() || GetPlayer()->IsFeared())
 		return;
 
 //	printf("Got ATTACK SWING: %08X %08X\n", GUID_HIPART(guid), GUID_LOPART(guid));
Index: ascent-world/Creature.cpp
===================================================================
--- ascent-world/Creature.cpp	(revision 3944)
+++ ascent-world/Creature.cpp	(working copy)
@@ -202,6 +202,7 @@
 	sLog.outDetail("Respawning "I64FMT"...", GetGUID());
 	SetUInt32Value(UNIT_FIELD_HEALTH, GetUInt32Value(UNIT_FIELD_MAXHEALTH));
 	SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0); // not tagging shiat
+	SetUInt32Value(UNIT_FIELD_DISPLAYID, GetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID));
 	if(proto && m_spawn)
 	{
 		SetUInt32Value(UNIT_NPC_FLAGS, proto->NPCFLags);
@@ -1048,6 +1049,7 @@
 	has_combat_text = objmgr.HasMonsterSay(GetEntry(), MONSTER_SAY_EVENT_ENTER_COMBAT);
 	has_waypoint_text = objmgr.HasMonsterSay(GetEntry(), MONSTER_SAY_EVENT_RANDOM_WAYPOINT);
 	m_aiInterface->m_isGuard = isGuard(GetEntry());
+	m_aiInterface->m_isNeutralGuard = isNeutralGuard(GetEntry());
 
 	m_aiInterface->getMoveFlags();
 
@@ -1324,6 +1326,15 @@
 	if(!IsInWorld())
 		return;
 
+	if(GetMapMgr() && GetMapMgr()->GetMapInfo() && GetMapMgr()->GetMapInfo()->type == INSTANCE_RAID)
+	{
+		if(GetTypeId() == TYPEID_UNIT)
+		{
+			if(GetCreatureName() && GetCreatureName()->Rank == ELITE_WORLDBOSS)
+				GetMapMgr()->RemoveCombatInProgress(GetGUID());
+		}
+	}
+
 	if(respawntime)
 	{
 		/* get the cell with our SPAWN location. if we've moved cell this might break :P */
@@ -1344,6 +1355,8 @@
 		Unit::RemoveFromWorld(true);
 		SafeDelete();
 	}
+
+	
 }
 
 void Creature::TriggerScriptEvent(string func)
Index: ascent-world/Creature.h
===================================================================
--- ascent-world/Creature.h	(revision 3944)
+++ ascent-world/Creature.h	(working copy)
@@ -143,6 +143,7 @@
 	float	run_speed;//most of the time mobs use this
 	float fly_speed;
 	uint32 extra_a9_flags;
+	uint32 modImmunities;
 
 	/* AI Stuff */
 	bool m_canRangedAttack;
Index: ascent-world/DayWatcherThread.cpp
===================================================================
--- ascent-world/DayWatcherThread.cpp	(revision 3944)
+++ ascent-world/DayWatcherThread.cpp	(working copy)
@@ -113,12 +113,7 @@
 	switch(timeoutval)
 	{
 	case WEEKLY:
-		{
-			if( (now_time->tm_mon != last_time->tm_mon) )
-				return true;
-            
-			return ( (now_time->tm_mday / 7) != (last_time->tm_mday / 7) );
-		}
+		return ( abs( now_time->tm_yday - last_time->tm_yday ) >= 7 );
 		
 	case MONTHLY:
 		return (now_time->tm_mon != last_time->tm_mon);
@@ -217,9 +212,9 @@
 				team = objmgr.GetArenaTeamByGuid(guid, i);
 				if(team)
 				{
-					/* TODO: In the future we might want to do a check that says is the player active in this arena team.
-					 * Private servers are kinda smaller so this probably isn't such a good idea.
-					 * - Burlex */
+					ArenaTeamMember *member = team->GetMemberByGuid(guid);
+					if(member == NULL || team->m_stat_gamesplayedweek < 10 ||(member->Played_ThisWeek*100)/team->m_stat_gamesplayedweek < 30)
+						continue;
 
 					/* we're in an arena team of this type! */
 					/* Source: http://www.wowwiki.com/Arena_point */
@@ -297,6 +292,8 @@
 		delete result;
 	}
 
+	objmgr.UpdateArenaTeamWeekly();
+
 	//===========================================================================
 	last_arena_time = UNIXTIME;
 	dupe_tm_pointer(localtime(&last_arena_time), &local_last_arena_time);
Index: ascent-world/EventMgr.h
===================================================================
--- ascent-world/EventMgr.h	(revision 3944)
+++ ascent-world/EventMgr.h	(working copy)
@@ -149,7 +149,8 @@
 	EVENT_DODGE_BLOCK_FLAG_EXPIRE,	//yeah, there are more then 1 flags
 	EVENT_REJUVENATION_FLAG_EXPIRE,
 	EVENT_PARRY_FLAG_EXPIRE,		
-	EVENT_CRIT_FLAG_EXPIRE,		
+	EVENT_CRIT_FLAG_EXPIRE,
+	EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE,
 	EVENT_GMSCRIPT_EVENT,
 	EVENT_RELOCATE,
 	EVENT_BATTLEGROUND_QUEUE_UPDATE,
@@ -169,6 +170,10 @@
 	EVENT_ITEM_UPDATE,
 	EVENT_PLAYER_JOIN_INSTANCE,
 	EVENT_PLAYER_FLUSH_MOVEMENT,
+	EVENT_EOTS_GIVE_POINTS,
+	EVENT_EOTS_CHECK_CAPTURE_POINT_STATUS,
+	EVENT_EOTS_RESET_FLAG,
+	EVENT_EOTS_RESPAWN_BUFF,
 };
 
 enum EventFlags
Index: ascent-world/EyeOfTheStorm.cpp
===================================================================
--- ascent-world/EyeOfTheStorm.cpp	(revision 3944)
+++ ascent-world/EyeOfTheStorm.cpp	(working copy)
@@ -20,24 +20,302 @@
 
 #include "StdAfx.h"
 
+static float EOTSBuffCoordinates[4][4] = {
+ { 2050.542236f, 1372.680176f, 1194.561279f, 1.67552f },
+ { 2047.728271f, 1749.736084f, 1190.198608f, -0.872665f },
+ { 2283.300049f, 1748.891235f, 1189.706787f, 1.76278f },
+ { 2301.271484f, 1388.116943f, 1197.304810f, -1.50098f },
+};
+
+static float EOTSBuffRotations[4][2] = {
+ { 0.681998f, -0.731354f },
+ { 0.771625f, 0.636078f },
+ { 0.422618f, -0.906308f },
+ { 0.743145f, 0.669131f },
+};
+
+uint32 EOTSbuffentrys[4] = {184964,184971,184978,184973};
+
+const float EOTSGraveyardLocations[EOTS_TOWER_COUNT][3] = {
+	{ 2012.403442f, 1455.412354f, 1172.201782f },			// BE Tower
+	{ 2013.061890f, 1677.238037f, 1182.125732f },			// Fel Reaver Ruins
+	{ 2355.297852f, 1683.713989f, 1173.153687f },			// Mage Tower
+	{ 2351.785400f, 1455.399048f, 1185.333374f },			// Draenei Ruins
+};
+
+const float EOTSCPLocations[EOTS_TOWER_COUNT][3] = {
+	{ 2048.290039f, 1393.757690f, 1194.363525f },			// BE Tower
+	{ 2043.571533f, 1729.117310f, 1189.911865f },			// Fel Reaver Ruins
+	{ 2284.430664f, 1731.128488f, 1189.874512f },			// Mage Tower
+	{ 2285.848877f, 1402.939575f, 1197.128540f },			// Draenei Ruins
+};
+
+const float EOTSFlagLocation[3] = { 2174.718750f, 1568.766113f, 1159.958740f };
+const float EOTSStartLocations[2][3] = {
+	{ 2523.686035f, 1596.597290f, 1269.347656f },
+	{ 1807.735962f, 1539.415649f, 1267.627319f },
+};
+
+const float EOTSBubbleLocations[2][4] = {
+	{ 2527.596924f, 1596.906494f, 1262.128052f, -3.124139f },
+	{ 1807.735962f, 1539.415649f, 1263.627319f, -3.124139f },
+};
+
+const float EOTSBubbleRotations[2][4] = {
+	{ -0.173642f, -0.001515f, 0.984770f, -0.008594f },
+	{ -0.173642f, -0.001515f, 0.984770f, -0.008594f },
+};
+
+//===================================================
+// 184083 - Draenei Tower Cap Pt, 184082 - Human Tower Cap Pt, 184081 - Fel Reaver Cap Pt, 184080 - BE Tower Cap Pt
+#define EOTS_GO_BE_TOWER 184080
+#define EOTS_GO_FELREAVER 184081
+#define EOTS_GO_MAGE_TOWER 184082
+#define EOTS_GO_DRAENEI_TOWER 184083
+
+#define EOTS_TOWER_BE 0
+#define EOTS_TOWER_FELREAVER 1
+#define EOTS_TOWER_MAGE 2
+#define EOTS_TOWER_DRAENEI 3
+
+#define EOTS_BANNER_NEUTRAL 184382
+#define EOTS_BANNER_ALLIANCE 184381
+#define EOTS_BANNER_HORDE 184380
+
+#define EOTS_CAPTURE_DISTANCE 900 /*30*/
+const uint32 EOTSTowerIds[EOTS_TOWER_COUNT] = { EOTS_GO_BE_TOWER, EOTS_GO_FELREAVER, EOTS_GO_MAGE_TOWER, EOTS_GO_DRAENEI_TOWER };
+
+/**
+ * WorldStates
+ */
+#define EOTS_WORLDSTATE_DISPLAYON				2718
+#define EOTS_WORLDSTATE_DISPLAYVALUE			2719
+#define EOTS_WORLDSTATE_ALLIANCE_VICTORYPOINTS	2749
+#define EOTS_WORLDSTATE_HORDE_VICTORYPOINTS		2750
+#define EOTS_WORLDSTATE_ALLIANCE_BASES			2752
+#define EOTS_WORLDSTATE_HORDE_BASES				2753
+#define EOTS_WORLDSTATE_FLAG_STATE				2757
+
+/* ruins marked full blue/red on world map but not on minimap
+ however, status remains "uncontrolled" on map */
+#define EOTS_WORLDSTATE_ALLIANCE_CONTROLL_FELREAVER		2726
+#define EOTS_WORLDSTATE_HORDE_CONTROLL_FELREAVER		2727
+#define EOTS_WORLDSTATE_HORDE_CONTROLL_MAGETOWER		2729
+#define EOTS_WORLDSTATE_ALLIANCE_CONTROLL_MAGETOWER		2730
+#define EOTS_WORLDSTATE_HORDE_CONTROLL_DRAENEI			2733
+#define EOTS_WORLDSTATE_ALLIANCE_CONTROLL_DRAENEI		2732
+#define EOTS_WORLDSTATE_HORDE_CONTROLL_ELFTOWER			2724
+#define EOTS_WORLDSTATE_ALLIANCE_CONTROLL_ELFTOWER		2723
+
+#define EOTS_WORLDSTATE_SHOW_MAGETOWER  2728
+#define EOTS_WORLDSTATE_SHOW_FELREAVER	2725
+#define EOTS_WORLDSTATE_SHOW_ELFTOWER	2722
+#define EOTS_WORLDSTATE_SHOW_DRAENEI	2731
+
+#define EOTS_NETHERWING_FLAG_SPELL 34976
+
+#define EOTS_CAPTURE_RATE 20 
+
+static uint32 TowerWorldStates[EOTS_TOWER_COUNT][2] = {
+		{ EOTS_WORLDSTATE_ALLIANCE_CONTROLL_ELFTOWER, EOTS_WORLDSTATE_HORDE_CONTROLL_ELFTOWER}, // EOTS_TOWER_BE
+		{ EOTS_WORLDSTATE_ALLIANCE_CONTROLL_FELREAVER, EOTS_WORLDSTATE_HORDE_CONTROLL_FELREAVER },	// EOTS_TOWER_FELREAVER
+		{ EOTS_WORLDSTATE_ALLIANCE_CONTROLL_MAGETOWER, EOTS_WORLDSTATE_HORDE_CONTROLL_MAGETOWER },	// EOTS_TOWER_MAGE
+		{ EOTS_WORLDSTATE_ALLIANCE_CONTROLL_DRAENEI, EOTS_WORLDSTATE_HORDE_CONTROLL_DRAENEI },	// EOTS_TOWER_DRAENEI
+	};
+
 EyeOfTheStorm::EyeOfTheStorm(MapMgr * mgr, uint32 id, uint32 lgroup, uint32 t) : CBattleground(mgr,id,lgroup,t)
 {
+	m_playerCountPerTeam = 15;
+	uint32 i;
 
+	for(i = 0; i < EOTS_TOWER_COUNT; ++i)
+	{
+		m_buffs[i] = NULL;
+		m_CPStatus[i] = 50;
+		m_CPBanner[i] = NULL;
+		m_CPStatusGO[i] = NULL;
+
+		m_spiritGuides[i] = NULL;
+	}
+
+	m_flagHolder = 0;
+	m_points[0] = m_points[1] = 0;
 }
 
 EyeOfTheStorm::~EyeOfTheStorm()
 {
+	for(uint32 i = 0; i < EOTS_TOWER_COUNT; ++i)
+	{
+		if( m_buffs[i] != NULL && m_buffs[i]->IsInWorld() == false )
+			delete m_buffs[i];
 
+		if( m_CPStatusGO[i] != NULL && m_CPStatusGO[i]->IsInWorld() == false )
+			delete m_CPStatusGO[i];
+
+		if( m_CPBanner[i] != NULL && m_CPBanner[i]->IsInWorld() == false )
+			delete m_CPBanner[i];
+	}
+
+	for(uint32 i = 0; i < 2; ++i)
+	{
+		if( m_bubbles[i] != NULL && m_bubbles[i]->IsInWorld() == false )
+			delete m_bubbles[i];
+	}
+
+	if( m_dropFlag != NULL && m_dropFlag->IsInWorld() == false )
+		delete m_dropFlag;
+
+	if( m_standFlag != NULL && m_standFlag->IsInWorld() == false )
+		delete m_standFlag;
+
 }
 
+void EyeOfTheStorm::RepopPlayersOfTeam(int32 team, Creature * sh)
+{
+	map<Creature*,set<uint32> >::iterator itr = m_resurrectMap.find(sh);
+	if( itr != m_resurrectMap.end() )
+	{
+		for( set<uint32>::iterator it2 = itr->second.begin(); it2 != itr->second.end(); ++it2 )
+		{
+			Player* r_plr = m_mapMgr->GetPlayer( *it2 );
+			if( r_plr != NULL && (team < 0 || (int32)r_plr->GetTeam() == team) && r_plr->isDead() )
+				HookHandleRepop( r_plr );
+		}
+	}
+}
+
 bool EyeOfTheStorm::HookHandleRepop(Player * plr)
 {
-	return false;
+	uint32 i;
+	int32 sval;
+	uint32 t = plr->GetTeam();
+	float dist = 999999.0f;
+	float distcur;
+	LocationVector dest;
+
+	if(plr->GetTeam() == 0)
+		sval = 100;
+	else
+		sval = 0;
+
+	dest.ChangeCoords( EOTSStartLocations[t][0], EOTSStartLocations[t][1], EOTSStartLocations[t][2], 0 );
+
+	for(i = 0; i < EOTS_TOWER_COUNT; ++i)
+	{
+		if( m_CPStatus[i] == sval )
+		{
+			distcur = plr->GetPositionNC().Distance2DSq( EOTSGraveyardLocations[i][0], EOTSGraveyardLocations[i][1] );
+			if( distcur < dist )
+			{
+				dist = distcur;
+				dest.ChangeCoords( EOTSGraveyardLocations[i][0], EOTSGraveyardLocations[i][1], EOTSGraveyardLocations[i][2], 0 );
+			}
+		}
+	}
+
+	plr->SafeTeleport(plr->GetMapId(), plr->GetInstanceID(), dest);
+	return true;
 }
 
 void EyeOfTheStorm::HookOnAreaTrigger(Player * plr, uint32 id)
 {
+	int32 tid = -1;
+	bool buff = false;
 
+	switch(id)
+	{
+	case 4568:
+		buff = true;
+	case 4476:			// BE Tower
+		tid = EOTS_TOWER_BE;
+		break;
+
+	case 4569:
+		buff = true;
+	case 4514:			// Fel Reaver Tower
+		tid = EOTS_TOWER_FELREAVER;
+		break;
+
+	case 4571:
+		buff = true;
+	case 4518:			// Draenei Tower
+		tid = EOTS_TOWER_DRAENEI;
+		break;
+
+	case 4570:
+		buff = true;
+	case 4516:			// Mage Tower
+		tid = EOTS_TOWER_MAGE;
+		break;
+	}
+
+	if( tid < 0 )
+		return;
+
+	if( buff )
+	{
+		uint32 spellid=0;
+		uint32 x = (uint32)tid;
+
+		if( m_buffs[x] && m_buffs[x]->IsInWorld() )
+		{
+			m_buffs[x]->RemoveFromWorld(false);
+			sEventMgr.AddEvent(this,&EyeOfTheStorm::SpawnBuff,x,EVENT_EOTS_RESPAWN_BUFF,EOTS_BUFF_RESPAWN_TIME,1,EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
+
+			SpellEntry * sp = dbcSpell.LookupEntryForced( m_buffs[x]->GetInfo()->sound3 );
+			if(sp)
+			{
+				Spell * pSpell = new Spell(plr, sp, true, NULL);
+				SpellCastTargets targets(plr->GetGUID());
+				pSpell->prepare(&targets);
+			}
+		}
+	}
+	else
+	{
+		uint32 team = plr->GetTeam();
+		if( plr->GetGUIDLow() != m_flagHolder )
+			return;
+
+		int32 val;
+		uint32 i;
+		uint32 towers = 0;
+		if( team == 0 )
+			val = 100;
+		else
+			val = 0;
+
+		if( m_CPStatus[tid] != val )
+			return;			// not captured by our team
+
+		for(i = 0; i < EOTS_TOWER_COUNT; ++i)
+		{
+			if(m_CPStatus[i] == val)
+				towers++;
+		}
+
+	/*
+	Points from flag captures
+
+	* 1 towers controlled = 75 points
+	* 2 towers controlled = 85 points
+	* 3 towers controlled = 100 points
+	* 4 towers controlled = 500 points 
+	*/
+
+	// 25 is guessed
+		const static uint32 points[5] = { 25, 75, 85, 100, 500 };
+		const char * msgs[2] = { "The Alliance have captured the flag.", "The Horde have captured the flag." };
+
+		SendChatMessage( 0x54, 0, msgs[team] );
+		GivePoints( team, points[towers] );
+
+		m_standFlag->PushToWorld( m_mapMgr );
+		m_flagHolder = 0;
+		SetWorldState( EOTS_WORLDSTATE_FLAG_STATE, 1 );
+
+		plr->RemoveAura( EOTS_NETHERWING_FLAG_SPELL );
+	}
 }
 
 void EyeOfTheStorm::HookOnPlayerDeath(Player * plr)
@@ -48,7 +326,18 @@
 
 void EyeOfTheStorm::HookFlagDrop(Player * plr, GameObject * obj)
 {
+	if( !m_dropFlag->IsInWorld() )
+		return;
 
+	m_dropFlag->RemoveFromWorld(false);
+	plr->CastSpell( plr->GetGUID(), EOTS_NETHERWING_FLAG_SPELL, true );
+
+	SetWorldState( EOTS_WORLDSTATE_FLAG_STATE, 0 );
+	PlaySoundToAll( 8212 );
+	SendChatMessage( 0x53, plr->GetGUID(), "$n has taken the flag!" );
+	m_flagHolder = plr->GetGUIDLow();
+
+	event_RemoveEvents( EVENT_EOTS_RESET_FLAG );
 }
 
 void EyeOfTheStorm::HookFlagStand(Player * plr, GameObject * obj)
@@ -56,26 +345,434 @@
 
 }
 
-void EyeOfTheStorm::HookOnMount(Player * plr)
+bool EyeOfTheStorm::HookSlowLockOpen(GameObject * pGo, Player * pPlayer, Spell * pSpell)
 {
+	if( m_flagHolder != 0 )
+		return false;
 
+	m_standFlag->RemoveFromWorld(false);
+	pPlayer->CastSpell( pPlayer->GetGUID(), EOTS_NETHERWING_FLAG_SPELL, true );
+
+	SetWorldState( EOTS_WORLDSTATE_FLAG_STATE, 0 );
+	PlaySoundToAll( 8212 );
+	SendChatMessage( 0x53, pPlayer->GetGUID(), "$n has taken the flag!" );
+	m_flagHolder = pPlayer->GetGUIDLow();
+	return true;
 }
 
+void EyeOfTheStorm::HookOnMount(Player * plr)
+{
+	if( m_flagHolder == plr->GetGUIDLow() )
+	{
+		plr->RemoveAura( EOTS_NETHERWING_FLAG_SPELL );
+		//DropFlag( plr );
+	}
+}
+
 void EyeOfTheStorm::OnAddPlayer(Player * plr)
 {
-
+	if ( plr != NULL && !m_started )
+	{
+		plr->Root();
+		plr->CastSpell(plr, BG_PREPARATION, true);
+	}
 }
 
 void EyeOfTheStorm::OnRemovePlayer(Player * plr)
 {
+	uint32 i;
 
+	for( i = 0; i < EOTS_TOWER_COUNT; ++i )
+	{
+		m_CPDisplay[i].erase( plr );
+	}
+
+	if( m_flagHolder == plr->GetGUIDLow() )
+	{
+		plr->RemoveAura( EOTS_NETHERWING_FLAG_SPELL );
+		//DropFlag( plr );
+	}
+
+	plr->RemoveAura(BG_PREPARATION);
 }
 
+void EyeOfTheStorm::DropFlag(Player * plr)
+{
+	if( m_flagHolder != plr->GetGUIDLow() )
+		return;
+
+	m_dropFlag->SetPosition( plr->GetPosition() );
+	m_dropFlag->PushToWorld( m_mapMgr );
+	m_flagHolder = 0;
+
+	sEventMgr.AddEvent( this, &EyeOfTheStorm::EventResetFlag, EVENT_EOTS_RESET_FLAG, 60000, 1, EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT );
+}
+
+void EyeOfTheStorm::EventResetFlag()
+{
+	if(!m_dropFlag->IsInWorld())
+		return;
+
+	m_dropFlag->RemoveFromWorld(false);
+	m_standFlag->PushToWorld(m_mapMgr);
+
+	SetWorldState( EOTS_WORLDSTATE_FLAG_STATE, 1 );
+	PlaySoundToAll( 8192 );
+	SendChatMessage( 0x52, 0, "The flag has been reset." );
+	m_flagHolder = 0;
+}
+
 void EyeOfTheStorm::OnCreate()
 {
+	GameObjectInfo* goi;
+	uint32 i;
 
+	/* eww worldstates */
+	SetWorldState(3218, 0);
+	SetWorldState(3217, 0);
+	SetWorldState(3191, 2);
+	SetWorldState(3085, 379);
+	SetWorldState(2770, 1);
+	SetWorldState(2769, 1);
+	SetWorldState(EOTS_WORLDSTATE_FLAG_STATE, 1);
+	SetWorldState(EOTS_WORLDSTATE_HORDE_BASES, 0);
+	SetWorldState(EOTS_WORLDSTATE_ALLIANCE_BASES, 0);
+	SetWorldState(EOTS_WORLDSTATE_HORDE_VICTORYPOINTS, 0);
+	SetWorldState(EOTS_WORLDSTATE_ALLIANCE_VICTORYPOINTS, 0);
+	// those 8 ( 2742 - 2735 ) are markes for changing tower control on map - TODO : find which one's which. 
+	SetWorldState(2742, 0);
+	SetWorldState(2741, 0);
+	SetWorldState(2740, 0);
+	SetWorldState(2739, 0);
+	SetWorldState(2738, 0);
+	SetWorldState(2737, 0);
+	SetWorldState(2736, 0);
+	SetWorldState(2735, 0);
+	SetWorldState(EOTS_WORLDSTATE_HORDE_CONTROLL_DRAENEI, 0);
+	SetWorldState(EOTS_WORLDSTATE_ALLIANCE_CONTROLL_DRAENEI, 0);
+	SetWorldState(EOTS_WORLDSTATE_SHOW_DRAENEI, 1);
+	SetWorldState(EOTS_WORLDSTATE_ALLIANCE_CONTROLL_MAGETOWER, 0);
+	SetWorldState(EOTS_WORLDSTATE_HORDE_CONTROLL_MAGETOWER, 0);
+	SetWorldState(EOTS_WORLDSTATE_SHOW_MAGETOWER, 1);
+	SetWorldState(EOTS_WORLDSTATE_HORDE_CONTROLL_FELREAVER, 0);
+	SetWorldState(EOTS_WORLDSTATE_ALLIANCE_CONTROLL_FELREAVER, 0);
+	SetWorldState(EOTS_WORLDSTATE_SHOW_FELREAVER, 1);
+	SetWorldState(EOTS_WORLDSTATE_HORDE_CONTROLL_ELFTOWER, 0);
+	SetWorldState(EOTS_WORLDSTATE_ALLIANCE_CONTROLL_ELFTOWER, 0);
+	SetWorldState(EOTS_WORLDSTATE_SHOW_ELFTOWER, 1);
+	SetWorldState(2720, 0);
+	SetWorldState(EOTS_WORLDSTATE_DISPLAYVALUE, 0);
+	SetWorldState(EOTS_WORLDSTATE_DISPLAYON, 0);
+	SetWorldState(2565, 142);
+	SetWorldState(2264, 0);
+	SetWorldState(2263, 0);
+	SetWorldState(2262, 0);
+	SetWorldState(2261, 0);
+	SetWorldState(2260, 0);
+	SetWorldState(2259, 0);
+
+	/* create gameobjects */
+	for(i = 0; i < EOTS_TOWER_COUNT; ++i)
+	{
+		goi = GameObjectNameStorage.LookupEntry( EOTSTowerIds[i] );
+		if( goi == NULL )
+		{
+			Log.LargeErrorMessage(LARGERRORMESSAGE_ERROR, "EOTS is being created and you are missing gameobjects. Terminating.");
+			abort();
+			return;
+		}
+
+		m_CPStatusGO[i] = m_mapMgr->CreateGameObject();
+		m_CPStatusGO[i]->CreateFromProto( goi->ID, m_mapMgr->GetMapId(), EOTSCPLocations[i][0], EOTSCPLocations[i][1], EOTSCPLocations[i][2], 0);
+		m_CPStatusGO[i]->PushToWorld( m_mapMgr );
+
+		goi = GameObjectNameStorage.LookupEntry( EOTS_BANNER_NEUTRAL );
+		if( goi == NULL )
+		{
+			Log.LargeErrorMessage(LARGERRORMESSAGE_ERROR, "EOTS is being created and you are missing gameobjects. Terminating.");
+			abort();
+			return;
+		}
+
+		m_CPBanner[i] = m_mapMgr->CreateGameObject();
+		m_CPBanner[i]->CreateFromProto( goi->ID, m_mapMgr->GetMapId(), EOTSCPLocations[i][0], EOTSCPLocations[i][1], EOTSCPLocations[i][2], 0);
+		m_CPBanner[i]->PushToWorld( m_mapMgr );
+
+		SpawnBuff(i);
+	}
+
+	/* BUBBLES! */
+	for( i = 0; i < 2; ++i )
+	{
+		m_bubbles[i] = SpawnGameObject( 184719, m_mapMgr->GetMapId(), EOTSBubbleLocations[i][0], EOTSBubbleLocations[i][1], EOTSBubbleLocations[i][2], EOTSBubbleLocations[i][3], 33, 114, 0.1f );
+		m_bubbles[i]->PushToWorld( m_mapMgr );
+	}
+
+	/* Flag */
+	m_standFlag = m_mapMgr->CreateGameObject();
+	m_standFlag->CreateFromProto( 184141, m_mapMgr->GetMapId(), 2174.782227f, 1569.054688f, 1160.361938f, -1.448624f );
+	m_standFlag->SetFloatValue( GAMEOBJECT_ROTATION_02, 0.662620f );
+	m_standFlag->SetFloatValue( GAMEOBJECT_ROTATION_03, -0.748956f );
+	m_standFlag->SetFloatValue( OBJECT_FIELD_SCALE_X, 2.5f );
+	m_standFlag->PushToWorld( m_mapMgr );
+
+	m_dropFlag = m_mapMgr->CreateGameObject();
+	m_dropFlag->CreateFromProto( 184142, m_mapMgr->GetMapId(), 2174.782227f, 1569.054688f, 1160.361938f, -1.448624f );
+	m_dropFlag->SetFloatValue( GAMEOBJECT_ROTATION_02, 0.885448f );
+	m_dropFlag->SetFloatValue( GAMEOBJECT_ROTATION_03, -0.464739f );
+	m_dropFlag->SetFloatValue( OBJECT_FIELD_SCALE_X, 2.5f );
 }
 
+void EyeOfTheStorm::RespawnCPFlag(uint32 i, uint32 id)
+{
+	m_CPBanner[i]->RemoveFromWorld(false);
+	m_CPBanner[i]->SetNewGuid( m_mapMgr->GenerateGameobjectGuid() );
+	m_CPBanner[i]->CreateFromProto( id, m_mapMgr->GetMapId(), m_CPBanner[i]->GetPositionX(), m_CPBanner[i]->GetPositionY(), m_CPBanner[i]->GetPositionZ(), m_CPBanner[i]->GetOrientation() );
+	m_CPBanner[i]->PushToWorld( m_mapMgr );
+}
+
+void EyeOfTheStorm::UpdateCPs()
+{
+	uint32 i;
+	set<Player*>::iterator itr, itrend;
+	Player * plr;
+	GameObject * go;
+	int32 delta;
+	uint32 playercounts[2];
+	uint32 towers[2] = {0,0};
+	EOTSCaptureDisplayList::iterator eitr, eitr2, eitrend;
+	EOTSCaptureDisplayList * disp;
+
+	for(i = 0; i < EOTS_TOWER_COUNT; ++i)
+	{
+		/* loop players inrange, add any that arent in the set to the set */
+		playercounts[0] = playercounts[1] = 0;
+		go = m_CPStatusGO[i];
+		disp = &m_CPDisplay[i];
+		itr = go->GetInRangePlayerSetBegin();
+		itrend = go->GetInRangePlayerSetEnd();
+
+		for( ; itr != itrend; ++itr )
+		{
+			plr = *itr;
+			if( (plr->GetDistance2dSq( go ) <= EOTS_CAPTURE_DISTANCE) && plr->isAlive() && !plr->IsStealth() )
+			{
+				playercounts[plr->GetTeam()]++;
+
+				if( disp->find( plr ) == disp->end() )
+				{
+					disp->insert( plr );
+					plr->SendWorldStateUpdate(EOTS_WORLDSTATE_DISPLAYON, 1);
+				}
+			}
+		}
+
+		/* score diff calculation */
+		if(playercounts[0] != playercounts[1])
+		{
+			if(playercounts[0] > playercounts[1])
+				delta = playercounts[0];
+			else if(playercounts[1] > playercounts[0])
+				delta = -(int32)playercounts[1];
+
+			delta *= EOTS_CAPTURE_RATE;
+			m_CPStatus[i] += delta;
+			if( m_CPStatus[i] > 100 )
+				m_CPStatus[i] = 100;
+			else if( m_CPStatus[i] < 0 )
+				m_CPStatus[i] = 0;
+
+			// change the flag depending on cp status
+			if( m_CPStatus[i] == 0 )
+			{
+				if( m_CPBanner[i]->GetEntry() != EOTS_BANNER_HORDE )
+				{
+					SetWorldState( TowerWorldStates[i][0], 0);
+					SetWorldState( TowerWorldStates[i][1], 1);
+
+					RespawnCPFlag(i, EOTS_BANNER_HORDE);
+					if( m_spiritGuides[i] != NULL )
+					{
+						RepopPlayersOfTeam( 0, m_spiritGuides[i] );
+						m_spiritGuides[i]->Despawn( 0, 0 );
+						RemoveSpiritGuide( m_spiritGuides[i] );
+						m_spiritGuides[i] = NULL;
+					}
+
+					m_spiritGuides[i] = SpawnSpiritGuide( EOTSGraveyardLocations[i][0], EOTSGraveyardLocations[i][1], EOTSGraveyardLocations[i][2], 0, 1 );
+					AddSpiritGuide( m_spiritGuides[i] );
+				}
+			}
+			else if( m_CPStatus[i] == 100 )
+			{
+				if( m_CPBanner[i]->GetEntry() != EOTS_BANNER_ALLIANCE )
+				{
+					SetWorldState( TowerWorldStates[i][1], 0);
+					SetWorldState( TowerWorldStates[i][0], 1);
+
+					RespawnCPFlag(i, EOTS_BANNER_ALLIANCE);
+					if( m_spiritGuides[i] != NULL )
+					{
+						RepopPlayersOfTeam( 1, m_spiritGuides[i] );
+						m_spiritGuides[i]->Despawn( 0, 0 );
+						RemoveSpiritGuide( m_spiritGuides[i] );
+						m_spiritGuides[i] = NULL;
+					}
+
+					m_spiritGuides[i] = SpawnSpiritGuide( EOTSGraveyardLocations[i][0], EOTSGraveyardLocations[i][1], EOTSGraveyardLocations[i][2], 0, 0 );
+					AddSpiritGuide( m_spiritGuides[i] );
+				}
+			}
+			else
+			{
+				if( m_CPBanner[i]->GetEntry() != EOTS_BANNER_NEUTRAL )
+				{
+
+					for( uint32 j = 0; j < 2; ++j )
+						SetWorldState( TowerWorldStates[i][j], 0);
+
+					RespawnCPFlag(i, EOTS_BANNER_NEUTRAL);
+					if( m_spiritGuides[i] != NULL )
+					{
+						RepopPlayersOfTeam( -1, m_spiritGuides[i] );
+						m_spiritGuides[i]->Despawn( 0, 0 );
+						RemoveSpiritGuide( m_spiritGuides[i] );
+						m_spiritGuides[i] = NULL;
+					}
+				}
+			}
+		}
+
+		/* update the players with the new value */
+		eitr = disp->begin();
+		eitrend = disp->end();
+
+		for( ; eitr != eitrend; )
+		{
+			plr = *eitr;
+			eitr2 = eitr;
+			++eitr;
+
+			if( plr->GetDistance2dSq( go ) > EOTS_CAPTURE_DISTANCE )
+			{
+				disp->erase( eitr2 );
+				plr->SendWorldStateUpdate(EOTS_WORLDSTATE_DISPLAYON, 0);			// hide the cp bar
+			}
+			else
+				plr->SendWorldStateUpdate(EOTS_WORLDSTATE_DISPLAYVALUE, m_CPStatus[i]);
+		}
+	}
+
+	for(i = 0; i < EOTS_TOWER_COUNT; ++i)
+	{
+		if( m_CPStatus[i] == 100 )
+			towers[0]++;
+		else if( m_CPStatus[i] == 0 )
+			towers[1]++;
+	}
+
+	SetWorldState( EOTS_WORLDSTATE_ALLIANCE_BASES, towers[0] );
+	SetWorldState( EOTS_WORLDSTATE_HORDE_BASES, towers[1] );
+}
+
+void EyeOfTheStorm::GeneratePoints()
+{
+	uint32 i;
+	uint32 towers[2] = {0,0};
+
+	/*
+	#  Unlike Arathi Basin, points are always generated in 2 seconds intervals no matter how many towers are controlled by both teams.
+	# Each claimed tower generates victory points for the controlling team. The more towers your team owns, the faster your team gains points
+
+	* 1 tower controlled = 1 point/tick (0.5 points per second)
+	* 2 towers controlled = 2 points/tick (1 point per second)
+	* 3 towers controlled = 5 points/tick (2.5 points per second)
+	* 4 towers controlled = 10 points/tick (5 points per second) 
+
+	*/
+	uint32 pointspertick[5] = { 0, 1, 2, 5, 10 };
+
+	for(i = 0; i < EOTS_TOWER_COUNT; ++i)
+	{
+		if(m_CPStatus[i] == 100)
+			towers[0]++;
+		else if(m_CPStatus[i] == 0)
+			towers[1]++;
+	}
+
+	for( i = 0; i < 2; ++i )
+	{
+		if( towers[i] == 0 )
+			continue;
+
+		if( GivePoints( i, pointspertick[towers[i]] ) )
+			return;
+	}
+}
+
+bool EyeOfTheStorm::GivePoints(uint32 team, uint32 points)
+{
+	m_points[team] += points;
+	if( m_points[team] >= 2000 )
+	{
+		m_points[team] = 2000;
+		SetWorldState( EOTS_WORLDSTATE_ALLIANCE_VICTORYPOINTS + team, m_points[team] );
+
+		m_ended = true;
+		m_winningteam = ( team ) ? 0 : 1;
+		m_nextPvPUpdateTime = 0;
+
+		sEventMgr.RemoveEvents(this);
+		sEventMgr.AddEvent(((CBattleground*)this), &CBattleground::Close, EVENT_BATTLEGROUND_CLOSE, 120000, 1,0);
+
+		/* add the marks of honor to all players */
+		m_mainLock.Acquire();
+		for(uint32 i = 0; i < 2; ++i)
+		{
+			for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+			{
+				Player *plr = objmgr.GetPlayer(*itr);
+				if( plr != NULL )
+				{
+					plr->Root();
+				
+					uint32 reward_count;
+
+					if( i != m_winningteam )
+						reward_count = 3;
+					else
+						reward_count = 1;
+
+					ItemPrototype* it = ItemPrototypeStorage.LookupEntry(29024);
+					if( it != NULL )
+					{
+						Item *item = objmgr.CreateItem( 29024, plr );
+						item->SetUInt32Value(ITEM_FIELD_STACK_COUNT, reward_count );
+						item->SoulBind();
+
+						if( plr->GetItemInterface()->AddItemToFreeSlot(item) )
+						{
+							SlotResult *lr = plr->GetItemInterface()->LastSearchResult();
+							plr->GetSession()->SendItemPushResult(item, false, true, false, true, lr->ContainerSlot, lr->Slot, reward_count);
+						}
+						else
+						{
+							delete item;
+						}
+
+					}
+				}
+			}
+		}
+		m_mainLock.Release();
+
+		return true;
+	}
+
+	SetWorldState( EOTS_WORLDSTATE_ALLIANCE_VICTORYPOINTS + team, m_points[team] );
+	return false;
+}
+
 void EyeOfTheStorm::HookOnPlayerKill(Player * plr, Unit * pVictim)
 {
 	plr->m_bgScore.KillingBlows++;
@@ -90,15 +787,73 @@
 
 void EyeOfTheStorm::SpawnBuff(uint32 x)
 {
+	uint32 chosen_buffid = EOTSbuffentrys[RandomUInt(3)];
+	GameObjectInfo * goi = GameObjectNameStorage.LookupEntry( chosen_buffid );
+	if( goi == NULL )
+		return;
 
+	if( m_buffs[x] == NULL )
+	{
+		m_buffs[x] = SpawnGameObject(chosen_buffid, m_mapMgr->GetMapId(), EOTSBuffCoordinates[x][0], EOTSBuffCoordinates[x][1], EOTSBuffCoordinates[x][2], EOTSBuffCoordinates[x][3], 0, 114, 1);
+		m_buffs[x]->SetFloatValue(GAMEOBJECT_ROTATION_02, EOTSBuffRotations[x][0]);
+		m_buffs[x]->SetFloatValue(GAMEOBJECT_ROTATION_03, EOTSBuffRotations[x][1]);
+		m_buffs[x]->SetUInt32Value(GAMEOBJECT_STATE, 1);
+		m_buffs[x]->SetUInt32Value(GAMEOBJECT_TYPE_ID, 6);
+		m_buffs[x]->SetUInt32Value(GAMEOBJECT_ANIMPROGRESS, 100);
+		m_buffs[x]->PushToWorld(m_mapMgr);
+	 }
+	else
+	{
+		if( m_buffs[x]->IsInWorld() )
+			m_buffs[x]->RemoveFromWorld(false);
+	
+		if(chosen_buffid != m_buffs[x]->GetEntry())
+		{
+			m_buffs[x]->SetNewGuid(m_mapMgr->GenerateGameobjectGuid());
+			m_buffs[x]->SetUInt32Value(OBJECT_FIELD_ENTRY, chosen_buffid);
+			m_buffs[x]->SetInfo(goi);
+		}
+	
+		m_buffs[x]->PushToWorld(m_mapMgr);
+	}
+
 }
 
 LocationVector EyeOfTheStorm::GetStartingCoords(uint32 Team)
 {
-	return LocationVector(0,0,0,0);
+	return LocationVector( EOTSStartLocations[Team][0], 
+		EOTSStartLocations[Team][1],
+		EOTSStartLocations[Team][2] );
 }
 
 void EyeOfTheStorm::OnStart()
 {
+	uint32 i;
 
+	m_started = true;
+
+	for(uint32 i = 0; i < 2; ++i) {
+		for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+		{
+			Player *plr = objmgr.GetPlayer(*itr);
+			if( plr != NULL )
+				plr->RemoveAura(BG_PREPARATION);
+		}
+	}
+
+	/* start the events */
+	sEventMgr.AddEvent(this, &EyeOfTheStorm::GeneratePoints, EVENT_EOTS_GIVE_POINTS, 2000, 0, EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
+	sEventMgr.AddEvent(this, &EyeOfTheStorm::UpdateCPs, EVENT_EOTS_CHECK_CAPTURE_POINT_STATUS, 5000, 0, EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
+
+	/* spirit guides */
+	AddSpiritGuide(SpawnSpiritGuide( EOTSStartLocations[0][0], EOTSStartLocations[0][1], EOTSStartLocations[0][2], 0, 0 ));
+	AddSpiritGuide(SpawnSpiritGuide( EOTSStartLocations[1][0], EOTSStartLocations[1][1], EOTSStartLocations[1][2], 0, 1 ));
+
+	/* remove the bubbles */
+	for( i = 0; i < 2; ++i )
+	{
+		m_bubbles[i]->RemoveFromWorld(false);
+		delete m_bubbles[i];
+		m_bubbles[i] = NULL;
+	}
 }
Index: ascent-world/EyeOfTheStorm.h
===================================================================
--- ascent-world/EyeOfTheStorm.h	(revision 3944)
+++ ascent-world/EyeOfTheStorm.h	(working copy)
@@ -21,8 +21,12 @@
 #ifndef _EOTS_H
 #define _EOTS_H
 
+#define EOTS_TOWER_COUNT 4
+#define EOTS_BUFF_RESPAWN_TIME 90000
+
 class EyeOfTheStorm : public CBattleground
 {
+public:
 	EyeOfTheStorm(MapMgr * mgr, uint32 id, uint32 lgroup, uint32 t);
 	~EyeOfTheStorm();
 
@@ -39,11 +43,41 @@
 	void HookOnHK(Player * plr);
 	void SpawnBuff(uint32 x);
 	LocationVector GetStartingCoords(uint32 Team);
-	static CBattleground * Create(MapMgr * m, uint32 i, uint32 l, uint32 t) { return new ArathiBasin(m, i, l, t); }
+	static CBattleground * Create(MapMgr * m, uint32 i, uint32 l, uint32 t) { return new EyeOfTheStorm(m, i, l, t); }
 
 	const char * GetName() { return "Eye of the Storm"; }
 	void OnStart();
 
+	void UpdateCPs();
+	void GeneratePoints();
+
+	// returns true if that team won
+	bool GivePoints(uint32 team, uint32 points);
+
+	void RespawnCPFlag(uint32 i, uint32 id);		// 0 = Neutral, <0 = Leaning towards alliance, >0 Leaning towards horde
+
+	bool HookSlowLockOpen(GameObject * pGo, Player * pPlayer, Spell * pSpell);
+	void DropFlag(Player * plr);
+	void EventResetFlag();
+	void RepopPlayersOfTeam(int32 team, Creature * sh);
+
+protected:
+	int32 m_CPStatus[EOTS_TOWER_COUNT];		
+	uint32 m_flagHolder;
+
+	GameObject * m_standFlag;
+	GameObject * m_dropFlag;
+
+	GameObject * m_CPStatusGO[EOTS_TOWER_COUNT];
+	GameObject * m_CPBanner[EOTS_TOWER_COUNT];
+	GameObject * m_bubbles[2];
+	GameObject * m_buffs[EOTS_TOWER_COUNT];
+
+	typedef set<Player*> EOTSCaptureDisplayList;
+	EOTSCaptureDisplayList m_CPDisplay[EOTS_TOWER_COUNT];
+
+	uint32 m_points[2];
+	Creature * m_spiritGuides[EOTS_TOWER_COUNT];
 };
 
 #endif		// _EOTS_H
Index: ascent-world/faction.cpp
===================================================================
--- ascent-world/faction.cpp	(revision 3944)
+++ ascent-world/faction.cpp	(working copy)
@@ -148,7 +148,11 @@
 
 		if(objA->HasFlag(PLAYER_FLAGS,PLAYER_FLAG_FREE_FOR_ALL_PVP) && objB->HasFlag(PLAYER_FLAGS,PLAYER_FLAG_FREE_FOR_ALL_PVP))
 		{
-			if( static_cast< Player* >( objA )->m_bg != NULL )
+			if(static_cast< Player* >( objA )->m_bg != NULL && static_cast< Player* >( objB )->m_bg != NULL)
+				if(static_cast< Player* >( objA )->m_bgTeam == static_cast< Player* >( objB )->m_bgTeam)
+					return false;
+
+			if(static_cast< Player* >( objA )->GetGroup() != NULL)
 				if( static_cast< Player* >( objA )->GetGroup() == static_cast< Player* >( objB )->GetGroup() )
 					return false;
 
@@ -160,19 +164,38 @@
 	if(objA->IsPet())
 	{
 		if(objB->IsPlayer())
+		{
 			if(
 				static_cast<Pet *>(objA)->GetPetOwner() &&
 				static_cast<Pet *>(objA)->GetPetOwner()->DuelingWith == static_cast< Player* >(objB) && 
 				static_cast<Pet *>(objA)->GetPetOwner()->GetDuelState() == DUEL_STATE_STARTED
 				)
 				return true;
+
+			if(
+				static_cast<Pet *>(objA)->GetPetOwner() &&
+				static_cast<Pet *>(objA)->GetPetOwner()->m_bg &&
+				static_cast<Pet *>(objA)->GetPetOwner()->m_bgTeam != static_cast< Player* >(objB)->m_bgTeam
+				)
+				return true;
+		}
 		if(objB->IsPet())
+		{
 			if(static_cast<Pet *>(objA)->GetPetOwner() &&
 				static_cast<Pet *>(objB)->GetPetOwner() &&
 				static_cast<Pet *>(objA)->GetPetOwner()->DuelingWith == static_cast<Pet *>(objB)->GetPetOwner() && 
 				static_cast<Pet *>(objA)->GetPetOwner()->GetDuelState() == DUEL_STATE_STARTED
 				)
 				return true;
+
+			if(
+				static_cast<Pet *>(objA)->GetPetOwner() && static_cast<Pet *>(objB)->GetPetOwner() &&
+				static_cast<Pet *>(objA)->GetPetOwner()->m_bg &&
+				static_cast<Pet *>(objA)->GetPetOwner()->m_bgTeam != static_cast<Pet *>(objB)->GetPetOwner()->m_bgTeam
+				)
+				return true;
+
+		}
 	}
 	if(objB->IsPet())
 	{
@@ -198,11 +221,22 @@
 		if(static_cast<Creature *>(objA)->IsTotem())
 		{
 			if(objB->IsPlayer())
+			{
+
 				if( static_cast<Creature *>(objA)->GetTotemOwner() &&
+					static_cast<Creature *>(objA)->GetTotemOwner()->m_bg &&
+					static_cast<Creature *>(objA)->GetTotemOwner()->m_bgTeam != static_cast< Player* >(objB)->m_bgTeam
+					)
+					return true;
+
+				if( static_cast<Creature *>(objA)->GetTotemOwner() &&
 					static_cast<Creature *>(objA)->GetTotemOwner()->DuelingWith == static_cast< Player* >(objB) && 
 					static_cast<Creature *>(objA)->GetTotemOwner()->GetDuelState() == DUEL_STATE_STARTED
 					)
 					return true;
+
+
+			}
 			if(objB->IsPet())
 				if( static_cast<Creature *>(objA)->GetTotemOwner() &&
 					static_cast<Creature *>(objA)->GetTotemOwner()->DuelingWith == static_cast<Pet *>(objB)->GetPetOwner() && 
@@ -236,6 +270,8 @@
 	AreaTable *atB;
 	if( objA->IsPet() && static_cast< Pet* >( objA )->GetPetOwner() )
 		atA = dbcArea.LookupEntry( static_cast< Pet* >( objA )->GetPetOwner()->GetAreaID() );
+	else if(objA->IsCreature() && static_cast< Creature* >( objA )->IsTotem() && static_cast< Creature* >(objA )->GetTotemOwner())
+		atA = dbcArea.LookupEntry( static_cast< Creature* >( objA )->GetTotemOwner()->GetAreaID() );
 	else if( objA->IsPlayer() )
 		atA = dbcArea.LookupEntry( static_cast< Player* >( objA )->GetAreaID() );
 	else
@@ -243,6 +279,8 @@
 
 	if( objB->IsPet() && static_cast< Pet* >( objB )->GetPetOwner() )
 		atB = dbcArea.LookupEntry( static_cast< Pet* >( objB )->GetPetOwner()->GetAreaID() );
+	else if(objB->IsCreature() && static_cast< Creature* >( objB )->IsTotem() && static_cast< Creature* >(objB )->GetTotemOwner())
+		atB = dbcArea.LookupEntry( static_cast< Creature* >( objB )->GetTotemOwner()->GetAreaID() );
 	else if( objB->IsPlayer() )
 		atB = dbcArea.LookupEntry( static_cast< Player* >( objB )->GetAreaID() );
 	else
Index: ascent-world/GameObject.cpp
===================================================================
--- ascent-world/GameObject.cpp	(revision 3944)
+++ ascent-world/GameObject.cpp	(working copy)
@@ -472,7 +472,11 @@
 
 void GameObject::EventCloseDoor()
 {
-	SetUInt32Value(GAMEOBJECT_STATE, 0);
+	SetUInt32Value(GAMEOBJECT_STATE, 1);
+	if(m_spawn && m_spawn->flags)
+		SetUInt32Value(GAMEOBJECT_FLAGS, m_spawn->flags);
+	else
+		SetUInt32Value(GAMEOBJECT_FLAGS, 0);
 }
 
 void GameObject::UseFishingNode(Player *player)
@@ -696,3 +700,21 @@
     return (count>0);
 
 }
+
+uint32 GameObject::GetGOReqSkill()  
+{
+	if(GetEntry() == 180215) return 300;
+
+	if(GetInfo() == NULL)
+		return 0;
+
+	Lock *lock = dbcLock.LookupEntry( GetInfo()->SpellFocus );
+	if(!lock) return 0;
+	for(uint32 i=0;i<5;i++)
+		if(lock->locktype[i] == 2 && lock->minlockskill[i])
+		{
+			return lock->minlockskill[i];
+		}
+	return 0;
+}
+
Index: ascent-world/GameObject.h
===================================================================
--- ascent-world/GameObject.h	(revision 3944)
+++ ascent-world/GameObject.h	(working copy)
@@ -259,6 +259,7 @@
 	}
 	bool HasLoot();
 	MapCell * m_respawnCell;
+	uint32 GetGOReqSkill();
 
 protected:
 
Index: ascent-world/Guild.cpp
===================================================================
--- ascent-world/Guild.cpp	(revision 3944)
+++ ascent-world/Guild.cpp	(working copy)
@@ -993,9 +993,14 @@
 	itr2->second->pRank = newRank;
 	itr2->first->guildRank = newRank;
 	CharacterDatabase.Execute("UPDATE guild_data SET guildRank = 0 WHERE playerid = %u AND guildid = %u", itr->first->guid, m_guildId);
-	CharacterDatabase.Execute("UPDATE guild_data SET guildRank = %u WHERE playerid = %u AND guildid = %u", newRank->iId, itr->first->guid, m_guildId);
+	CharacterDatabase.Execute("UPDATE guild_data SET guildRank = %u WHERE playerid = %u AND guildid = %u", newRank->iId, itr2->first->guid, m_guildId);
 	CharacterDatabase.Execute("UPDATE guilds SET leaderGuid = %u WHERE guildId = %u", itr->first->guid, m_guildId);
 	m_guildLeader = itr->first->guid;
+
+	if(itr->first->m_loggedInPlayer)
+		itr->first->m_loggedInPlayer->SetGuildRank(0);
+	if(itr2->first->m_loggedInPlayer)
+		itr2->first->m_loggedInPlayer->SetGuildRank(newRank->iId);
 	m_lock.Release();
 }
 
Index: ascent-world/GuildHandler.cpp
===================================================================
--- ascent-world/GuildHandler.cpp	(revision 3944)
+++ ascent-world/GuildHandler.cpp	(working copy)
@@ -1415,6 +1415,7 @@
 				pDestItem = objmgr.CreateItem(pSourceItem2->GetEntry(), _player);
 				pDestItem->SetUInt32Value(ITEM_FIELD_STACK_COUNT, deposit_stack);
 				pDestItem->SetUInt32Value(ITEM_FIELD_CREATOR, pSourceItem2->GetUInt32Value(ITEM_FIELD_CREATOR));
+				pDestItem->m_isDirty = true;
 			}
 			else
 			{
Index: ascent-world/HonorHandler.cpp
===================================================================
--- ascent-world/HonorHandler.cpp	(revision 3944)
+++ ascent-world/HonorHandler.cpp	(working copy)
@@ -125,12 +125,13 @@
 			uint32 t = pPlayer->m_bgTeam;
 			toadd.reserve(15);		// shouldnt have more than this
 			pPlayer->m_bg->Lock();
-			set<Player*> * s = &pPlayer->m_bg->m_players[t];
+			set<uint32> * s = &pPlayer->m_bg->m_players[t];
 
-			for(set<Player*>::iterator itr = s->begin(); itr != s->end(); ++itr)
+			for(set<uint32>::iterator itr = s->begin(); itr != s->end(); ++itr)
 			{
-				if((*itr) == pPlayer || (*itr)->isInRange(pPlayer,100.0f))
-					toadd.push_back(*itr);
+				Player *plr = objmgr.GetPlayer(*itr);
+				if( plr != NULL && (plr == pPlayer || plr->isInRange(pPlayer,100.0f)) )
+					toadd.push_back(plr);
 			}
 
 			uint32 pts = Points / (uint32)toadd.size();
@@ -191,6 +192,20 @@
                             SpellEntry * halaa_spell = dbcSpell.LookupEntry(gPlayer->GetTeam()? 33004 : 33005);
                             gPlayer->CastSpell(gPlayer, halaa_spell, true);
                         }
+						// If we are in Hellfire Peninsula
+                        if(pPlayer->GetZoneId() == 3483)
+                        {
+                            // Add Mark of Thrallmar/Honor Hold
+                            SpellEntry * halaa_spell = dbcSpell.LookupEntry(gPlayer->GetTeam()? 32158 : 32155);
+                            gPlayer->CastSpell(gPlayer, halaa_spell, true);
+                        }
+                        // If we are in Zangarmarsh
+                        if(pPlayer->GetZoneId() == 3521)
+                        {
+                            // Add Mark of Thrallmar/Honor Hold
+                            SpellEntry * halaa_spell = dbcSpell.LookupEntry(gPlayer->GetTeam()? 32158 : 32155);
+                            gPlayer->CastSpell(gPlayer, halaa_spell, true);
+                        }
                     }
 
                 }
@@ -231,8 +246,9 @@
 {
 	// Why are we multiplying by 10.. ho well
 	pPlayer->SetUInt32Value(PLAYER_FIELD_KILLS, pPlayer->m_killsToday);
-	pPlayer->SetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, pPlayer->m_honorToday);
-	pPlayer->SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, pPlayer->m_killsYesterday | ( (pPlayer->m_honorYesterday * 10) << 16));
+	pPlayer->SetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, pPlayer->m_honorToday *10 );
+	//isnt it yesterday kills? TODO: check if PLAYER_FIELD_BYTES2 fits here.
+	pPlayer->SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, pPlayer->m_killsYesterday *10 /*| ( (pPlayer->m_honorYesterday * 10) << 16)*/);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS, pPlayer->m_killsLifetime);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_HONOR_CURRENCY, pPlayer->m_honorPoints);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_ARENA_CURRENCY, pPlayer->m_arenaPoints);
Index: ascent-world/Item.cpp
===================================================================
--- ascent-world/Item.cpp	(revision 3944)
+++ ascent-world/Item.cpp	(working copy)
@@ -693,6 +693,7 @@
 							TS.procChance = Entry->min[c];
 						Log.Debug( "Enchant", "Setting procChance to %u%%.", TS.procChance );
 						TS.deleted = false;
+						TS.ProcType = (GetProto()->Class == ITEM_CLASS_WEAPON)? 1 : 2;
 						TS.spellId = Entry->spell[c];
 						m_owner->m_procSpells.push_back( TS );
 					}
Index: ascent-world/Item.h
===================================================================
--- ascent-world/Item.h	(revision 3944)
+++ ascent-world/Item.h	(working copy)
@@ -111,7 +111,7 @@
 #define APPLY true
 #define REMOVE false
 
-#define RANDOM_SUFFIX_MAGIC_CALCULATION( __suffix, __scale ) int32( float( ( float( ( __suffix ) ) * float( ( __scale ) ) ) ) / 13340.0f );
+#define RANDOM_SUFFIX_MAGIC_CALCULATION( __suffix, __scale ) int32( float( ( float( ( __suffix ) ) * float( ( __scale ) ) ) ) / 10000.0f );
 
 class SERVER_DECL Item : public Object
 {
Index: ascent-world/ItemInterface.cpp
===================================================================
--- ascent-world/ItemInterface.cpp	(revision 3944)
+++ ascent-world/ItemInterface.cpp	(working copy)
@@ -1383,7 +1383,7 @@
 
 	if((slot < INVENTORY_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET) || (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET))
 	{
-		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat())
+		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat() && (slot < EQUIPMENT_SLOT_MAINHAND || slot > EQUIPMENT_SLOT_RANGED))
 			return INV_ERR_CANT_DO_IN_COMBAT;
 
 		if(proto->Flags & ITEM_FLAG_UNIQUE_EQUIP && IsEquipped(proto->ItemId))
@@ -2303,6 +2303,7 @@
 	if( SrcItem != NULL && DstItem != NULL && SrcItem->GetEntry()==DstItem->GetEntry() && SrcItem->GetProto()->MaxCount > 1 && SrcItem->wrapped_item_id == 0 && DstItem->wrapped_item_id == 0 )
 	{
 		uint32 total = SrcItem->GetUInt32Value( ITEM_FIELD_STACK_COUNT ) + DstItem->GetUInt32Value( ITEM_FIELD_STACK_COUNT );
+		SrcItem->m_isDirty = DstItem->m_isDirty = true;
 		if( total <= DstItem->GetProto()->MaxCount )
 		{
 			DstItem->ModUInt32Value( ITEM_FIELD_STACK_COUNT, SrcItem->GetUInt32Value( ITEM_FIELD_STACK_COUNT ) );
@@ -2477,7 +2478,7 @@
 	if( dstslot < INVENTORY_SLOT_BAG_END ) 
 	{
 		if( m_pItems[(int)dstslot] != NULL )		
-			m_pOwner->ApplyItemMods( m_pItems[(int)dstslot], srcslot, true );
+			m_pOwner->ApplyItemMods( m_pItems[(int)dstslot], dstslot/*srcslot*/, true );
 	}
 
 }
Index: ascent-world/Level1.cpp
===================================================================
--- ascent-world/Level1.cpp	(revision 3944)
+++ ascent-world/Level1.cpp	(working copy)
@@ -224,6 +224,21 @@
 
 			item->ApplyRandomProperties(false);
 		}
+		else
+		{
+			if (it->RandomPropId)
+			{
+				RandomProps * iRandomProperty = lootmgr.GetRandomProperties(it);
+				item->SetRandomProperty(iRandomProperty->ID);
+				item->ApplyRandomProperties(false);
+			}
+			if (it->RandomSuffixId)
+			{
+				ItemRandomSuffixEntry * iRandomSuffix = lootmgr.GetRandomSuffix(it);
+				item->SetRandomSuffix(iRandomSuffix->id);
+				item->ApplyRandomProperties(false);
+			}
+		}
 	  
 		if(!chr->GetItemInterface()->AddItemToFreeSlot(item))
 		{
Index: ascent-world/Level2.cpp
===================================================================
--- ascent-world/Level2.cpp	(revision 3944)
+++ ascent-world/Level2.cpp	(working copy)
@@ -358,7 +358,7 @@
 	if(target->IsPlayer())
 	{
 		Player * plr = static_cast< Player* >(target);
-		plr->SetUInt32Value(UNIT_FIELD_HEALTH, 0);
+		m_session->GetPlayer()->DealDamage(plr, plr->GetUInt32Value(UNIT_FIELD_HEALTH),0,0,0);
 		plr->KillPlayer();
 		BlueSystemMessageToPlr(plr, "%s killed you with a GM command.", m_session->GetPlayer()->GetName());
 	}
Index: ascent-world/LootMgr.cpp
===================================================================
--- ascent-world/LootMgr.cpp	(revision 3944)
+++ ascent-world/LootMgr.cpp	(working copy)
@@ -104,6 +104,7 @@
 	LoadLootTables("fishingloot",&FishingLoot);
 	LoadLootTables("itemloot", &ItemLoot);
 	LoadLootTables("prospectingloot", &ProspectingLoot);
+	LoadLootTables("disenchantingloot", &DisenchantingLoot);
 	LoadLootTables("pickpocketingloot", &PickpocketingLoot);
 	is_loading = false;
 }
@@ -230,8 +231,11 @@
   for(LootStore::iterator iter=ProspectingLoot.begin(); iter != ProspectingLoot.end(); ++iter)
   delete [] iter->second.items;
 
- for(LootStore::iterator iter=PickpocketingLoot.begin(); iter != PickpocketingLoot.end(); ++iter)
- delete [] iter->second.items;
+ for(LootStore::iterator iter=DisenchantingLoot.begin(); iter != DisenchantingLoot.end(); ++iter)
+	delete [] iter->second.items;
+
+  for(LootStore::iterator iter=PickpocketingLoot.begin(); iter != PickpocketingLoot.end(); ++iter)
+	delete [] iter->second.items;
 }
 
 void LootMgr::LoadLootTables(const char * szTableName,LootStore * LootTable)
@@ -513,6 +517,26 @@
  else PushLoot(&tab->second,loot,false);
 }
 
+void LootMgr::FillDisenchantingLoot(Loot *loot, uint32 loot_id)
+{
+ loot->items.clear();
+ loot->gold =0;
+
+ LootStore::iterator tab = DisenchantingLoot.find(loot_id);
+ if( DisenchantingLoot.end()==tab)return;
+ else PushLoot(&tab->second,loot,false);
+}
+
+void LootMgr::FillProspectingLoot(Loot *loot, uint32 loot_id)
+{
+ loot->items.clear();
+ loot->gold =0;
+
+ LootStore::iterator tab = ProspectingLoot.find(loot_id);
+ if( ProspectingLoot.end()==tab)return;
+ else PushLoot(&tab->second,loot,false);
+}
+
 bool LootMgr::CanGODrop(uint32 LootId,uint32 itemid)
 {
 	LootStore::iterator tab =GOLoot.find(LootId);
Index: ascent-world/LootMgr.h
===================================================================
--- ascent-world/LootMgr.h	(revision 3944)
+++ ascent-world/LootMgr.h	(working copy)
@@ -130,6 +130,8 @@
 	void FillFishingLoot(Loot * loot,uint32 loot_id);
 	void FillSkinningLoot(Loot * loot,uint32 loot_id);
 	void FillPickpocketingLoot(Loot *loot, uint32 loot_id);
+	void FillDisenchantingLoot(Loot *loot, uint32 loot_id);
+	void FillProspectingLoot(Loot *loot, uint32 loot_id);
 
 	bool CanGODrop(uint32 LootId,uint32 itemid);
 	bool IsPickpocketable(uint32 creatureId);
@@ -146,7 +148,8 @@
 	LootStore	GOLoot;
 	LootStore	ItemLoot;
 	LootStore	ProspectingLoot;
-	LootStore PickpocketingLoot;
+	LootStore	PickpocketingLoot;
+	LootStore	DisenchantingLoot;
 	std::map<uint32, std::set<uint32> > quest_loot_go;
 
 	RandomProps * GetRandomProperties(ItemPrototype * proto);
Index: ascent-world/MapMgr.cpp
===================================================================
--- ascent-world/MapMgr.cpp	(revision 3944)
+++ ascent-world/MapMgr.cpp	(working copy)
@@ -800,7 +800,7 @@
 				{
 					plObj2 = static_cast< Player* >( curObj );
 
-					if( plObj2->CanSee( obj ) && !plObj2->IsVisible( obj ) )
+					if( plObj2 != NULL && plObj2->CanSee( obj ) && !plObj2->IsVisible( obj ) )
 					{
 						CHECK_BUF;
 						count = obj->BuildCreateUpdateBlockForPlayer(*buf, plObj2);
@@ -1784,18 +1784,19 @@
 	switch (id)
 	{
 	case 4591:
-		//Only opens when the first one steps in, if 669 if you find a way, put it in :P (else was used to increase the time the door stays opened when another one steps on it)
 		GameObject *door = GetInterface()->GetGameObjectNearestCoords(803.827f, 6869.38f, -38.5434f, 184212);
-		if (door && (door->GetUInt32Value(GAMEOBJECT_STATE) == 1))
+		if (!door)
+			return;
+		if (door->GetUInt32Value(GAMEOBJECT_STATE) == 1)
 		{
 			door->SetUInt32Value(GAMEOBJECT_STATE, 0);
-			//sEventMgr.AddEvent(door, &GameObject::SetUInt32Value, GAMEOBJECT_STATE, 1, EVENT_SCRIPT_UPDATE_EVENT, 10000, 1, 0);
+			sEventMgr.AddEvent(door, &GameObject::EventCloseDoor, EVENT_GAMEOBJECT_DOOR_CLOSE, 20000, 1, 0);
 		}
-		//else
-		//{
-			//sEventMgr.RemoveEvents(door);
-			//sEventMgr.AddEvent(door, &GameObject::SetUInt32Value,GAMEOBJECT_STATE, 0, EVENT_SCRIPT_UPDATE_EVENT, 10000, 1, 0);
-		//}
+		else
+		{
+			if (sEventMgr.HasEvent(door, EVENT_GAMEOBJECT_DOOR_CLOSE))
+				sEventMgr.ModifyEventTime(door, EVENT_GAMEOBJECT_DOOR_CLOSE, 20000);
+		}
 		break;
 	}
 }
Index: ascent-world/MiscHandler.cpp
===================================================================
--- ascent-world/MiscHandler.cpp	(revision 3944)
+++ ascent-world/MiscHandler.cpp	(working copy)
@@ -64,6 +64,11 @@
 		if(!pItem)
 			return;
 		pLoot = pItem->loot;
+	}else if( UINT32_LOPART(GUID_HIPART(GetPlayer()->GetLootGUID())) == HIGHGUID_PLAYER )
+	{
+		Player * pl = _player->GetMapMgr()->GetPlayer((uint32)GetPlayer()->GetLootGUID());
+		if(!pl) return;
+		pLoot = &pl->loot;
 	}
 
 	if(!pLoot) return;
@@ -463,11 +468,6 @@
 										//pGO->Despawn( 600000 + ( RandomUInt( 300000 ) ) );
                                         return;
                                     }
-                                    else
-                                    {
-										pGO->Despawn( 60000 + ( RandomUInt( 180000 ) ) );
-										return;
-                                    }
 
                                     if( pGO->CanMine() )
                                     {
@@ -478,7 +478,7 @@
                                     else
                                     {
     									pGO->CalcMineRemaining( true );
-										pGO->Despawn( 60000 + ( RandomUInt( 180000 ) ) );
+										pGO->Despawn( 600000 + ( RandomUInt( 180000 ) ) );
 										return;
                                     }
                                 }
@@ -490,14 +490,14 @@
                                         return;
                                     }
                     			    uint32 DespawnTime = 0;
-			                        if(sQuestMgr.GetGameObjectLootQuest(pGO->GetEntry()))
-				                        DespawnTime = 120000;	   // 5 min for quest GO,
-			                        else
-			                        {
-				                        DespawnTime = 900000;	   // 15 for else
-			                        }
-
-
+									if( !IS_INSTANCE(pGO->GetMapId()) )
+									{
+										if(sQuestMgr.GetGameObjectLootQuest(pGO->GetEntry()))
+											DespawnTime = 120000;	   // 5 min for quest GO,
+										else
+											DespawnTime = 900000;	   // 15 for else
+									}
+	
 			                        pGO->Despawn(DespawnTime);
 									return;
                                 }
@@ -513,16 +513,14 @@
                         return;
                     }
                     uint32 DespawnTime = 0;
-			        if(sQuestMgr.GetGameObjectLootQuest(pGO->GetEntry()))
-				        DespawnTime = 120000;	   // 5 min for quest GO,
-			        else
-			        {
-				        DespawnTime = 900000;	   // 15 for else
-			        }
-
-
+					if( !IS_INSTANCE(pGO->GetMapId()) )
+					{
+						if(sQuestMgr.GetGameObjectLootQuest(pGO->GetEntry()))
+							DespawnTime = 120000;	   // 5 min for quest GO,
+						else
+							DespawnTime = 900000;	   // 15 for else
+					}
 			        pGO->Despawn(DespawnTime);
-
                 }
             }
         default: break;
@@ -540,6 +538,7 @@
 		if(plr)
 		{
 			plr->bShouldHaveLootableOnCorpse = false;
+			plr->loot.items.clear();
 			plr->RemoveFlag(UNIT_DYNAMIC_FLAGS, U_DYN_FLAG_LOOTABLE);
 		}
 	}
@@ -926,7 +925,7 @@
 
 void WorldSession::HandleCorpseReclaimOpcode(WorldPacket &recv_data)
 {
-	if(_player->isAlive())
+	if(_player == NULL || _player->isAlive())
 		return;
 
 	sLog.outDetail("WORLD: Received CMSG_RECLAIM_CORPSE");
@@ -1235,6 +1234,12 @@
 
 	Player *plyr = GetPlayer();
    
+	if ( plyr != NULL && plyr->IsStealth() )
+	{
+		plyr->RemoveAura(plyr->m_stealth);
+		plyr->m_stealth = 0;
+	}
+
 	CALL_GO_SCRIPT_EVENT(obj, OnActivate)(_player);
 
 	uint32 type = obj->GetUInt32Value(GAMEOBJECT_TYPE_ID);
@@ -1412,6 +1417,21 @@
 					/* expire the gameobject */
 					obj->ExpireAndDelete();
 				}
+				else if( goinfo->ID == 186811 || goinfo->ID == 181622)		// Ritual of Refreshment/Souls
+				{
+					Player * pCaster = _player->GetMapMgr()->GetPlayer(obj->m_ritualcaster);
+					if( pCaster == NULL )
+						return;
+
+					info = dbcSpell.LookupEntry(goinfo->sound1);
+					spell = new Spell(pCaster, info, true, NULL);
+					SpellCastTargets targets;
+					targets.m_unitTarget = pCaster->GetGUID();
+					spell->prepare(&targets);		
+
+					obj->ExpireAndDelete();
+				}
+
 			}
 		}break;
 	case GAMEOBJECT_TYPE_GOOBER:
Index: ascent-world/MovementHandler.cpp
===================================================================
--- ascent-world/MovementHandler.cpp	(revision 3944)
+++ ascent-world/MovementHandler.cpp	(working copy)
@@ -189,6 +189,7 @@
 	else
 	{
 		// Test to see if we can stop water breathing hack
+		/*
 		if( sWorld.antihack_water_breathing )
 		{
 			if( ( sWorld.no_antihack_on_gm && !pSession->HasGMPermissions() ) || !sWorld.no_antihack_on_gm )
@@ -202,8 +203,9 @@
 						_player->SetMovement( MOVE_ROOT, 1 );
 			}
 		}
+		*/
 	}
-
+	
 	//player is swiming and not flagged as in the water
 	if( movement_info.flags & MOVEFLAG_SWIMMING && !( _player->m_UnderwaterState & UNDERWATERSTATE_SWIMMING ) )
 	{
@@ -514,7 +516,7 @@
 						
 						if( coeff > 0.0 )
 						{
-							uint32 damage = (uint32)( _player->GetUInt32Value( UNIT_FIELD_MAXHEALTH ) * coeff );
+							uint32 damage = (uint32)( _player->GetUInt32Value( UNIT_FIELD_MAXHEALTH ) * coeff * 0.6f);
 
 							if( _player->bSafeFall )
 								damage = float2int32( float( damage ) * 0.83f );
@@ -629,6 +631,7 @@
 		{
 			if( _player->_lastHeartbeatT == 0 )
 			{
+				/*
 				if( ( sWorld.no_antihack_on_gm && !HasGMPermissions() ) || !sWorld.no_antihack_on_gm )
 				{
 					if( _player->_lastHeartbeatV >= speed )
@@ -681,6 +684,7 @@
 						}
 					}
 				}
+				*/
 			}
 			else
 			{
@@ -703,7 +707,7 @@
 	/************************************************************************/
 	/* Anti-Flying Hack                                                     */
 	/************************************************************************/
-
+/*
 	if( sWorld.antihack_flight )
 	{
 		//if( ( sWorld.no_antihack_on_gm && !HasGMPermissions() ) || !sWorld.no_antihack_on_gm )
@@ -733,11 +737,11 @@
 			}
 		}
 	}
-
+*/
 	/************************************************************************/
 	/* Anti-Fall Damage hack                                                */
 	/************************************************************************/
-
+/*
 	if( sWorld.antihack_fall_damage )
 	{
 		if( ( sWorld.no_antihack_on_gm && !HasGMPermissions() ) || !sWorld.no_antihack_on_gm )
@@ -760,7 +764,7 @@
 			}
 		}
 	}
-
+*/
 	/************************************************************************/
 	/* Anti-Packet Hack Checks                                              */
 	/************************************************************************/
@@ -861,9 +865,10 @@
 
 void WorldSession::HandleWorldportOpcode(WorldPacket & recv_data)
 {
+	uint32 unk; // time in msec? but WTF for?
 	uint32 mapid;
 	float x,y,z,o;
-	recv_data >> mapid >> x >> y >> z >> o;
+	recv_data >> unk >> mapid >> x >> y >> z >> o;
 	
 	if(!_player->IsInWorld())
 		return;
@@ -878,25 +883,89 @@
 	_player->SafeTeleport(mapid,0,vec);
 }
 
-void WorldSession::HandleTeleportToUnitOpcode(WorldPacket & recv_data)
+void WorldSession::HandleWhoisOpcode(WorldPacket & recv_data)
 {
-	uint8 unk;
-	Unit * target;
-	recv_data >> unk;
+	if(!HasGMPermissions())
+    {
+        SendNotification("You do not have permission to perform that function");
+        return;
+    }
+	
+	std::string character, message;
+    recv_data >> character;
+    
+	if(character.empty())
+    {
+		message = "Character name not specified.";
+        WorldPacket data(SMSG_WHOIS, message.size()+1);
+        data << message;
+        _player->GetSession()->SendPacket(&data);
+        return;
+    }
+ 
+    Player *player = objmgr.GetPlayer(character.c_str(), false);
+ 
+    if(player)
+	{
+        message = player->GetSession()->GetAccountName();
+	} else {
+		message = "Can't find player " + character;
+        WorldPacket data(SMSG_WHOIS, message.size()+1);
+        data << message;
+        _player->GetSession()->SendPacket(&data);
+        return;
+    }
+	// put account name in uppercase, like blizz
+	transform(message.begin(), message.end(), message.begin(), towupper);
+    WorldPacket data(SMSG_WHOIS, message.size()+1);
+    data << message;
+    _player->GetSession()->SendPacket(&data);
+}
 
-	if(!_player->IsInWorld())
-		return;
-
+void WorldSession::HandleTeleportToUnitOpcode(WorldPacket & recv_data)
+{ 
 	if(!HasGMPermissions())
 	{
 		SendNotification("You do not have permission to use this function.");
 		return;
 	}
 
-	if( (target = _player->GetMapMgr()->GetUnit(_player->GetSelection())) == NULL )
-		return;
+	if(!_player->IsInWorld())
+ 		return; 
 
-	_player->SafeTeleport(_player->GetMapId(), _player->GetInstanceID(), target->GetPosition());
+	std::string unit;
+	recv_data >> unit;
+
+	if (unit.empty()) // no unit name specified
+	{
+		Unit * target;
+		if( (target = _player->GetMapMgr()->GetUnit(_player->GetSelection())) == NULL )
+		{ // no target
+			SendNotification("Specify a player or NPC to teleport to, or target one.");
+			return;
+		}
+		if (!target->IsInWorld())
+		{
+			SendNotification("Unit not in world - cannot teleport to it.");
+			return;
+		}
+		// port to target
+		_player->SafeTeleport(_player->GetMapId(), _player->GetInstanceID(), target->GetPosition());
+	} else {
+		Player *player = objmgr.GetPlayer(unit.c_str(), false); // try and find specified player
+		if (!player) // player not found, try and find npc with that name
+		{
+			SendNotification("Can't find player or NPC named '%s'", unit.c_str());
+			return;
+		}
+		if (!player->IsInWorld())
+		{
+			SendNotification("Player '%s' is either offline or being teleported - cannot teleport to them now.");
+			return;
+		}
+		_player->SafeTeleport(player->GetMapId(), player->GetInstanceID(), player->GetPosition());
+	}
+	 
 }
 
 void WorldSession::HandleTeleportCheatOpcode(WorldPacket & recv_data)
Index: ascent-world/NPCHandler.cpp
===================================================================
--- ascent-world/NPCHandler.cpp	(revision 3944)
+++ ascent-world/NPCHandler.cpp	(working copy)
@@ -478,7 +478,7 @@
 		
 		if(aur) // If the player already have the aura, just extend it.
 		{
-			GetPlayer()->SetAurDuration(15007,aur->GetDuration());
+			GetPlayer()->SetAurDuration(15007,600000);
 		}
 		else // else add him one, that fucker, he think he will get away!?
 		{
@@ -487,6 +487,9 @@
 			targets.m_unitTarget = GetPlayer()->GetGUID();
 			Spell*sp=new Spell(_player,spellInfo,true,NULL);
 			sp->prepare(&targets);
+			Aura *aur1 = GetPlayer()->FindAura(15007);
+			if(aur1)
+				GetPlayer()->SetAurDuration(15007,600000);
 		}
 	}
 
Index: ascent-world/Object.cpp
===================================================================
--- ascent-world/Object.cpp	(revision 3944)
+++ ascent-world/Object.cpp	(working copy)
@@ -364,7 +364,8 @@
 			{
 				//flags2 |= 0x800; //in 2.3 this is some state that i was not able to decode yet
 				//Zack : Teribus the Cursed had flag 400 instead of 800 and he is flying all the time 
-				flags2 |= MOVEFLAG_NO_COLLISION;
+				//flags2 |= MOVEFLAG_NO_COLLISION;
+				flags2 |= MOVEFLAG_TAXI;
 			}
 
 			if( static_cast< Creature* >(this)->proto && static_cast< Creature* >( this )->proto->extra_a9_flags )
@@ -1386,6 +1387,9 @@
 {
 	// check if we facing something ( is the object within a 180 degree slice of our positive y axis )
 
+	if ( target == NULL )
+		return false;
+
     double x = target->GetPositionX() - m_position.x;
     double y = target->GetPositionY() - m_position.y;
 
@@ -1407,10 +1411,39 @@
     return( ( angle >= left ) && ( angle <= right ) );
 }
 
+bool Object::isInCone(Object* target)
+{
+	// check if we facing something within a 102 degree slice of our positive y axis
+
+	if ( target == NULL )
+		return false;
+
+    double x = target->GetPositionX() - m_position.x;
+    double y = target->GetPositionY() - m_position.y;
+
+    double angle = atan2( y, x );
+    angle = ( angle >= 0.0 ) ? angle : 2.0 * M_PI + angle;
+	angle -= m_position.o;
+
+    while( angle > M_PI)
+        angle -= 2.0 * M_PI;
+
+    while(angle < -M_PI)
+        angle += 2.0 * M_PI;
+
+    double left = -1.0 * ( M_PI / 3.5 );
+    double right = ( M_PI / 3.5 );
+
+    return( ( angle >= left ) && ( angle <= right ) );
+}
+
 bool Object::isInBack(Object* target)
 {
 	// check if we are behind something ( is the object within a 180 degree slice of our negative y axis )
 
+	if ( target == NULL )
+		return false;
+
     double x = m_position.x - target->GetPositionX();
     double y = m_position.y - target->GetPositionY();
 
@@ -1638,24 +1671,24 @@
 		}
 	}
 
-        ///Rage
-        float val;
+	// Rage generating - I am receiving damage!
+	if( damage && pVictim->IsPlayer() && pVictim->GetPowerType() == POWER_TYPE_RAGE && pVictim->CombatStatus.IsInCombat() )
+	{
+		float val;
+		float level = (float)pVictim->getLevel();
 
-		if( pVictim->GetPowerType() == POWER_TYPE_RAGE 
-			//&& !spellId //zack : general opinion is that spells should generate rage. I share the feeling
-			&& pVictim != this
-			&& pVictim->IsPlayer())
-		{
-			float level = (float)pVictim->getLevel();
-			float c = 0.0091107836f * level * level + 3.225598133f * level + 4.2652911f;
-			val = 2.5f * damage / c;
-			uint32 rage = pVictim->GetUInt32Value( UNIT_FIELD_POWER2 );
-			if( rage + float2int32( val ) > 1000 )
-			  val = 1000.0f - (float)pVictim->GetUInt32Value( UNIT_FIELD_POWER2 );
+		// Conversion Value
+		float c = 0.0091107836f * level * level + 3.225598133f * level + 4.2652911f;
 
-			ModUInt32Value(UNIT_FIELD_POWER2, (int32)val);
-		}
+		val = 2.5f * damage / c;
+		val *= 10;
 
+		pVictim->ModUInt32Value( UNIT_FIELD_POWER2, (int32)val );
+		if( pVictim->GetUInt32Value( UNIT_FIELD_POWER2) > 1000 )
+			pVictim->ModUInt32Value( UNIT_FIELD_POWER2, 1000 - pVictim->GetUInt32Value( UNIT_FIELD_POWER2 ) );
+	}
+
+
 	if( pVictim->IsPlayer() )
 	{
 		Player *pThis = static_cast< Player* >(pVictim);
@@ -1841,17 +1874,21 @@
 		pVictim->SetUInt32Value(UNIT_FIELD_HEALTH, 0);
 		if(pVictim->IsPlayer())
 		{
-			uint32 self_res_spell = static_cast< Player* >( pVictim )->SoulStone;
-			static_cast< Player* >( pVictim )->SoulStone = static_cast< Player* >( pVictim )->SoulStoneReceiver = 0;
+			uint32 self_res_spell = 0;
+			if (GetMapMgr()->GetMapId() != 572 && GetMapMgr()->GetMapId() != 562 && GetMapMgr()->GetMapId() != 559)
+			{
+				self_res_spell = static_cast< Player* >( pVictim )->SoulStone;
+				static_cast< Player* >( pVictim )->SoulStone = static_cast< Player* >( pVictim )->SoulStoneReceiver = 0;
 
-			if( !self_res_spell && static_cast< Player* >( pVictim )->bReincarnation )
-			{
-				SpellEntry* m_reincarnSpellInfo = dbcSpell.LookupEntry( 20608 );
-				if( static_cast< Player* >( pVictim )->CanCastDueToCooldown( m_reincarnSpellInfo ) )
+				if( !self_res_spell && static_cast< Player* >( pVictim )->bReincarnation )
 				{
-					uint32 ankh_count = static_cast< Player* >( pVictim )->GetItemInterface()->GetItemCount( 17030 );
-					if( ankh_count )
-						self_res_spell = 21169;
+					SpellEntry* m_reincarnSpellInfo = dbcSpell.LookupEntry( 20608 );
+					if( static_cast< Player* >( pVictim )->CanCastDueToCooldown( m_reincarnSpellInfo ) )
+					{
+						uint32 ankh_count = static_cast< Player* >( pVictim )->GetItemInterface()->GetItemCount( 17030 );
+						if( ankh_count )
+							self_res_spell = 21169;
+					}
 				}
 			}
 			pVictim->SetUInt32Value( PLAYER_SELF_RES_SPELL, self_res_spell );
@@ -1915,29 +1952,36 @@
 			if( pVictim->IsPlayer() )
 			{
 				sHookInterface.OnKillPlayer( plr, static_cast< Player* >( pVictim ) );
+				bool setAurastateFlag = false;
 				if(plr->getLevel() > pVictim->getLevel())
 				{
 					unsigned int diff = plr->getLevel() - pVictim->getLevel();
 					if( diff <= 8 )
 					{
 						HonorHandler::OnPlayerKilledUnit(plr, pVictim);
-						SetFlag( UNIT_FIELD_AURASTATE, AURASTATE_FLAG_LASTKILLWITHHONOR );
+						setAurastateFlag = true;
 					}
-					else
-						RemoveFlag( UNIT_FIELD_AURASTATE, AURASTATE_FLAG_LASTKILLWITHHONOR );
 				}
 				else
 				{
 					HonorHandler::OnPlayerKilledUnit( plr, pVictim );
-					SetFlag( UNIT_FIELD_AURASTATE, AURASTATE_FLAG_LASTKILLWITHHONOR );
+					setAurastateFlag = true;
 				}
+
+				if (setAurastateFlag)
+				{
+					this->SetFlag(UNIT_FIELD_AURASTATE,AURASTATE_FLAG_LASTKILLWITHHONOR);
+					if(!sEventMgr.HasEvent(this,EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE))
+						sEventMgr.AddEvent((Unit*)this,&Unit::EventAurastateExpire,(uint32)AURASTATE_FLAG_LASTKILLWITHHONOR,EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE,20000,1,0);
+					else sEventMgr.ModifyEventTimeLeft(this,EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE,20000);
+				}
 			}
 			else
 			{
 				// REPUTATION
 				plr->Reputation_OnKilledUnit( pVictim, false );
-				RemoveFlag( UNIT_FIELD_AURASTATE, AURASTATE_FLAG_LASTKILLWITHHONOR );
 			}
+
 		}
 		/* -------------------------------- HONOR + BATTLEGROUND CHECKS END------------------------ */
 
@@ -2067,8 +2111,15 @@
 				{
 					uint32 xp = CalculateXpToGive( pVictim, static_cast< Unit* >( this ) );
 					if( xp )
+					{
 						static_cast< Player* >( this )->GiveXP( xp, victimGuid, true );
 
+						this->SetFlag(UNIT_FIELD_AURASTATE,AURASTATE_FLAG_LASTKILLWITHHONOR);
+						if(!sEventMgr.HasEvent(this,EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE))
+							sEventMgr.AddEvent((Unit*)this,&Unit::EventAurastateExpire,(uint32)AURASTATE_FLAG_LASTKILLWITHHONOR,EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE,20000,1,0);
+						else sEventMgr.ModifyEventTimeLeft(this,EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE,20000);
+					}
+
 					if( static_cast< Player* >( this )->GetSummon() && static_cast< Player* >( this )->GetSummon()->GetUInt32Value( UNIT_CREATED_BY_SPELL ) == 0 )
 					{
 						xp = CalculateXpToGive( pVictim, static_cast< Player* >( this )->GetSummon() );
@@ -2108,6 +2159,8 @@
 				if(pVictim->IsPet())
 				{
 					static_cast< Pet* >( pVictim )->DelayedRemove( false, true );
+					static_cast< Pet* >( pVictim )->SendNullSpellsToOwner();
+
 					//remove owner warlock soul link from caster
 					Player* owner = static_cast<Pet*>( pVictim )->GetPetOwner();
 					if( owner != NULL )
@@ -2132,7 +2185,7 @@
 			static_cast< Player* >( pVictim )->m_BreathDamageTimer = 0;
 			static_cast< Player* >( pVictim )->m_SwimmingTime = 0;
 
-			/* -------------------- KILL PET WHEN PLAYER DIES ---------------*/
+			/* -------------------- KILL PET AND TOTEMS WHEN PLAYER DIES ---------------*/
 			if( static_cast< Player* >( pVictim )->GetSummon() != NULL )
 			{
 				if( pVictim->GetUInt32Value( UNIT_CREATED_BY_SPELL ) > 0 )
@@ -2140,7 +2193,12 @@
 				else
 					static_cast< Player* >( pVictim )->GetSummon()->Remove( true, true, true );
 			}
-			/* -------------------- KILL PET WHEN PLAYER DIES END---------------*/
+			for (int slot = 0; slot < 4; slot++)
+			{
+				if (static_cast<Player*>(pVictim)->m_TotemSlots[slot] != 0)
+					static_cast<Player*>(pVictim)->m_TotemSlots[slot]->TotemExpire();
+			}
+			/* -------------------- KILL PET AND TOTEMS WHEN PLAYER DIES END---------------*/
 		}
 		else sLog.outError("DealDamage for Unknown Object.");
 	}
@@ -2204,7 +2262,7 @@
 	{
 		Unit* caster = static_cast< Unit* >( this );
 		caster->RemoveAurasByInterruptFlag( AURA_INTERRUPT_ON_START_ATTACK );
-		res += caster->GetSpellDmgBonus( pVictim, spellInfo, ( int )res );
+		res += caster->GetSpellDmgBonus( pVictim, spellInfo, ( int )res ,0);
 
 		//==========================================================================================
 		//==============================Post +SpellDamage Bonus Modifications=======================
@@ -2215,72 +2273,81 @@
 		{
 			//------------------------------critical strike chance--------------------------------------	
 			// lol ranged spells were using spell crit chance
-			float CritChance;
-			if( spellInfo->is_ranged_spell )
+			if ( spellInfo && (spellInfo->Flags3 & FLAGS3_CANNOT_CRIT) )
 			{
+				// do we need to do something extra ?
+			}
+			else
+			{
+				float CritChance;
+				if( spellInfo->is_ranged_spell )
+				{
 
-				if( IsPlayer() )
-				{
-					CritChance = GetFloatValue( PLAYER_RANGED_CRIT_PERCENTAGE );
-					CritChance += static_cast< Player* >( pVictim )->res_R_crit_get();
-					CritChance += float( pVictim->AttackerCritChanceMod[spellInfo->School] );
+					if( IsPlayer() )
+					{
+						CritChance = GetFloatValue( PLAYER_RANGED_CRIT_PERCENTAGE );
+					}
+					else
+					{
+						CritChance = 5.0f; // static value for mobs.. not blizzlike, but an unfinished formula is not fatal :)
+					}
+					if( pVictim->IsPlayer() )
+					{
+						CritChance += static_cast< Player* >( pVictim )->res_R_crit_get();
+						CritChance += float( pVictim->AttackerCritChanceMod[spellInfo->School] );
+						CritChance -= static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_RANGED_CRIT_RESILIENCE );
+					}
 				}
 				else
 				{
-					CritChance = 5.0f; // static value for mobs.. not blizzlike, but an unfinished formula is not fatal :)
-				}
-				if( pVictim->IsPlayer() )
-				CritChance -= static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_RANGED_CRIT_RESILIENCE );
-			}
-			else
-			{
-				CritChance = caster->spellcritperc + caster->SpellCritChanceSchool[school] + pVictim->AttackerCritChanceMod[school];
-				if( caster->IsPlayer() && ( pVictim->m_rooted - pVictim->m_stunned ) )	
-					CritChance += static_cast< Player* >( caster )->m_RootedCritChanceBonus;
+					CritChance = caster->spellcritperc + caster->SpellCritChanceSchool[school] + pVictim->AttackerCritChanceMod[school];
+					if( caster->IsPlayer() && ( pVictim->m_rooted - pVictim->m_stunned ) )	
+						CritChance += static_cast< Player* >( caster )->m_RootedCritChanceBonus;
 
-				if( spellInfo->SpellGroupType )
-				{
-					SM_FFValue(caster->SM_CriticalChance, &CritChance, spellInfo->SpellGroupType);
+					if( spellInfo->SpellGroupType )
+					{
+						SM_FFValue(caster->SM_CriticalChance, &CritChance, spellInfo->SpellGroupType);
 	#ifdef COLLECTION_OF_UNTESTED_STUFF_AND_TESTERS
-					float spell_flat_modifers=0;
-					SM_FFValue(caster->SM_CriticalChance,&spell_flat_modifers,spellInfo->SpellGroupType);
-					if(spell_flat_modifers!=0)
-						printf("!!!!spell critchance mod flat %f ,spell group %u\n",spell_flat_modifers,spellInfo->SpellGroupType);
+						float spell_flat_modifers=0;
+						SM_FFValue(caster->SM_CriticalChance,&spell_flat_modifers,spellInfo->SpellGroupType);
+						if(spell_flat_modifers!=0)
+							printf("!!!!spell critchance mod flat %f ,spell group %u\n",spell_flat_modifers,spellInfo->SpellGroupType);
 	#endif
+					}
+					if( pVictim->IsPlayer() )
+					CritChance -= static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_SPELL_CRIT_RESILIENCE );
 				}
-				if( pVictim->IsPlayer() )
-				CritChance -= static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_SPELL_CRIT_RESILIENCE );
-			}
-			if( CritChance < 0 ) CritChance = 0;
-			if( CritChance > 95 ) CritChance = 95;
-			critical = Rand(CritChance);
-			//sLog.outString( "SpellNonMeleeDamageLog: Crit Chance %f%%, WasCrit = %s" , CritChance , critical ? "Yes" : "No" );
+				if( CritChance < 0 ) CritChance = 0;
+				if( CritChance > 95 ) CritChance = 95;
+				critical = Rand(CritChance);
+				//sLog.outString( "SpellNonMeleeDamageLog: Crit Chance %f%%, WasCrit = %s" , CritChance , critical ? "Yes" : "No" );
 //==========================================================================================
 //==============================Spell Critical Hit==========================================
 //==========================================================================================
-			if (critical)
-			{		
-				float b = res / 2.0f;
-				if( spellInfo->SpellGroupType )
-					SM_PFValue( caster->SM_PCriticalDamage, &b, spellInfo->SpellGroupType );
-				res += b;
-				if( pVictim->IsPlayer() )
-				{
+				if (critical)
+				{		
+					float b = res / 2.0f;
+					if( spellInfo->SpellGroupType )
+						SM_PFValue( caster->SM_PCriticalDamage, &b, spellInfo->SpellGroupType );
+					res += b;
+					if( pVictim->IsPlayer() )
+					{
 					//res = res*(1.0f-2.0f*static_cast< Player* >(pVictim)->CalcRating(PLAYER_RATING_MODIFIER_MELEE_CRIT_RESISTANCE));
 					//Resilience is a special new rating which was created to reduce the effects of critical hits against your character.
 					//It has two components; it reduces the chance you will be critically hit by x%, 
 					//and it reduces the damage dealt to you by critical hits by 2x%. x is the percentage resilience granted by a given resilience rating. 
 					//It is believed that resilience also functions against spell crits, 
 					//though it's worth noting that NPC mobs cannot get critical hits with spells.
-					float dmg_reduction_pct = 2 * static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_MELEE_CRIT_RESILIENCE ) / 100.0f;
-					if( dmg_reduction_pct > 1.0f )
-						dmg_reduction_pct = 1.0f; //we cannot resist more then he is criticalling us, there is no point of the critical then :P
-					res = res - res * dmg_reduction_pct;
+						float dmg_reduction_pct = 2 * static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_MELEE_CRIT_RESILIENCE ) / 100.0f;
+						if( dmg_reduction_pct > 1.0f )
+							dmg_reduction_pct = 1.0f; //we cannot resist more then he is criticalling us, there is no point of the critical then :P
+						res = res - res * dmg_reduction_pct;
+					}
+
+					pVictim->Emote( EMOTE_ONESHOT_WOUNDCRITICAL );
+					aproc |= PROC_ON_SPELL_CRIT_HIT;
+					vproc |= PROC_ON_SPELL_CRIT_HIT_VICTIM;
 				}
-
-				pVictim->Emote( EMOTE_ONESHOT_WOUNDCRITICAL );
-				aproc |= PROC_ON_SPELL_CRIT_HIT;
-				vproc |= PROC_ON_SPELL_CRIT_HIT_VICTIM;
 			}
 		}
 	}
@@ -2338,7 +2405,8 @@
 //==============================Data Sending ProcHandling===================================
 //==========================================================================================
 	SendSpellNonMeleeDamageLog(this, pVictim, spellID, float2int32(res), school, abs_dmg, dmg.resisted_damage, false, 0, critical, IsPlayer());
-	
+	DealDamage( pVictim, float2int32( res ), 2, 0, spellID );
+
 	if( this->IsUnit() && allowProc && spellInfo->Id != 25501 )
 	{
 		pVictim->HandleProc( vproc, static_cast< Unit* >( this ), spellInfo, float2int32( res ) );
@@ -2351,8 +2419,6 @@
 			static_cast< Player* >( this )->m_casted_amount[school] = ( uint32 )res;
 	}
 
-	DealDamage( pVictim, float2int32( res ), 2, 0, spellID );
-
 	if( pVictim->GetCurrentSpell() )
 		pVictim->GetCurrentSpell()->AddTime( school );
 
@@ -2428,7 +2494,7 @@
 
 void Object::SendSpellNonMeleeDamageLog( Object* Caster, Object* Target, uint32 SpellID, uint32 Damage, uint8 School, uint32 AbsorbedDamage, uint32 ResistedDamage, bool PhysicalDamage, uint32 BlockedDamage, bool CriticalHit, bool bToset )
 {
-	if ((!Caster || !Target) && SpellID)
+	if ( Caster == NULL || Target == NULL || !SpellID )
 		return;
 
 	WorldPacket data(SMSG_SPELLNONMELEEDAMAGELOG,40);
Index: ascent-world/Object.h
===================================================================
--- ascent-world/Object.h	(revision 3944)
+++ ascent-world/Object.h	(working copy)
@@ -288,6 +288,7 @@
 
 	// Use it to Check if a object is in front of another one
 	bool isInFront(Object* target);
+	bool isInCone(Object* target);
 	bool isInBack(Object* target);
 	/* Calculates the angle between two Positions */
 	float calcAngle( float Position1X, float Position1Y, float Position2X, float Position2Y );
Index: ascent-world/ObjectMgr.cpp
===================================================================
--- ascent-world/ObjectMgr.cpp	(revision 3944)
+++ ascent-world/ObjectMgr.cpp	(working copy)
@@ -1824,6 +1824,32 @@
 	} while(result->NextRow());
 	delete result;
 	Log.Notice("ObjectMgr", "%u spell fixes loaded.", fixed_count);
+
+	/*##########################################################################################*/
+
+	// Loads data from spell_data_extra table
+	QueryResult * result1 = WorldDatabase.Query("SELECT * FROM spell_data_extra");
+	if(result1 == 0) return;
+
+	uint32 override_count = 0;
+	do
+	{
+		Field * fields1 = result1->Fetch();
+		uint32 spell_id = fields1[0].GetUInt32();
+		SpellEntry * sp = dbcSpell.LookupEntry(spell_id);
+		if(sp == 0) 
+			continue;
+
+		if(sp->dmg_bonus == 0)
+		{
+			sp->dmg_bonus = fields1[1].GetUInt32();
+			override_count++;
+		}
+
+	} while (result1->NextRow());
+
+	delete result1;
+	Log.Notice("ObjectMgr", "%u spell data extra loaded.", override_count);
 }
 
 void ObjectMgr::LoadSpellOverride()
@@ -2613,3 +2639,27 @@
 	m_arenaTeamLock.Release();
 }
 
+void ObjectMgr::UpdateArenaTeamWeekly()
+{	// reset weekly matches count for all teams and all members
+	m_arenaTeamLock.Acquire();
+	for(uint32 i = 0; i < NUM_ARENA_TEAM_TYPES; ++i)
+	{
+		for(HM_NAMESPACE::hash_map<uint32,ArenaTeam*>::iterator itr = m_arenaTeamMap[i].begin(); itr != m_arenaTeamMap[i].end(); ++itr)
+		{
+			ArenaTeam *team = itr->second;
+			if(team)
+			{
+				team->m_stat_gamesplayedweek = 0;
+				team->m_stat_gameswonweek = 0;
+				for(uint32 j = 0; j < team->m_memberCount; ++j)
+				{
+					team->m_members[j].Played_ThisWeek = 0;
+					team->m_members[j].Won_ThisWeek = 0;
+				}
+				team->SaveToDB();
+			}
+		}
+	}
+	m_arenaTeamLock.Release();
+}
+
Index: ascent-world/ObjectMgr.h
===================================================================
--- ascent-world/ObjectMgr.h	(revision 3944)
+++ ascent-world/ObjectMgr.h	(working copy)
@@ -505,6 +505,7 @@
 	ArenaTeam * GetArenaTeamById(uint32 id);
 	ArenaTeam * GetArenaTeamByGuid(uint32 guid, uint32 Type);
 	void UpdateArenaTeamRankings();
+	void UpdateArenaTeamWeekly();
 	void LoadArenaTeams();
 	HM_NAMESPACE::hash_map<uint32, ArenaTeam*> m_arenaTeamMap[3];
 	HM_NAMESPACE::hash_map<uint32, ArenaTeam*> m_arenaTeams;
Index: ascent-world/ObjectStorage.cpp
===================================================================
--- ascent-world/ObjectStorage.cpp	(revision 3944)
+++ ascent-world/ObjectStorage.cpp	(working copy)
@@ -24,7 +24,7 @@
 const char * gItemPrototypeFormat						= "uuuussssuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuffuffuffuffuffuuuuuuuuuufuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusuuuuuuuuuuuuuuuuuuuuuuuuuuuu";
 const char * gCreatureNameFormat						= "usssuuuuuuuuuuffcc";
 const char * gGameObjectNameFormat						= "uuusuuuuuuuuuuuuuuuuuuuuuuuu";
-const char * gCreatureProtoFormat						= "uuuuuuufuuuffuffuuuuuuuuuuuuuuuuuuffsuuuufffu";
+const char * gCreatureProtoFormat						= "uuuuuuufuuuffuffuuuuuuuuuuuuuuuuuuffsuuuufffuu";
 const char * gAreaTriggerFormat							= "ucuusffffuu";
 const char * gItemPageFormat							= "usu";
 const char * gNpcTextFormat								= "ufssuuuuuuufssuuuuuuufssuuuuuuufssuuuuuuufssuuuuuuufssuuuuuuufssuuuuuuufssuuuuuuu";
Index: ascent-world/Opcodes.cpp
===================================================================
--- ascent-world/Opcodes.cpp	(revision 3944)
+++ ascent-world/Opcodes.cpp	(working copy)
@@ -868,7 +868,8 @@
 	{SMSG_MOVE_UNLOCK_MOVEMENT,                    "SMSG_MOVE_UNLOCK_MOVEMENT"},
 	{CMSG_MOVE_UNLOCK_MOVEMENT_ACK,                "CMSG_MOVE_UNLOCK_MOVEMENT_ACK"},
 	{SMSG_SET_COMBO_POINTS,                        "SMSG_SET_COMBO_POINTS"},
-	{SMSG_PET_LEARNT_SPELL,                        "SMSG_PET_LEARNT_SPELL"},
+	{SMSG_SET_AURA_MULTIPLE,					   "SMSG_SET_AURA_MULTIPLE"},
+	{SMSG_SET_AURA_SINGLE,                         "SMSG_SET_AURA_SINGLE"},
 	{SMSG_TARGET_CAST_RESULT,                      "SMSG_TARGET_CAST_RESULT"},
 	{CMSG_REPORT_SPAM,                             "CMSG_REPORT_SPAM"},
 	{SMSG_REPORT_SPAM_RESPONSE,                    "SMSG_REPORT_SPAM_RESPONSE"},
Index: ascent-world/Opcodes.h
===================================================================
--- ascent-world/Opcodes.h	(revision 3944)
+++ ascent-world/Opcodes.h	(working copy)
@@ -885,7 +885,8 @@
 	CMSG_MOVE_UNLOCK_MOVEMENT_ACK					= 913,	//(0x0391)
 	SMSG_SET_COMBO_POINTS							= 925,	//(0x039D)
 	SMSG_VOICE_SESSION								= 926,	//(0x039E)
-	SMSG_PET_LEARNT_SPELL							= 932,	//(0x03A4)
+	SMSG_SET_AURA_MULTIPLE							= 931,  //TODO
+	SMSG_SET_AURA_SINGLE							= 932,	//(0x03A4)
 	SMSG_TARGET_CAST_RESULT							= 934,	//(0x03A6)
 	MSG_MOVE_FLY_DOWN_UNK							= 935,  //(0x03A7)
 	// 938
Index: ascent-world/Player.cpp
===================================================================
--- ascent-world/Player.cpp	(revision 3944)
+++ ascent-world/Player.cpp	(working copy)
@@ -231,14 +231,17 @@
 		BaseResistanceModPctNeg[x] = 0; 
 		ResistanceModPctPos[x] = 0;
 		ResistanceModPctNeg[x] = 0;
-		SpellDmgDoneByInt[x] = 0;
-		SpellHealDoneByInt[x] = 0;
-		SpellDmgDoneBySpr[x] = 0;
-		SpellHealDoneBySpr[x] = 0;
 		SpellDelayResist[x] = 0;
 		m_casted_amount[x] = 0;
 	} 
-		
+
+	for(uint32 a = 0; a < 6; a++)
+		for(uint32 x = 0; x < 7; x++)
+		{	
+			SpellDmgDoneByAttribute[a][x] = 0;
+			SpellHealDoneByAttribute[a][x] = 0;
+		}
+
 	for(uint32 x = 0; x < 5; x++)
 	{
 		FlatStatModPos[x] = 0;
@@ -372,7 +375,7 @@
 	m_speedChangeCounter=1;
 	memset(&m_bgScore,0,sizeof(BGScore));
 	m_arenaPoints = 0;
-	memset(&m_spellIndexTypeTargets, 0, sizeof(uint64)*NUM_SPELL_TYPE_INDEX);
+	memset(&m_spellIndexTypeTargets, 0, sizeof(uint64)*MECHANIC_END);
 	m_base_runSpeed = m_runSpeed;
 	m_base_walkSpeed = m_walkSpeed;
 	m_arenateaminviteguid=0;
@@ -404,6 +407,7 @@
 
 void Player::OnLogin()
 {
+	/*
 	if (this->getClass() == DRUID)
 	{
 		SSAura* aura = new SSAura();
@@ -411,6 +415,7 @@
 		aura->forms = FORM_MOONKIN;
 		this->m_ssAuras.insert(aura);
 	}
+	*/
 }
 
 
@@ -962,6 +967,9 @@
 		return;
 	}
 
+	if ( IsFeared() || IsStunned() )
+		return;
+
 	Unit *pVictim = 0;
 	if(m_curSelection)
 		pVictim = GetMapMgr()->GetUnit(m_curSelection);
@@ -1348,6 +1356,9 @@
 ///  It assumes you will send out an UpdateObject packet at a later time.
 void Player::GiveXP(uint32 xp, const uint64 &guid, bool allowbonus)
 {
+	if ( isDead() )
+		return;
+
 	if ( xp < 1 )
 		return;
 
@@ -1862,7 +1873,10 @@
 		if(pet->active)
 		{
 			if(iActivePet)  // how the hell can this happen
-				printf("pet warning - >1 active pet.. weird..");
+			{
+				//printf("pet warning - >1 active pet.. weird..");
+
+			}
 			else
 				iActivePet = pet->number;
 		}	   
@@ -2073,13 +2087,18 @@
 	Unit::DestroyForPlayer( target );
 }
 
+#define IS_ARENA(x) ( (x) >= BATTLEGROUND_ARENA_2V2 && (x) <= BATTLEGROUND_ARENA_5V5 )
 
 void Player::SaveToDB(bool bNewCharacter /* =false */)
 {
+	bool in_arena = false;
 	QueryBuffer * buf = NULL;
 	if(!bNewCharacter)
 		buf = new QueryBuffer;
 
+	if( m_bg != NULL && IS_ARENA( m_bg->GetType() ) )
+		in_arena = true;
+
 	if(m_uint32Values[PLAYER_CHARACTER_POINTS2]>2)
 		m_uint32Values[PLAYER_CHARACTER_POINTS2]=2;
  
@@ -2172,15 +2191,29 @@
 	<< m_uint32Values[PLAYER_BYTES] << ","
 	<< m_uint32Values[PLAYER_BYTES_2] << ","
 	<< player_flags << ","
-	<< m_uint32Values[PLAYER_FIELD_BYTES] << ","
+	<< m_uint32Values[PLAYER_FIELD_BYTES] << ",";
+ 
+	if( in_arena )
+	{
+		// if its an arena, save the entry coords instead
+		ss << m_bgEntryPointX << ", ";
+		ss << m_bgEntryPointY << ", ";
+		ss << m_bgEntryPointZ << ", ";
+		ss << m_bgEntryPointO << ", ";
+		ss << m_bgEntryPointMap << ", ";
+	}
+	else
+	{
+		// save the normal position
+		ss << m_position.x << ", "
+			<< m_position.y << ", "
+			<< m_position.z << ", "
+			<< m_position.o << ", "
+			<< m_mapId << ", ";
+	}
 
-	<< m_position.x << ", "
-	<< m_position.y << ", "
-	<< m_position.z << ", "
-	<< m_position.o << ", "
-	<< m_mapId << ", "
-	<< m_zoneId << ", '";
-		
+	ss << m_zoneId << ", '";
+	
 	for(uint32 i = 0; i < 8; i++ )
 		ss << m_taximask[i] << " ";
 	ss << "', "
@@ -2221,9 +2254,16 @@
 		<< (uint32)m_StableSlotCount << ",";
 	
 	// instances
-	ss 
-	<< m_instanceId		   << ", "
-	<< m_bgEntryPointMap	  << ", " 
+	if( in_arena )
+	{
+		ss << m_bgEntryPointInstance << ", ";
+	}
+	else
+	{
+		ss << m_instanceId		   << ", ";
+	}
+
+	ss << m_bgEntryPointMap	  << ", " 
 	<< m_bgEntryPointX		<< ", " 
 	<< m_bgEntryPointY		<< ", " 
 	<< m_bgEntryPointZ		<< ", "
@@ -3256,6 +3296,15 @@
 #ifdef ENABLE_COMPRESSED_MOVEMENT
 	sEventMgr.AddEvent(this, &Player::EventDumpCompressedMovement, EVENT_PLAYER_FLUSH_MOVEMENT, World::m_movementCompressInterval, 0, EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
 #endif
+
+	if( m_mapMgr != NULL && m_mapMgr->m_battleground != NULL && m_bg != m_mapMgr->m_battleground )
+	{
+		m_bg = m_mapMgr->m_battleground;
+		m_bg->PortPlayer( this, true );
+	}
+
+	if( m_bg != NULL )
+		m_bg->OnPlayerPushed( this );
 }
 
 void Player::ResetHeartbeatCoords()
@@ -3359,6 +3408,9 @@
 // TODO: perhaps item should just have a list of mods, that will simplify code
 void Player::_ApplyItemMods(Item* item, int8 slot, bool apply, bool justdrokedown /* = false */, bool skip_stat_apply /* = false  */)
 {
+	if (slot > INVENTORY_SLOT_BAG_END)
+		return;
+
 	ASSERT( item );
 	ItemPrototype* proto = item->GetProto();
 
@@ -3627,6 +3679,7 @@
 				ts.procChance = 5;
 				ts.caster = this->GetGUID();
 				ts.procFlags = PROC_ON_MELEE_ATTACK;
+				ts.ProcType = (item->GetProto()->Class == ITEM_CLASS_WEAPON)? 1 : 2;
 				ts.deleted = false;
 				m_procSpells.push_front( ts );			
 			}
@@ -3665,6 +3718,16 @@
 			}
 		}
 	}
+
+	if( !apply ) // force remove auras added by using this item
+	{
+		for(uint32 k = 0; k < MAX_POSITIVE_AURAS; ++k)
+		{
+			Aura* m_aura = this->m_auras[k];
+			if( m_aura != NULL && m_aura->m_castedItemId && m_aura->m_castedItemId == proto->ItemId )
+				m_aura->Remove();
+		}
+	}
 	
 	if( !skip_stat_apply )
 		UpdateStats();
@@ -4414,7 +4477,11 @@
 	defence_contribution += CalcRating( PLAYER_RATING_MODIFIER_DEFENCE ) * 0.04f;
 
 	// dodge
-	tmp = baseDodge[pClass] + float( GetUInt32Value( UNIT_FIELD_STAT1 ) / dodgeRatio[69][pClass] );
+	if( dodgeRatio[pLevel - 1][pClass] != 0.0f ) {
+		tmp = baseDodge[pClass] + float( GetUInt32Value( UNIT_FIELD_STAT1 ) / dodgeRatio[pLevel - 1][pClass] );
+	} else {
+		tmp = baseDodge[pClass] + float( GetUInt32Value( UNIT_FIELD_STAT1 ) / dodgeRatio[69][pClass] );
+	}
 	tmp += CalcRating( PLAYER_RATING_MODIFIER_DODGE ) + this->GetDodgeFromSpell();
 	tmp += defence_contribution;
 	if( tmp < 0.0f )tmp = 0.0f;
@@ -4944,6 +5011,7 @@
 						return bGMTagOn; // GM can see invisible players
 				}
 
+				/*
 				if(pObj->IsStealth()) // Stealth Detection (  I Hate Rogues :P  )
 				{
 					if(GetGroup() && pObj->GetGroup() == GetGroup() // can see stealthed group members except when dueling them
@@ -4959,7 +5027,8 @@
 						if( getLevel() < 60 )
 							detectRange = 5.0f + float( getLevel() ) + 0.2f * (float)( getLevel() + GetStealthDetectBonus() - pObj->GetStealthLevel() );
 						else
-							detectRange = 65.0f + 0.2f * (float)( getLevel() + GetStealthDetectBonus() - pObj->GetStealthLevel() );						// Hehe... stealth skill is increased by 5 each level and detection skill is increased by 5 each level too.
+							detectRange = 65.0f + 0.2f * (float)( getLevel() + GetStealthDetectBonus() - pObj->GetStealthLevel() );	
+						// Hehe... stealth skill is increased by 5 each level and detection skill is increased by 5 each level too.
 						// This way, a level 70 should easily be able to detect a level 4 rogue (level 4 because that's when you get stealth)
 						//	detectRange += 0.2f * ( getLevel() - pObj->getLevel() );
 						if( detectRange < 1.0f )
@@ -4979,7 +5048,41 @@
 					if( GetDistanceSq( pObj ) > detectRange * detectRange )
 						return bGMTagOn; // GM can see stealthed players
 				}
+				*/
 
+				
+				if(pObj->IsStealth()) // Stealth Detection (  I Hate Rogues :P  )
+				{
+					if(GetGroup() && pObj->GetGroup() == GetGroup() // can see stealthed group members except when dueling them
+							&& DuelingWith != pObj)
+						return true;
+
+					if(pObj->stalkedby == GetGUID()) // Hunter's Mark / MindVision is visible to the caster
+						return true;
+
+					if(isInFront(pObj)) // stealthed player is in front of us
+					{
+						// Detection Range = 5yds + (Detection Skill - Stealth Skill)/5
+						if(getLevel() < 60)
+							detectRange = 5.0f + getLevel() + 0.2f * (float)(GetStealthDetectBonus() - pObj->GetStealthLevel());
+						else
+							detectRange = 65.0f + 0.2f * (float)(GetStealthDetectBonus() - pObj->GetStealthLevel());
+
+						if(detectRange < 1.0f) detectRange = 1.0f; // Minimum Detection Range = 1yd
+					}
+					else // stealthed player is behind us
+					{
+						if(GetStealthDetectBonus() > 1000) return true; // immune to stealth
+						else detectRange = 0.0f;
+					}
+
+					detectRange += GetFloatValue(UNIT_FIELD_BOUNDINGRADIUS); // adjust range for size of player
+					detectRange += pObj->GetFloatValue(UNIT_FIELD_BOUNDINGRADIUS); // adjust range for size of stealthed player
+
+					if(GetDistance2dSq(pObj) > detectRange * detectRange)
+						return bGMTagOn; // GM can see stealthed players
+				}
+
 				return true;
 			}
 		//------------------------------------------------------------------
@@ -5112,7 +5215,7 @@
 		m_spellTypeTargets[2] = NULL;*/
 	if(pObj->IsUnit())
 	{
-		for(uint32 x = 0; x < NUM_SPELL_TYPE_INDEX; ++x)
+		for(uint32 x = 0; x < MECHANIC_END; ++x)
 			if(m_spellIndexTypeTargets[x] == pObj->GetGUID())
 				m_spellIndexTypeTargets[x] = 0;
 	}
@@ -5321,7 +5424,7 @@
         } 
 
 		slottype = 0;
-		if( m_Group != NULL )
+		if(m_Group != NULL && loot_type < 2)
 		{
 			switch( m_Group->GetMethod() )
 			{
@@ -5427,7 +5530,7 @@
 					{
 						for(GroupMembersSet::iterator itr = pGroup->GetSubGroup(i)->GetGroupMembersBegin(); itr != pGroup->GetSubGroup(i)->GetGroupMembersEnd(); ++itr)
 						{
-							if((*itr)->m_loggedInPlayer && (*itr)->m_loggedInPlayer->GetItemInterface()->CanReceiveItem(itemProto, iter->iItemsCount) == 0)
+							if((*itr)->m_loggedInPlayer && (*itr)->m_loggedInPlayer->GetItemInterface()->CanReceiveItem(itemProto, iter->iItemsCount) == 0 && this->GetMapId() == (*itr)->m_loggedInPlayer->GetMapId() )
 							{
 								(*itr)->m_loggedInPlayer->GetSession()->SendPacket(&data2);
 							}
@@ -6286,7 +6389,7 @@
 	float amt = (Spirit*HPRegen->val+HPRegenBase->val*100)*(1+PctRegenModifier);
 	amt *= sWorld.getRate(RATE_HEALTH);//Apply shit from conf file
 
-	if(m_interruptRegen)
+	if(inCombat)
 		amt *= PctIgnoreRegenModifier;
 
 	if(amt != 0)
@@ -6310,22 +6413,11 @@
 	//The Anger Management talent changes this to 2 rage every 3 seconds.
 	uint32 cur = GetUInt32Value(UNIT_FIELD_POWER2);
 	uint32 decayValue = 30; // default not modified
-	
-	if(cur) {
-	  uint32 cl=getClass();
 
-	  switch(cl) {
-	  case WARRIOR:
-	    // Check for talent modifiers when the talent code is completed
-	    break;
-	  case DRUID:
-	    // For now, i don't think there is anything that might change druids
-	    // rage per decay anywhere
-	    break;
-	  }
-
-	  SetUInt32Value(UNIT_FIELD_POWER2, (cur <= decayValue) ? 0 : (cur - decayValue));
-	}
+	uint32 newrage = ((int)cur <= decayValue) ? 0 : cur-decayValue;
+    if (newrage > 1000 )
+	  newrage = 1000;
+	SetUInt32Value(UNIT_FIELD_POWER2,newrage);
 }
 
 void Player::RegenerateEnergy()
@@ -7118,7 +7210,6 @@
 	data << GetGUID();
 	pTarget->GetSession()->SendPacket(&data);
 
-	m_duelCountdownTimer = 3000;
 }
 
 void Player::DuelCountdown()
@@ -8082,6 +8173,7 @@
 	}
 
 	sInstanceMgr.BuildSavedInstancesForPlayer(this);
+	CombatStatus.UpdateFlag();
 }
 
 void Player::OnWorldPortAck()
@@ -8258,7 +8350,7 @@
 		case EXPERTISE_RATING_2:
 			{
 				ModUInt32Value( PLAYER_RATING_MODIFIER_EXPERTISE, val );
-				ModUInt32Value( PLAYER_EXPERTISE, float2int32( CalcRating( PLAYER_RATING_MODIFIER_EXPERTISE ) ) );
+				ModUInt32Value( PLAYER_EXPERTISE, val );
 			}break;
 		case RESILIENCE_RATING:
 			{
@@ -8295,14 +8387,13 @@
 	//for(uint32 x=0;x<MAX_AURAS+MAX_PASSIVE_AURAS;x++)
 	for( uint32 x = 0; x < MAX_AURAS; x++ )
 	{
-		if( m_auras[x] != NULL )
+		if( m_auras[x] != NULL && m_auras[x]->m_spellProto != NULL )
 		{
 			Aura* aur = m_auras[x];
 			bool skip = false;
 			for( uint32 i = 0; i < 3; ++i )
 			{
-				if( aur->m_spellProto->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA ||
-					aur->m_spellProto->Effect[i] == SPELL_EFFECT_ADD_FARSIGHT )
+				if( aur->m_spellProto->Effect[i] == SPELL_EFFECT_APPLY_AREA_AURA || aur->m_spellProto->Effect[i] == SPELL_EFFECT_ADD_FARSIGHT )
 				{
 					skip = true;
 					break;
@@ -8620,14 +8711,15 @@
 		SetUInt32Value( PLAYER_RATING_MODIFIER_RANGED_SKILL, cr );
 
 /////////////////////////////////RANGED end
-		tmp = 1;
+		/*
+		tmp = 1; 
 		for(i = damagedone.begin();i != damagedone.end();i++)
 		if(i->second.wclass==(uint32)-1)  //any weapon
 			tmp += i->second.value/100.0f;
 		
 		//display only modifiers for any weapon
 		SetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PCT ,tmp);
- 
+ */
 }
 
 uint32 Player::GetMainMeleeDamage(uint32 AP_owerride)
@@ -8879,6 +8971,34 @@
 	pTarget->_setFaction();
 	pTarget->UpdateOppFactionSet();
 
+	if (pTarget->GetTypeId() == TYPEID_UNIT)
+	{
+		if (pTarget->GetAIInterface()->getAITargetsCount())
+		{
+			std::vector<Unit*> targetTable;
+			TargetMap *targets = pTarget->GetAIInterface()->GetAITargets();
+			for (TargetMap::iterator itr = targets->begin(); itr != targets->end(); itr++)
+			{
+				Unit *temp = itr->first;
+				if (temp->GetTypeId() == TYPEID_UNIT && temp->isAlive())
+				{
+					temp->GetAIInterface()->RemoveThreatByPtr(this);
+					if (temp->GetAIInterface()->GetNextTarget() == pTarget)
+						temp->GetAIInterface()->SetNextTarget(NULL);
+					if (pTarget->m_faction == temp->m_faction)
+					{
+						temp->GetAIInterface()->AttackReaction(this, 1, 0);
+						temp->GetAIInterface()->SetNextTarget(this);
+					}
+				}
+			}
+		}
+
+		pTarget->GetAIInterface()->ClearHateList();
+		pTarget->GetAIInterface()->AttackReaction(this, (this->getLevel()*75), 0); // "When the spell ends, the MCed unit (if not a player) will have a large amount of threat on the priest who controlled it" no idea if (lvl*75) is right but it does his job
+		pTarget->GetAIInterface()->SetNextTarget(this);
+	}
+
 	list<uint32> avail_spells;
 	for(list<AI_Spell*>::iterator itr = pTarget->GetAIInterface()->m_spells.begin(); itr != pTarget->GetAIInterface()->m_spells.end(); ++itr)
 	{
@@ -9352,12 +9472,12 @@
 	}
 }
 
-void Player::RemoveSpellTargets(uint32 Type)
+void Player::RemoveSpellTargets(uint32 Type, Unit* target)
 {
 	if( m_spellIndexTypeTargets[Type] != 0 )
 	{
 		Unit* pUnit = m_mapMgr ? m_mapMgr->GetUnit( m_spellIndexTypeTargets[Type] ) : NULL;
-		if( pUnit != NULL )
+		if( pUnit != NULL && target != NULL && pUnit != target )
             pUnit->RemoveAurasByBuffIndexType( Type, GetGUID() );
 
 		m_spellIndexTypeTargets[Type] = 0;
Index: ascent-world/Player.h
===================================================================
--- ascent-world/Player.h	(revision 3944)
+++ ascent-world/Player.h	(working copy)
@@ -309,7 +309,7 @@
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 26
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 27
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 28
-{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 29
+{ 0.0f, 11.792f, 10.12f, 9.19f, 6.024f, 15.405f, 0.0f, 10.82f, 16.85f, 11.47f, 0.0f, 6.11f },// Level 29
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 30
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 31
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 32
@@ -340,7 +340,7 @@
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 57
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 58
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 59
-{ 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 60
+{ 0.0f, 20.0f, 20.07f, 20.0f, 14.5f, 20.0f, 0.0f, 20.0f, 20.0f, 20.0f, 0.0f, 20.0f },// Level 60
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 61
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 62
 { 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f },// Level 63
@@ -565,21 +565,6 @@
 	uint32 forms;
 };
 
-enum SPELL_INDEX
-{
-	SPELL_TYPE_INDEX_MARK			= 1,
-	SPELL_TYPE_INDEX_POLYMORPH		= 2,
-	SPELL_TYPE_INDEX_FEAR			= 3,
-	SPELL_TYPE_INDEX_SAP			= 4,
-	SPELL_TYPE_INDEX_SCARE_BEAST	= 5,
-	SPELL_TYPE_INDEX_HIBERNATE		= 6,
-	SPELL_TYPE_INDEX_EARTH_SHIELD	= 7,
-	SPELL_TYPE_INDEX_CYCLONE		= 8,
-	SPELL_TYPE_INDEX_BANISH			= 9,
-	SPELL_TYPE_INDEX_JUDGEMENT		= 10,
-	NUM_SPELL_TYPE_INDEX			= 11,
-};
-
 #define PLAYER_RATING_MODIFIER_RANGED_SKILL						PLAYER_FIELD_COMBAT_RATING_1
 #define PLAYER_RATING_MODIFIER_DEFENCE							PLAYER_FIELD_COMBAT_RATING_01
 #define PLAYER_RATING_MODIFIER_DODGE							PLAYER_FIELD_COMBAT_RATING_02
@@ -628,6 +613,7 @@
 typedef std::set<Player**>							ReferenceSet;
 
 //#define OPTIMIZED_PLAYER_SAVING
+#define MECHANIC_END 28
 
 class SERVER_DECL Player : public Unit
 {
@@ -684,9 +670,9 @@
 
 	bool ok_to_remove;
 	PlayerInfo * m_playerInfo;
-	uint64 m_spellIndexTypeTargets[NUM_SPELL_TYPE_INDEX];
+	uint64 m_spellIndexTypeTargets[MECHANIC_END];
 	void OnLogin();//custom stuff on player login.
-	void RemoveSpellTargets(uint32 Type);
+	void RemoveSpellTargets(uint32 Type, Unit* target);
 	void RemoveSpellIndexReferences(uint32 Type);
 	void SetSpellTargetType(uint32 Type, Unit* target);
 	void SendMeetingStoneQueue(uint32 DungeonId, uint8 Status);
@@ -807,7 +793,7 @@
     void EventPortToGM(Player *p);
 	ASCENT_INLINE uint32 GetTeam() { return m_team; }
 	ASCENT_INLINE void SetTeam(uint32 t) { m_team = t; m_bgTeam=t; }
-	ASCENT_INLINE void ResetTeam() { m_team = myRace->team_id==7 ? 0 : 1; m_bgTeam=m_team; }
+	ASCENT_INLINE void ResetTeam() { if( myRace == NULL ) return; m_team = myRace->team_id==7 ? 0 : 1; m_bgTeam=m_team; }
 
 	ASCENT_INLINE bool IsInFeralForm()
 	{
@@ -927,8 +913,8 @@
 		return false;
 	}
 	ASCENT_INLINE int          HasBeenInvited() { return m_GroupInviter != 0; }
-	ASCENT_INLINE Group*       GetGroup() { return m_playerInfo->m_Group; }
-	ASCENT_INLINE int8		   GetSubGroup() { return m_playerInfo->subGroup; }
+	ASCENT_INLINE Group*       GetGroup() { return (m_playerInfo != NULL) ? m_playerInfo->m_Group : NULL; }
+	ASCENT_INLINE int8		   GetSubGroup() { return (m_playerInfo != NULL) ? m_playerInfo->subGroup : NULL; }
     bool                IsGroupMember(Player *plyr);
 	ASCENT_INLINE bool         IsBanned()
 	{
@@ -1295,10 +1281,8 @@
 	uint32 ResistanceModPctNeg[7];
 	float m_resist_critical[2];//when we are a victim we can have talents to decrease chance for critical hit. This is a negative value and it's added to critchances
 	float m_resist_hit[3]; // 0 = melee; 1= ranged; 2=spells
-	float SpellDmgDoneByInt[7];
-	float SpellHealDoneByInt[7];
-	float SpellDmgDoneBySpr[7];
-	float SpellHealDoneBySpr[7];
+	float SpellDmgDoneByAttribute[5][7];
+	float SpellHealDoneByAttribute[5][7];
 	uint32 m_modphyscritdmgPCT;
 	uint32 m_RootedCritChanceBonus;
 	uint32 m_ModInterrMRegenPCT;
@@ -1666,6 +1650,7 @@
     void SendEnvironmentalDamageLog(const uint64 & guid, uint8 type, uint32 damage);
     void SendLoginVerifyWorld(uint32 MapId, float x, float y, float z, float o);
     void SendLoginVerifyWorld();
+	void SendWorldStateUpdate(uint32 WorldState, uint32 Value);
     /************************************************************************/
     /* End of SpellPacket wrapper                                           */
     /************************************************************************/
Index: ascent-world/PlayerPacketWrapper.cpp
===================================================================
--- ascent-world/PlayerPacketWrapper.cpp	(revision 3944)
+++ ascent-world/PlayerPacketWrapper.cpp	(working copy)
@@ -110,8 +110,23 @@
     float  O;
 };
 
+struct WorldStateUpdatePacket
+{
+	uint32 State;
+	uint32 Value;
+};
+
 #pragma pack(pop)
 
+void Player::SendWorldStateUpdate(uint32 WorldState, uint32 Value)
+{
+	WorldStateUpdatePacket pck;
+	pck.State = WorldState;
+	pck.Value = Value;
+
+	GetSession()->OutPacket(SMSG_UPDATE_WORLD_STATE, sizeof(WorldStateUpdatePacket), (const char*)&pck);
+}
+
 void Player::Gossip_SendPOI(float X, float Y, uint32 Icon, uint32 Flags, uint32 Data, const char* Name)
 {
 	Gossip_POI_Packet packet;
Index: ascent-world/Professions.cpp
===================================================================
--- ascent-world/Professions.cpp	(revision 3944)
+++ ascent-world/Professions.cpp	(working copy)
@@ -1,209 +0,0 @@
-/*
- * Ascent MMORPG Server
- * Copyright (C) 2005-2007 Ascent Team <http://www.ascentemu.com/>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "StdAfx.h"
-
-uint32 GetGOReqSkill(GameObject * gameObjTarget)  
-{
-	if(gameObjTarget->GetEntry()==180215)return 300;
-	GameObjectInfo*gi= GameObjectNameStorage.LookupEntry(gameObjTarget->GetEntry());
-	if(!gi)
-	{
-		sLog.outError("Unknown go entry=%u",gameObjTarget->GetEntry());
-		return 0;
-	}
-
-	Lock *lock = dbcLock.LookupEntry( gi->SpellFocus );
-	if(!lock) return 0;
-	for(uint32 i=0;i<5;i++)
-		if(lock->locktype[i] == 2 && lock->minlockskill[i])
-		{
-			return lock->minlockskill[i];
-		}
-	return 0;
-}
-
-void AddItemFromDisenchant(ItemPrototype *proto,Player*owner)
-{
-	uint32 count = 0,item = 0;
-	uint32 l=proto->ItemLevel;
-	if(proto->Quality ==4 && l>=51)
-	{
-		count=1;
-		if (l<61) item=20725;
-		else item=22450;
-	}
-	else
-	{
-		if(proto->Quality ==2)//green -> dust for armor, essence for weapon
-		{
-			if(proto->Class==4)//armor->dust
-			{
-				if(l<=20)item=10940;
-				else if(l<=30)item=11083;
-				else if(l<=40)item=11137;
-				else if(l<=50)item=11176;
-				else if(l<=60)item=16204;
-				else item=22445;
-			}
-			else
-			{
-				if(l<=10)item=10938;
-				else if(l<=15)item=10939;
-				else if(l<=20)item=10998;
-				else if(l<=25)item=11082;
-				else if(l<=30)item=11134;
-				else if(l<=35)item=11135;
-				else if(l<=40)item=11174;
-				else if(l<=45)item=11175;
-				else if(l<=50)item=16202;
-				else if(l<=60)item=16203;
-				else if(l<=66) item=22447;
-				else item=22446;
-			
-			}
-			count =1+rand()%3; 
-		}
-		else if(proto->Quality >=3)//blue -> shards
-		{
-				if(l<=20)item=10978;
-				else if(l<=25)item=11084;
-				else if(l<=30)item=11138;
-				else if(l<=35)item=11139;
-				else if(l<=40)item=11177;
-				else if(l<=45)item=11178;
-				else if(l<=50)item=14343;
-				else if(l<=60)item=14344;
-				else if(l<=65)item=22448;
-				else item=22449;
-		
-			count = proto->Quality-2+rand()%3;
-		}
-	}
-	Item *add;
-	SlotResult slotresult;
-	add = owner->GetItemInterface()->FindItemLessMax(item, count, false);
-	if (!add)
-	{
-		slotresult = owner->GetItemInterface()->FindFreeInventorySlot(proto);
-		if(!slotresult.Result)
-		{
-			owner->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
-			return;
-		}
-		Item * it=objmgr.CreateItem(item,owner);  
-		it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
-		owner->GetItemInterface()->SafeAddItem(it,slotresult.ContainerSlot, slotresult.Slot);
-	}
-	else
-	{
-		add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + count);
-		add->m_isDirty = true;
-	}
-}
-
-/*
-Dusts usually are extracted from armors, but also occasionally found from weapons. 
-
-Strange Dust - Disenchanted from level 1 to 20 items [10940]
-Soul Dust - Disenchanted from level 21 to 30 items [11083]
-Vision Dust - Disenchanted from level 31 to 40 items [11137]
-Dream Dust - Disenchanted from level 41 to 50 items [11176]
-Illusion Dust - Disenchanted from level 51 to 60 items [16204]
-
-
-Essences usually are extracted from weapons, but also occasionally found from armors. 
-
-Lesser Magic Essence - Disenchanted from level 1 to 10 items [10938]
-Greater Magic Essence - Disenchanted from level 11 to 15 items [10939]
-Lesser Astral Essence - Disenchanted from level 16 to 20 items [10998]
-Greater Astral Essence - Disenchanted from level 21 to 25 items [11082]
-Lesser Mystic Essence - Disenchanted from level 26 to 30 items [11134]
-Greater Mystic Essence - Disenchanted from level 31 to 35 items [11135]
-Lesser Nether Essence - Disenchanted from level 36 to 40 items [11174]
-Greater Nether Essence - Disenchanted from level 41 to 45 items [11175]
-Lesser Eternal Essence - Disenchanted from level 46 to 50 items [16202]
-Greater Eternal Essence - Disenchanted from level 51 to 60 items [16203]
-
-
-Shards are normally disenchanted from blue or better items, but have a small chance of coming from green items. 
-
-Small Glimmering Shard - Disenchanted from level 1 to 20 items [10978]
-Large Glimmering Shard - Disenchanted from level 21 to 25 items [11084]
-Small Glowing Shard - Disenchanted from level 26 to 30 items [11138]
-Large Glowing Shard - Disenchanted from level 31 to 35 items [11139]
-Small Radiant Shard - Disenchanted from level 36 to 40 items [11177]
-Large Radiant Shard - Disenchanted from level 41 to 45 items [11178]
-Small Brilliant Shard - Disenchanted from level 46 to 50 items [14343]
-Large Brilliant Shard - Disenchanted from level 51 to 60 items [14344]
-
-Nexus Crystals are obtained by disenchanting Epic (purple) items, and sometimes come from Rare (blue) items also. 
-
-Nexus Crystal - Disenchanted from level 51-60 items [20725]
-*/
-
-void AddItemFromProspecting(uint32 loot_id,Player*owner)
-{
-	LootStore::iterator tab =lootmgr.ProspectingLoot.find(loot_id);
-	if( lootmgr.ProspectingLoot.end()==tab)
-		return;
-	StoreLootList *list=&(tab->second);
-
-	for(uint32 x =0,pass=0; x<list->count; x++,pass++)
-	{
-		if(list->items[x].item.itemproto)// this check is needed until loot DB is fixed
-		{
-			if(Rand(list->items[x].chance)) 
-		    {
-				ItemPrototype *itemproto = list->items[x].item.itemproto;
-				if(!itemproto)
-					return;
-				uint32 count = 1;
-				if(list->count != (x - 1))
-				{
-					for(uint32 z = (x + 1); z < list->count; z++)
-						if(itemproto->MaxCount && (count == itemproto->MaxCount))
-							break;
-						else if(list->items[x].item.itemproto == list->items[z].item.itemproto && Rand(list->items[x].chance))
-							count++;
-				}
-				Item *add;
-				SlotResult slotresult;
-				add = owner->GetItemInterface()->FindItemLessMax(list->items[x].item.itemproto->ItemId, count, false);
-				if (!add)
-				{
-					slotresult = owner->GetItemInterface()->FindFreeInventorySlot(itemproto);
-					if(!slotresult.Result)
-					{
-						owner->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
-						return;
-					}
-					Item * it=objmgr.CreateItem(list->items[x].item.itemproto->ItemId,owner);  
-					it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
-					owner->GetItemInterface()->SafeAddItem(it,slotresult.ContainerSlot, slotresult.Slot);
-				}
-				else
-				{
-					add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + count);
-					add->m_isDirty = true;
-				}
-			}
-		}
- 	}
-}
Index: ascent-world/Professions.h
===================================================================
--- ascent-world/Professions.h	(revision 3944)
+++ ascent-world/Professions.h	(working copy)
@@ -1,28 +0,0 @@
-/*
- * Ascent MMORPG Server
- * Copyright (C) 2005-2007 Ascent Team <http://www.ascentemu.com/>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-#ifndef _PROFFESIONS_H
-#define _PROFFESIONS_H
-
-uint32 GetGOReqSkill(GameObject * gameObjTarget);
-void UseFishing(Player *player);
-void AddItemFromDisenchant(ItemPrototype *proto,Player*owner);
-void AddItemFromProspecting(uint32 loot_id,Player*owner);
-
-#endif
Index: ascent-world/ReputationHandler.cpp
===================================================================
--- ascent-world/ReputationHandler.cpp	(revision 3944)
+++ ascent-world/ReputationHandler.cpp	(working copy)
@@ -399,7 +399,7 @@
 			continue;
 
 		pUnit = static_cast< Unit* >( *itr );
-		if( pUnit->m_factionDBC != NULL || pUnit->m_factionDBC->RepListId < 0 )
+		if( pUnit->m_factionDBC != NULL && pUnit->m_factionDBC->RepListId < 0 )
 			continue;
 
 		rep_value = IsHostileBasedOnReputation( pUnit->m_factionDBC );
Index: ascent-world/SocialMgr.cpp
===================================================================
--- ascent-world/SocialMgr.cpp	(revision 3944)
+++ ascent-world/SocialMgr.cpp	(working copy)
@@ -165,9 +165,9 @@
 		plr->GetSession()->SendPacket( &data );
 		return;
 	}
-	if( friendInfo->team != playerInfo->team )
+	if( friendInfo->team != playerInfo->team && sWorld.FriendFactionLimitation )
 	{
-		sLog.outDebug("SocialMgr: %s tried to add an ennemy to his friendlist", plr->GetName());
+		sLog.outDebug("SocialMgr: %s tried to add an enemy to his friendlist", plr->GetName());
 		data << (uint8)FRIEND_ENEMY << (uint64)friendInfo->guid;
 		plr->GetSession()->SendPacket( &data );
 		return;
@@ -179,7 +179,7 @@
 
 	if ( pGuid == fGuid )
 	{
-		sLog.outDebug("SocialMgr: %s tried to add himself to his friendlist", plr->GetName());
+		sLog.outDebug("SocialMgr: %s tried to add himself to his ignorelist", plr->GetName());
 		data << (uint8)FRIEND_SELF << (uint64)fGuid;
 		plr->GetSession()->SendPacket(&data);
 		return;
Index: ascent-world/Spell.cpp
===================================================================
--- ascent-world/Spell.cpp	(revision 3944)
+++ ascent-world/Spell.cpp	(working copy)
@@ -123,7 +123,7 @@
 		    i_caster = NULL;
 		    u_caster = static_cast< Unit* >( Caster );
 		    p_caster = static_cast< Player* >( Caster );
-		    if( p_caster->DuelingWith != NULL )
+		    if( p_caster->GetDuelState() == DUEL_STATE_STARTED )
 			    duelSpell = true;
         }break;
 
@@ -133,7 +133,7 @@
 		    i_caster = NULL;
 		    p_caster = NULL;
 		    u_caster = static_cast< Unit* >( Caster );
-		    if( u_caster->IsPet() && static_cast< Pet* >( u_caster)->GetPetOwner() != NULL && static_cast< Pet* >( u_caster )->GetPetOwner()->DuelingWith != NULL )
+		    if( u_caster->IsPet() && static_cast< Pet* >( u_caster)->GetPetOwner() != NULL && static_cast< Pet* >( u_caster )->GetPetOwner()->GetDuelState() == DUEL_STATE_STARTED )
 			    duelSpell = true;
         }break;
 
@@ -271,9 +271,10 @@
                 {
 					did_hit_result = DidHit(i, static_cast< Unit* >( *itr ) );
 					if( did_hit_result != SPELL_DID_HIT_SUCCESS )
-						ModeratedTargets.push_back(SpellTargetMod((*itr)->GetGUID(), did_hit_result));
+						SafeAddModeratedTarget((*itr)->GetGUID(), did_hit_result);
 					else
-						tmpMap->push_back((*itr)->GetGUID());
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
+						//tmpMap->push_back((*itr)->GetGUID());
                 }
 
             }
@@ -283,10 +284,12 @@
                 {
                     //trap, check not to attack owner and friendly
                     if(isAttackable(g_caster->m_summoner,(Unit*)(*itr),!(m_spellInfo->c_is_flags & SPELL_FLAG_IS_TARGETINGSTEALTHED)))
-                        tmpMap->push_back((*itr)->GetGUID());
+                        //tmpMap->push_back((*itr)->GetGUID());
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
                 }
                 else
-                    tmpMap->push_back((*itr)->GetGUID());
+					SafeAddTarget(tmpMap,(*itr)->GetGUID());
+                    //tmpMap->push_back((*itr)->GetGUID());
             }
             if( m_spellInfo->MaxTargets)
             {
@@ -333,9 +336,10 @@
 				{
 					did_hit_result = DidHit(i, static_cast< Unit* >( *itr ) );
 					if( did_hit_result == SPELL_DID_HIT_SUCCESS )
-						tmpMap->push_back( (*itr)->GetGUID() );
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
+						//tmpMap->push_back( (*itr)->GetGUID() );
 					else
-						ModeratedTargets.push_back( SpellTargetMod( (*itr)->GetGUID(), did_hit_result ) );
+						SafeAddModeratedTarget((*itr)->GetGUID(), did_hit_result );
 				}
 			}
 			else //cast from GO
@@ -344,10 +348,12 @@
 				{
 					//trap, check not to attack owner and friendly
 					if( isAttackable( g_caster->m_summoner, static_cast< Unit* >( *itr ), !(m_spellInfo->c_is_flags & SPELL_FLAG_IS_TARGETINGSTEALTHED) ) )
-						tmpMap->push_back( (*itr)->GetGUID() );
+						//tmpMap->push_back( (*itr)->GetGUID() );
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
 				}
 				else
-					tmpMap->push_back( (*itr)->GetGUID() );
+					//tmpMap->push_back( (*itr)->GetGUID() );
+					SafeAddTarget(tmpMap,(*itr)->GetGUID());
 			}			
 			if( m_spellInfo->MaxTargets )
 				if( m_spellInfo->MaxTargets == tmpMap->size() )
@@ -384,9 +390,10 @@
 				{
 					did_hit_result = DidHit(i, static_cast< Unit* >( *itr ) );
 					if( did_hit_result == SPELL_DID_HIT_SUCCESS )
-						tmpMap->push_back( (*itr)->GetGUID() );
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
+						//tmpMap->push_back( (*itr)->GetGUID() );
 					else
-						ModeratedTargets.push_back( SpellTargetMod( (*itr)->GetGUID(), did_hit_result ) );
+						SafeAddModeratedTarget((*itr)->GetGUID(), did_hit_result );
 				}
 			}
 			else //cast from GO
@@ -395,10 +402,12 @@
 				{
 					//trap, check not to attack owner and friendly
 					if( isFriendly( g_caster->m_summoner, static_cast< Unit* >( *itr ) ) )
-						tmpMap->push_back( (*itr)->GetGUID() );
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
+						//tmpMap->push_back( (*itr)->GetGUID() );
 				}
 				else
-					tmpMap->push_back( (*itr)->GetGUID() );
+					SafeAddTarget(tmpMap,(*itr)->GetGUID());
+					//tmpMap->push_back( (*itr)->GetGUID() );
 			}			
 			if( m_spellInfo->MaxTargets )
 				if( m_spellInfo->MaxTargets == tmpMap->size() )
@@ -517,12 +526,29 @@
 	if( u_victim == NULL )
 		return SPELL_DID_HIT_MISS;
 	
+	//multiple effects from same same spell cannot be resisted separately
+	for(SpellTargetsList::iterator itr = ModeratedTargets.begin(); itr != ModeratedTargets.end(); ++itr)
+	{
+		if( (*itr).TargetGuid == u_victim->GetGUID() )
+			return (*itr).TargetModType;
+	}
+
+	/*
+	for(std::vector< uint64 >::iterator trg = m_targetUnits[effindex].begin(); trg != m_targetUnits[effindex].end(); trg++)
+	{
+		if( (*trg) == u_victim->GetGUID() )
+			return SPELL_DID_HIT_SUCCESS;
+			//m_targetUnits[effindex].erase( m_targetUnits[effindex].begin() + k );
+	}
+	*/
+
 	/************************************************************************/
-	/* Elite mobs always hit                                                */
+	/* Elite mobs always hit - mooo?                                        */
 	/************************************************************************/
+	/*
 	if( u_caster != NULL && u_caster->GetTypeId() == TYPEID_UNIT && static_cast< Creature* >( u_caster )->GetCreatureName() && static_cast< Creature* >( u_caster )->GetCreatureName()->Rank >= 3 )
 		return SPELL_DID_HIT_SUCCESS;
-
+	*/
 	/************************************************************************/
 	/* Can't resist non-unit                                                */
 	/************************************************************************/
@@ -557,42 +583,47 @@
 	
 	/**** HACK FIX: AoE Snare/Root spells (i.e. Frost Nova) ****/
 	/* If you find any other AoE effects that also apply something that SHOULD be a mechanic, add it here. */
-	if( u_victim->MechanicsDispels[MECHANIC_ROOTED] ||
-		u_victim->MechanicsDispels[MECHANIC_ENSNARED]
-		)
+	if( u_victim->MechanicsDispels[MECHANIC_ROOTED] || u_victim->MechanicsDispels[MECHANIC_ENSNARED] )
 	{
-	for( int i = 1 ; i <= 3 ; i ++ )
+		for( int i = 1 ; i <= 3 ; i ++ )
 		{
 			if( u_victim->MechanicsDispels[MECHANIC_ROOTED] && m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT )
 				return SPELL_DID_HIT_IMMUNE;
 			if( u_victim->MechanicsDispels[MECHANIC_ENSNARED] && m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED )
 				return SPELL_DID_HIT_IMMUNE;
 		}
-
 	}
 
 	/************************************************************************/
-	/* Check if the target has a % resistance to this mechanic              */
-	/************************************************************************/
-		/* Never mind, it's already done below. Lucky I didn't go through with this, or players would get double resistance. */
-
-	/************************************************************************/
 	/* Check if the spell is a melee attack and if it was missed/parried    */
 	/************************************************************************/
-	uint32 melee_test_result;
-	if( m_spellInfo->is_melee_spell)
+	if( m_spellInfo->is_melee_spell || m_spellInfo->is_ranged_spell )
 	{
-		melee_test_result = u_caster->GetSpellDidHitResult( u_victim, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo );
-		if(melee_test_result != SPELL_DID_HIT_SUCCESS)
-			return (uint8)melee_test_result;
+		uint32 _type = MELEE;
+		if( GetType() == SPELL_DMG_TYPE_RANGED )
+			_type = RANGED;
+		else
+		{
+			if (m_spellInfo->Flags4 & 0x1000000)
+				_type = OFFHAND;
+			else
+				_type = MELEE;
+		}
+
+		return uint8( u_caster->GetSpellDidHitResult( u_victim, _type, m_spellInfo ) );
 	}
 
+	/* this is wrong, if we got here with spell which is SCHOOL_NORMAL most chances it is stun
+	if( m_spellInfo->School == SCHOOL_NORMAL )
+		return SPELL_DID_HIT_SUCCESS;
+	*/
+
+	if( m_spellInfo->MechanicsType == MECHANIC_DISORIENTED ) // hope its right
+		return SPELL_DID_HIT_SUCCESS;
+	
 	/************************************************************************/
 	/* Check if the spell is resisted.                                      */
 	/************************************************************************/
-	if( m_spellInfo->School==0)
-		return SPELL_DID_HIT_SUCCESS;
-
 	bool pvp =(p_caster && p_victim);
 
 	if(pvp)
@@ -617,23 +648,24 @@
 				resistchance = baseresist[2] + (((float)lvldiff-2.0f)*11.0f);
 		}
 	}
+
 	//check mechanical resistance
-	//i have no idea what is the best pace for this code
-	if( m_spellInfo->MechanicsType<27)
+	if( m_spellInfo->MechanicsType && m_spellInfo->MechanicsType < 27 )
 	{
 		if(p_victim)
 			resistchance += p_victim->MechanicsResistancesPCT[m_spellInfo->MechanicsType];
 		else 
 			resistchance += u_victim->MechanicsResistancesPCT[m_spellInfo->MechanicsType];
 	}
+
 	//rating bonus
-	if( p_caster != NULL )
+	if( p_caster != NULL && m_spellInfo->School != SCHOOL_NORMAL )
 	{
 		resistchance -= p_caster->CalcRating( PLAYER_RATING_MODIFIER_SPELL_HIT );
 		resistchance -= p_caster->GetHitFromSpell();
 	}
 
-	if(p_victim)
+	if( p_victim && m_spellInfo->School != SCHOOL_NORMAL )
 		resistchance += p_victim->m_resist_hit[2];
 
 	if( this->m_spellInfo->Effect[effindex] == SPELL_EFFECT_DISPEL && m_spellInfo->SpellGroupType && u_caster)
@@ -663,22 +695,24 @@
 #endif
 	}
 
+	uint32 res;
+
 	if(resistchance >= 100.0f)
-		return SPELL_DID_HIT_RESIST;
+		res = SPELL_DID_HIT_RESIST;
 	else
 	{
-		uint32 res;
 		if(resistchance<=1.0)//resist chance >=1
-			res =  (Rand(1.0f) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
+			res =  ( Rand(1.0f) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
 		else
-			res =  (Rand(resistchance) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
+			res =  ( Rand(resistchance) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
+	}
+	
+	if (res == SPELL_DID_HIT_SUCCESS)
+	{
+		target->HandleProc(PROC_ON_SPELL_LAND_VICTIM,this->u_caster,this->m_spellInfo);
+	}
 
-		if (res == SPELL_DID_HIT_SUCCESS) // proc handling. mb should be moved outside this function
-			target->HandleProc(PROC_ON_SPELL_LAND_VICTIM,this->u_caster,this->m_spellInfo);
-
-		return res;
-	}
- 
+	return res;
 }
 //generate possible target list for a spell. Use as last resort since it is not acurate
 //this function makes a rough estimation for possible target !
@@ -944,7 +978,11 @@
 		m_castTime = 0;
 	else
 	{
-		m_castTime = GetCastTime( dbcSpellCastTime.LookupEntry( m_spellInfo->CastingTimeIndex ) );
+		SpellCastTime *time = dbcSpellCastTime.LookupEntry( m_spellInfo->CastingTimeIndex );
+		if ( time == NULL )
+			m_castTime = 0;
+		else
+			m_castTime = GetCastTime( time );
 
 		if( m_castTime && m_spellInfo->SpellGroupType && u_caster != NULL )
 		{
@@ -1280,18 +1318,19 @@
 				p_caster->setAttackTimer( 0, true );
 				p_caster->setAttackTimer( 0, false );
 			}
-			if( p_caster->IsStealth() && !(m_spellInfo->AttributesEx & ATTRIBUTESEX_DELAY_SOME_TRIGGERS ) )
+			else if( m_spellInfo->NameHash == SPELL_HASH_VICTORY_RUSH )
 			{
+				p_caster->RemoveFlag(UNIT_FIELD_AURASTATE,AURASTATE_FLAG_LASTKILLWITHHONOR);
+			}
+
+			if( p_caster->IsStealth() && !(m_spellInfo->AttributesEx & ATTRIBUTESEX_NOT_BREAK_STEALTH) )
+			{
 				/* talents procing - don't remove stealth either */
-				if( m_spellInfo->Attributes & 64 || ( pSpellId && dbcSpell.LookupEntry(pSpellId)->Attributes & 64 ) )
+				if (!(m_spellInfo->Attributes & ATTRIBUTES_PASSIVE) && 
+					!( pSpellId && dbcSpell.LookupEntry(pSpellId)->Attributes & ATTRIBUTES_PASSIVE ) )
 				{
-
-				}
-				else
-				{
-					uint32 stealthid = p_caster->m_stealth;
+					p_caster->RemoveAura(p_caster->m_stealth);
 					p_caster->m_stealth = 0;
-					p_caster->RemoveAura(stealthid);
 				}
 			}
 		}
@@ -1890,8 +1929,6 @@
 
 void Spell::SendSpellGo()
 {
-    
-
 	// Fill UniqueTargets
 	TargetsList::iterator i, j;
 	for( uint32 x = 0; x < 3; x++ )
@@ -2235,6 +2272,13 @@
 		cost +=float2int32(cost*u_caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+m_spellInfo->School));
 	}
 
+	if (p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_SHIV && p_caster->GetItemInterface()) //hackfix for shiv's energy cost
+	{
+		Item *it = p_caster->GetItemInterface()->GetInventoryItem( EQUIPMENT_SLOT_OFFHAND );
+		if( it != NULL )
+			cost += (uint32)(10* (it->GetProto()->Delay / 1000.0f));
+	}
+
 	//apply modifiers
 	if( m_spellInfo->SpellGroupType && u_caster)
 	{
@@ -2333,6 +2377,13 @@
 		cost +=float2int32(cost*u_caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+m_spellInfo->School));
 	}
 
+	if (p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_SHIV && p_caster->GetItemInterface()) //hackfix for shiv's energy cost
+	{
+		Item *it = p_caster->GetItemInterface()->GetInventoryItem( EQUIPMENT_SLOT_OFFHAND );
+		if( it != NULL )
+			cost += (uint32)(10* (it->GetProto()->Delay / 1000.0f));
+	}
+
 	//apply modifiers
 	if( m_spellInfo->SpellGroupType && u_caster)
 	{
@@ -2511,7 +2562,7 @@
 				Aura* aur = NULL;
 				for( int i = 0;i < itr->second->GetSpellProto()->procCharges - 1; i++ )
 				{
-					aur = new Aura( itr->second->GetSpellProto(), itr->second->GetDuration(), itr->second->GetCaster(), itr->second->GetTarget() );
+					aur = new Aura( itr->second->GetSpellProto(), itr->second->GetDuration(), itr->second->GetCaster(), itr->second->GetTarget(), i_caster  );
 					Target->AddAura( aur );
 					aur = NULL;
 				}
@@ -2645,6 +2696,7 @@
 			}
 		}
 
+		/*
 		// check for duel areas
 		if( m_spellInfo->Id == 7266)
 		{
@@ -2652,7 +2704,7 @@
 			if( at->AreaFlags & AREA_CITY_AREA )
 				return SPELL_FAILED_NO_DUELING;
 		}
-
+		*/
 		// check if spell is allowed while player is on a taxi
 		if( p_caster->m_onTaxi )
 		{
@@ -2907,10 +2959,6 @@
 			case SPELL_EFFECT_ENCHANT_ITEM:
 			case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
 			{
-				// check for enchants that can only be done on your own items, make sure they are soulbound
-				if( m_spellInfo->Flags3 & FLAGS3_ENCHANT_OWN_ONLY && !(i_target->IsSoulbound()))
-					return SPELL_FAILED_BAD_TARGETS;
-
 				// check if we have the correct class, subclass, and inventory type of target item
 				if( m_spellInfo->EquippedItemClass != proto->Class)
 					return SPELL_FAILED_BAD_TARGETS;
@@ -2986,6 +3034,10 @@
 		}
 	}
 
+	//are we in an arena and the spell cooldown is longer then 15mins?
+	if ( p_caster != NULL && p_caster->m_bg != NULL && ( p_caster->m_bg->GetType() >= BATTLEGROUND_ARENA_2V2 && p_caster->m_bg->GetType() <= BATTLEGROUND_ARENA_5V5 ) && ( m_spellInfo->RecoveryTime >= 900000 || m_spellInfo->CategoryRecoveryTime >= 900000 ) )
+		return SPELL_FAILED_SPELL_UNAVAILABLE;
+
 	// backstab/ambush
 	if( p_caster != NULL && ( m_spellInfo->NameHash == SPELL_HASH_BACKSTAB || m_spellInfo->NameHash == SPELL_HASH_AMBUSH ) )
 	{
@@ -3390,7 +3442,7 @@
 						break;
 
 						{
-							if( u_caster->m_special_state & ( UNIT_STATE_FEAR | UNIT_STATE_CHARM | UNIT_STATE_SLEEP | UNIT_STATE_ROOT | UNIT_STATE_STUN | UNIT_STATE_CONFUSE | UNIT_STATE_SNARE ) )
+							if( u_caster->m_special_state & ( UNIT_STATE_FEAR | UNIT_STATE_CHARM | UNIT_STATE_SLEEP | UNIT_STATE_ROOT | UNIT_STATE_STUN | UNIT_STATE_CONFUSE | UNIT_STATE_SNARE | UNIT_STATE_SILENCE ) )
 								break;
 						}
 							break;
@@ -3408,8 +3460,19 @@
 		}
 
 		if( u_caster->m_silenced && m_spellInfo->School != NORMAL_DAMAGE )// can only silence non-physical
-			return SPELL_FAILED_SILENCED;
+		{
+			// HACK FIX
+			switch( m_spellInfo->NameHash )
+			{
+				case SPELL_HASH_ICE_BLOCK: //Ice Block
+				case 0x9840A1A6: //Divine Shield
+						break;
 
+				default:
+					return SPELL_FAILED_SILENCED;
+			}
+		}
+
 		if( target != NULL ) /* -Supalosa- Shouldn't this be handled on Spell Apply? */
 		{
 			for( int i = 0; i < 3; i++ ) // if is going to cast a spell that breaks stun remove stun auras, looks a bit hacky but is the best way i can find
@@ -3439,6 +3502,8 @@
 			{
 				case SPELL_HASH_ICE_BLOCK: //Ice Block
 				case 0x9840A1A6: //Divine Shield
+						break;
+
 				case 0x3DFA70E5: //Will of the Forsaken
 				{
 					if( u_caster->m_special_state & (UNIT_STATE_FEAR | UNIT_STATE_CHARM | UNIT_STATE_SLEEP))
@@ -4017,32 +4082,39 @@
 	float healdoneaffectperc = 0;
 	if( u_caster != NULL )
 	{
-		SpellCastTime *sd = dbcSpellCastTime.LookupEntry(m_spellInfo->CastingTimeIndex);
-
-		// affect the plus damage by duration
-		float castaff = float(GetCastTime(sd));
-		if(castaff > 3500) 
-            castaff = 3500;
-		else if(castaff < 1500) 
-            castaff = 1500;
-
-		healdoneaffectperc = castaff / 3500.0f;
+		if(!m_spellInfo->dmg_bonus)
+		{
+			SpellCastTime *sd = dbcSpellCastTime.LookupEntry(m_spellInfo->CastingTimeIndex);
+			// affect the plus damage by duration
+			float castaff = float(GetCastTime(sd));
+			if(castaff > 3500) 
+				castaff = 3500;
+			else if(castaff < 1500) 
+				castaff = 1500;
+ 
+			healdoneaffectperc = castaff / 3500.0f;
+		}
+		else
+		{
+			healdoneaffectperc = m_spellInfo->dmg_bonus/100.0f;
+		}
 		
 		//Downranking
-		/*if( m_spellInfo->baseLevel > 0 && m_spellInfo->maxLevel > 0 && p_caster)
+		if( u_caster->IsPlayer() && m_spellInfo->baseLevel > 0 && m_spellInfo->maxLevel > 0 )
 		{
 			float downrank1 = 1.0f;
-			if (m_spellInfo->baseLevel < 20)
-				downrank1 = 1.0f - (20.0f - float (m_spellInfo->baseLevel) ) * 0.0375f;
+			if( m_spellInfo->baseLevel < 20 )
+				downrank1 = 1.0f - ( 20.0f - float( m_spellInfo->baseLevel ) ) * 0.0375f;
+
 			float downrank2 = ( float(m_spellInfo->maxLevel + 5.0f) / float(p_caster->getLevel()) );
-			if (downrank2 >= 1 || downrank2 < 0)
+			if( downrank2 >= 1 || downrank2 < 0 )
 				downrank2 = 1.0f;
-			healdoneaffectperc *= downrank1 * downrank2;
-		}*/
 
-		//caster sided bonus
-		bonus += u_caster->HealDoneMod[m_spellInfo->School] + (amount*u_caster->HealDonePctMod[m_spellInfo->School])/100;
+			healdoneaffectperc *= downrank1*downrank2;
+		}
 
+		bonus += u_caster->HealDoneMod[m_spellInfo->School];
+
 		if(m_spellInfo->SpellGroupType)
 		{
 			int penalty_pct = 0;
@@ -4060,12 +4132,16 @@
 				printf("!!!!!HEAL : spell dmg bonus(p=24) mod flat %d , spell dmg bonus(p=24) pct %d , spell dmg bonus %d, spell group %u\n",spell_flat_modifers,spell_pct_modifers,bonus,m_spellInfo->SpellGroupType);
 #endif
 		}
-//		amount += float2int32(u_caster->HealDoneMod[m_spellInfo->School] * healdoneaffectperc);
-//		amount += (amount*u_caster->HealDonePctMod[m_spellInfo->School])/100;
-		bonus += unitTarget->HealTakenMod[m_spellInfo->School];//amt of health that u RECIVE, not heal
-		bonus += float2int32(unitTarget->HealTakenPctMod[m_spellInfo->School]*amount);
 
+		bonus += unitTarget->HealTakenMod[m_spellInfo->School];
 
+		if (p_caster)
+		{
+			for(uint32 a = 0; a < 6; a++)
+				bonus += float2int32(p_caster->SpellHealDoneByAttribute[a][m_spellInfo->School] * p_caster->GetUInt32Value(UNIT_FIELD_STAT0 + a));
+		}
+ 
+		amount += float2int32( float( bonus ) * healdoneaffectperc );
 
 		float spellCrit = u_caster->spellcritperc + u_caster->SpellCritChanceSchool[m_spellInfo->School];
         SM_FFValue(u_caster->SM_CriticalChance, &spellCrit, m_spellInfo->SpellGroupType);
@@ -4082,10 +4158,6 @@
 			if( m_spellInfo->SpellGroupType )
 				SM_PIValue( static_cast< Unit* >( u_caster )->SM_PCriticalDamage, &critbonus, m_spellInfo->SpellGroupType );
 			amount += critbonus;
-			//Shady: does it correct> caster casts heal and proc ..._VICTIM ? 
-			// Or mb i'm completely wrong? So if true  - just replace with old string. 
-			//u_caster->HandleProc(PROC_ON_SPELL_CRIT_HIT_VICTIM, unitTarget, m_spellInfo, amount);
-			//Replaced with following one:
 			
 			unitTarget->HandleProc( PROC_ON_SPELL_CRIT_HIT_VICTIM, u_caster, m_spellInfo, amount );
 			u_caster->HandleProc( PROC_ON_SPELL_CRIT_HIT, unitTarget, m_spellInfo, amount );
@@ -4093,14 +4165,8 @@
 		
 	}
 
-	if( p_caster != NULL )  
-	{
-		bonus += float2int32( p_caster->SpellHealDoneByInt[m_spellInfo->School] * p_caster->GetUInt32Value( UNIT_FIELD_STAT3 ) );
-		bonus += float2int32( p_caster->SpellHealDoneBySpr[m_spellInfo->School] * p_caster->GetUInt32Value( UNIT_FIELD_STAT4 ) );
-	}
+	amount += float2int32(( u_caster->HealDonePctMod[m_spellInfo->School]/100.0f + unitTarget->HealTakenPctMod[m_spellInfo->School])*amount);
 
-	amount += float2int32( float( bonus ) * healdoneaffectperc ); //apply downranking on final value ?
-
 	if( amount < 0 ) 
 		amount = 0;
 
@@ -4225,20 +4291,6 @@
 	tgt->push_back(guid);
 }
 
-void Spell::SafeAddMissedTarget(uint64 guid)
-{
-    for(SpellTargetsList::iterator i=ModeratedTargets.begin();i!=ModeratedTargets.end();i++)
-        if((*i).TargetGuid==guid)
-        {
-            //sLog.outDebug("[SPELL] Something goes wrong in spell target system");
-			// this isnt actually wrong, since we only have one missed target map,
-			// whereas hit targets have multiple maps per effect.
-            return;
-        }
-
-    ModeratedTargets.push_back(SpellTargetMod(guid,2));
-}
-
 void Spell::SafeAddModeratedTarget(uint64 guid, uint16 type)
 {
 	for(SpellTargetsList::iterator i=ModeratedTargets.begin();i!=ModeratedTargets.end();i++)
@@ -4383,63 +4435,51 @@
 	{
 	case SPELL_HASH_SAP:					// Sap
 	case SPELL_HASH_GOUGE:					// Gouge
+	case SPELL_HASH_REPENTANCE:			// Repentance
+	case SPELL_HASH_MAIM:
 		{
 			grp = 0;
 		}break;
 
+	case SPELL_HASH_POUNCE:
 	case SPELL_HASH_CHEAP_SHOT:				// Cheap Shot
+	case SPELL_HASH_KIDNEY_SHOT:			// Kidney Shot
+	case SPELL_HASH_HAMMER_OF_JUSTICE:		// Hammer of Justice
+	case SPELL_HASH_CHARGE:					// Charge
+	case SPELL_HASH_INTERCEPT :				// Intercept
+	case SPELL_HASH_CONCUSSION_BLOW:		// Concussion Blow
+	case SPELL_HASH_CELESTIAL_FOCUS:		// Celestial Focus
+	case SPELL_HASH_IMPACT:					// Impact
+	case SPELL_HASH_BLACKOUT:				// Blackout
+	case SPELL_HASH_SHADOWFURY:				// Shadowfury
 		{
 			grp = 1;
 			pve = true;
 		}break;
 
-	case SPELL_HASH_KIDNEY_SHOT:			// Kidney Shot
-		{
-			grp = 2;
-			pve = true;
-		}break;
-
+	case SPELL_HASH_STUN:					// Stuns (all of them)
 	case SPELL_HASH_BASH:					// Bash
 		{
-			grp = 3;
+			grp = 1;
 		}break;
 
+	case SPELL_HASH_FROST_NOVA:				// Frost Nova
+	case SPELL_HASH_FROSTBITE:				// Frostbite
 	case SPELL_HASH_ENTANGLING_ROOTS:		// Entangling Roots
 		{
 			grp = 4;
 		}break;
 
-	case SPELL_HASH_HAMMER_OF_JUSTICE:		// Hammer of Justice
-		{
-			grp = 5;
-			pve = true;
-		}break;
-
-	case SPELL_HASH_STUN:					// Stuns (all of them)
-		{
-			grp = 6;
-		}break;
-
-	case SPELL_HASH_CHARGE:					// Charge
-	case SPELL_HASH_INTERCEPT :				// Intercept
-	case SPELL_HASH_CONCUSSION_BLOW:		// Concussion Blow
-		{
-			grp = 7;
-			pve = true;
-		}break;
-
+	case SPELL_HASH_SEDUCTION:				// Seduction
 	case SPELL_HASH_FEAR:					// Fear
-	case SPELL_HASH_SEDUCTION:				// Seduction
 	case SPELL_HASH_HOWL_OF_TERROR:			// Howl of Terror
+	case SPELL_HASH_DEATH_COIL:			// Death Coil
+	case SPELL_HASH_PSYCHIC_SCREAM:			// Psychic Scream
+	case SPELL_HASH_SCARE_BEAST:			// Scare Beast
 		{
 			grp = 8;
 		}break;
 
-	case SPELL_HASH_FROST_NOVA:				// Frost Nova
-		{
-			grp = 9;
-		}break;
-
 	case SPELL_HASH_POLYMORPH:				// Polymorph
 	case SPELL_HASH_POLYMORPH__CHICKEN:		// Chicken
 	case SPELL_HASH_POLYMORPH__PIG:			// Pig
@@ -4447,24 +4487,20 @@
 	case SPELL_HASH_POLYMORPH__SHEEP:		// Good ol' sheep
 		{
 			grp = 10;
-			pve = true;   
 		}break;
 
-	case SPELL_HASH_PSYCHIC_SCREAM:			// Psychic Scream
+	case SPELL_HASH_BLIND:		// Blind
 		{
 			grp = 11;
+			pve = true;   
 		}break;
 
+	case SPELL_HASH_ENSLAVE_DEMON:			// Enslave Demon
 	case SPELL_HASH_MIND_CONTROL:			// Mind Control
 		{
 			grp = 12;
 		}break;
 
-	//With Patch 2.3, Frost Shock no longer suffers from diminishing returns. Prior to that it suffered from Diminishing Returns, which rendered each application of the snare weaker and weaker until the third use, at which point the target was immune for 15 seconds.
-	//case SPELL_HASH_FROST_SHOCK:			// Frost Shock
-	//	grp = 13;
-	//	break;
-
 	case SPELL_HASH_HIBERNATE:				// Hibernate
 		{
 			grp = 14;
@@ -4476,24 +4512,6 @@
 			pve = true;
 		}break;
 
-	case SPELL_HASH_CELESTIAL_FOCUS:		// Celestial Focus
-		{
-			grp = 16;
-			pve = true;
-		}break;
-
-	case SPELL_HASH_IMPACT:					// Impact
-		{
-			grp = 17;
-			pve = true;
-		}break;
-
-	case SPELL_HASH_BLACKOUT:				// Blackout
-		{
-			grp = 18;
-			pve = true;
-		}break;
-
 	case SPELL_HASH_BANISH:					// Banish
 		{
 			grp = 19;
@@ -4504,16 +4522,6 @@
 			grp = 20;
 		}break;
 
-	case SPELL_HASH_SCARE_BEAST:			// Scare Beast
-		{
-			grp = 21;
-		}break;
-
-	case SPELL_HASH_ENSLAVE_DEMON:			// Enslave Demon
-		{
-			grp = 22;
-		}break;
-
 	}
 	uint32 ret;
 	if( pve )
Index: ascent-world/Spell.h
===================================================================
--- ascent-world/Spell.h	(revision 3944)
+++ ascent-world/Spell.h	(working copy)
@@ -369,7 +369,7 @@
     ATTRIBUTESEX_UNK4                         = 0x4,
     ATTRIBUTESEX_UNK5                         = 0x8,
     ATTRIBUTESEX_UNK6                         = 0x10,
-    ATTRIBUTESEX_DELAY_SOME_TRIGGERS          = 0x20,
+    ATTRIBUTESEX_NOT_BREAK_STEALTH			  = 0x20,
     ATTRIBUTESEX_UNK8                         = 0x40,
     ATTRIBUTESEX_UNK9                         = 0x80,
     ATTRIBUTESEX_UNK10                        = 0x100,
@@ -402,7 +402,7 @@
     FLAGS3_NULL               = 0x0,
     FLAGS3_UNK2               = 0x1,
     FLAGS3_UNK3               = 0x2,    // Can be used while stealthed
-    FLAGS3_UNK4               = 0x4,    // request pet maybe
+    FLAGS3_CANNOT_CRIT        = 0x4,    // cannot crit
     FLAGS3_UNK5               = 0x8,    // something todo with temp enchanted items
     FLAGS3_PARTY_EFFECTING_AURA = 0x10, // Party affecting aura's
     FLAGS3_ACTIVATE_AUTO_SHOT = 0x20,   // spell that enable's auto shoot
@@ -705,7 +705,7 @@
     SPELL_ENTRY_Flags3,
     SPELL_ENTRY_field10,
     SPELL_ENTRY_field11,
-    SPELL_ENTRY_unk201_1,
+    SPELL_ENTRY_FlagsTargets,
     SPELL_ENTRY_RequiredShapeShift,
     SPELL_ENTRY_UNK14,
     SPELL_ENTRY_Targets,
@@ -972,6 +972,7 @@
     SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER	= 0x00000200, //we should cast these on owner too
     SPELL_FLAG_IS_EXPIREING_WITH_PET	= 0x00000400, //when pet dies, we remove this too
     SPELL_FLAG_IS_EXPIREING_ON_PET		= 0x00000800, //when pet is summoned
+	SPELL_FLAG_IS_JUDGEMENT				= 0x00001000,
 };
 
 ASCENT_INLINE bool CanAgroHash(uint32 spellhashname)
@@ -1923,7 +1924,6 @@
     TargetsList m_targetUnits[3];
     void SafeAddTarget(TargetsList* tgt,uint64 guid);
     
-    void SafeAddMissedTarget(uint64 guid);
     void SafeAddModeratedTarget(uint64 guid, uint16 type);
 
     friend class DynamicObject;
Index: ascent-world/SpellAuras.cpp
===================================================================
--- ascent-world/SpellAuras.cpp	(revision 3944)
+++ ascent-world/SpellAuras.cpp	(working copy)
@@ -194,8 +194,8 @@
 		&Aura::SpellAuraIncreasePartySpeed,//missing = 171
 		&Aura::SpellAuraIncreaseMovementAndMountedSpeed,//missing = 172 //used //Apply Aura: Increase Movement and Mounted Speed (Non-Stacking) //http://www.thottbot.com/?sp=26022 2e effect
 		&Aura::SpellAuraNULL,//missing = 173 // Apply Aura: Allow Champion Spells
-		&Aura::SpellAuraIncreaseSpellDamageBySpr,//missing = 174 //used //Apply Aura: Increase Spell Damage by % Spirit (Spells) //http://www.thottbot.com/?sp=15031
-		&Aura::SpellAuraIncreaseHealingBySpr,//missing = 175 //used //Apply Aura: Increase Spell Healing by % Spirit //http://www.thottbot.com/?sp=15031
+		&Aura::SpellAuraIncreaseSpellDamageByAttribute,//missing = 174 //used //Apply Aura: Increase Spell Damage by % Spirit (Spells) //http://www.thottbot.com/?sp=15031
+		&Aura::SpellAuraIncreaseHealingByAttribute,//missing = 175 //used //Apply Aura: Increase Spell Healing by % Spirit //http://www.thottbot.com/?sp=15031
 		&Aura::SpellAuraSpiritOfRedemption,//missing = 176 //used // Apply Aura: Spirit of Redemption
 		&Aura::SpellAuraNULL,//missing = 177 //used //Apply Aura: Area Charm // http://www.thottbot.com/?sp=26740
 		&Aura::SpellAuraNULL,//missing = 178 //Apply Aura: Increase Debuff Resistance 
@@ -214,8 +214,8 @@
 		&Aura::SpellAuraLimitSpeed,//missing = 191 //used // noname //http://www.thottbot.com/?sp=29894
 		&Aura::SpellAuraNULL,//192 Apply Aura: Melee Slow %
 		&Aura::SpellAuraIncreaseTimeBetweenAttacksPCT,//193 Apply Aura: Increase Time Between Attacks (Melee, Ranged and Spell) by %
-		&Aura::SpellAuraIncreaseSpellDamageByInt,//194 Apply Aura: Increase Spell Damage by % of Intellect (All)
-		&Aura::SpellAuraIncreaseHealingByInt,//195 Apply Aura: Increase Healing by % of Intellect
+		&Aura::SpellAuraNULL,//194 //&Aura::SpellAuraIncreaseSpellDamageByInt,//194 Apply Aura: Increase Spell Damage by % of Intellect (All)
+		&Aura::SpellAuraNULL,//195 //&Aura::SpellAuraIncreaseHealingByInt,//195 Apply Aura: Increase Healing by % of Intellect
 		&Aura::SpellAuraNULL,//196 Apply Aura: Mod All Weapon Skills (6)
 		&Aura::SpellAuraModAttackerCritChance,//197 Apply Aura: Reduce Attacker Critical Hit Chance by %
 		&Aura::SpellAuraIncreaseAllWeaponSkill,//198
@@ -257,10 +257,10 @@
         &Aura::SpellAuraNULL,//234 Apply Aura: Reduces Silence or Interrupt effects, Item spell magic http://www.thottbot.com/s42184
 		&Aura::SpellAuraNULL,//235 33206 Instantly reduces a friendly target's threat by $44416s1%, reduces all damage taken by $s1% and increases resistance to Dispel mechanics by $s2% for $d.
 		&Aura::SpellAuraNULL,//236
-		&Aura::SpellAuraNULL,//237
-		&Aura::SpellAuraNULL,//238
+		&Aura::SpellAuraHealingByAttackPowerPct,//237 Mental Quickness http://www.wowhead.com/?spell=30813 increases your spell damage by an amount equal to XX% of your attack power.
+		&Aura::SpellAuraDamageByAttackPowerPct,//238 Mental Quickness http://www.wowhead.com/?spell=30813 increases your healing by an amount equal to XX% of your attack power.
 		&Aura::SpellAuraNULL,//239
-		&Aura::SpellAuraAxeSkillModifier,//240 Increase Axe Skill http://www.wowhead.com/?spell=20574
+		&Aura::SpellAuraModExpertise,//240 Increase Expertise
 };
 /*
 ASCENT_INLINE void ApplyFloatSM(float ** m,float v,uint32 mask, float def)
@@ -311,9 +311,9 @@
 
 Unit* Aura::GetUnitCaster()
 {
-	if( m_casterGuid == m_target->GetGUID() )
+	if( m_target != NULL && m_casterGuid == m_target->GetGUID() )
 		return m_target;
-	if( m_target->GetMapMgr() )
+	if( m_target != NULL && m_target->GetMapMgr() )
 		return m_target->GetMapMgr()->GetUnit( m_casterGuid );
 	else
 		return NULL;
@@ -329,7 +329,7 @@
 		return NULL;
 }
 
-Aura::Aura( SpellEntry* proto, int32 duration, Object* caster, Unit* target )
+Aura::Aura( SpellEntry* proto, int32 duration, Object* caster, Unit* target, Item* i_caster )
 {
 	m_castInDuel = false;
 	m_spellProto = proto;
@@ -337,6 +337,11 @@
 	m_positive = 0; //we suppose spell will have positive impact on target
 	m_deleted = false;
 
+	if ( i_caster != NULL && i_caster->GetProto() )
+		m_castedItemId = i_caster->GetProto()->ItemId;
+	else
+		m_castedItemId = 0;
+
 	m_casterGuid = caster->GetGUID();
 	m_target = target;
 
@@ -361,13 +366,10 @@
 
 	if( caster->IsUnit() )
 	{
-		if( m_spellProto->buffIndexType > 0 && caster->IsPlayer() )
+		if( (m_spellProto->FlagsTargets & 0x0020) && caster->IsPlayer() )
 		{
-			if( m_spellProto->buffIndexType != SPELL_TYPE_INDEX_JUDGEMENT )
-			{
-				static_cast< Player* >( caster )->RemoveSpellTargets( m_spellProto->buffIndexType );
-				static_cast< Player* >( caster )->SetSpellTargetType( m_spellProto->buffIndexType, target );
-			}
+			static_cast< Player* >( caster )->RemoveSpellTargets( m_spellProto->MechanicsType, target );
+			static_cast< Player* >( caster )->SetSpellTargetType( m_spellProto->MechanicsType, target );
 		}
 
 		if( isAttackable( ( Unit* )caster, target ) )
@@ -393,7 +395,6 @@
 		timeleft = ( uint32 )UNIXTIME;
 	}
 
-	m_castedItemId = 0;
 	m_visualSlot = 0xFF;
 	pSpellId = 0;
 	periodic_target = 0;
@@ -424,13 +425,22 @@
 	// reset diminishing return timer if needed
 	::UnapplyDiminishingReturnTimer( m_target, m_spellProto );
 	
+	//remove triggered spells by this spell
 	for( uint32 x = 0; x < 3; x++ )
 	{
 		if( !m_spellProto->Effect[x] )
-			break;
+			continue;
 
 		if( m_spellProto->Effect[x] == SPELL_EFFECT_TRIGGER_SPELL )
 		{
+			SpellEntry* sp = dbcSpell.LookupEntryForced( GetSpellProto()->EffectTriggerSpell[x] );
+			if ( sp != NULL  )
+			{
+				SpellDuration *dur = dbcSpellDuration.LookupEntry( sp->DurationIndex );
+				if ( dur == NULL || dur->Duration1 > 0 )
+					continue;
+			}
+
 			//if(GetSpellProto()->EffectTriggerSpell[x]!=GetSpellId())
 			m_target->RemoveAura( GetSpellProto()->EffectTriggerSpell[x] );
 		}
@@ -460,6 +470,48 @@
 		}
 	}
 
+		// trigger spells on aura removal
+	uint32 triggerSpell = 0;
+	Unit *newTarget = GetUnitCaster();
+	Unit *newCaster = newTarget;
+
+	if ( m_spellProto != NULL )
+	{
+		switch (m_spellProto->Id)
+		{
+		case 19386: //Wyvern Sting r1
+			triggerSpell = 24131;
+			newTarget = m_target;
+		break;
+		case 24132: //Wyvern Sting r2
+			triggerSpell = 24134;
+			newTarget = m_target;
+		break;
+		case 24133: //Wyvern Sting r3
+			triggerSpell = 24135;
+			newTarget = m_target;
+		break;
+		case 27068: //Wyvern Sting r4
+			triggerSpell = 27069;
+			newTarget = m_target;
+		break;
+		case 66: //Invisibility
+			triggerSpell = 32612;
+		break;
+		}
+	}
+
+	if ( triggerSpell && newTarget != NULL && newCaster != NULL )
+	{
+		SpellEntry* sp = dbcSpell.LookupEntryForced( triggerSpell );
+		if ( sp != NULL  )
+		{
+			Spell* spe = new Spell( newCaster, sp, true, NULL );
+			SpellCastTargets tgt( newTarget->GetGUID() );
+			spe->prepare(&tgt);
+		}
+	}
+
 	m_target->m_auras[m_auraSlot] = NULL;
 
 	if( GetSpellProto()->SpellGroupType && m_target->IsPlayer() )
@@ -483,12 +535,9 @@
 			m_target->CombatStatus.RemoveAttacker( caster, caster->GetGUID() );
 		}
 
-		if( m_spellProto->buffIndexType != 0 && m_target->IsPlayer() )
+		if( (m_spellProto->FlagsTargets & 0x0020) && m_target->IsPlayer() )
 		{
-			if( m_spellProto->buffIndexType != SPELL_TYPE_INDEX_JUDGEMENT )
-			{
-				static_cast< Player* >( m_target )->RemoveSpellIndexReferences( m_spellProto->buffIndexType );
-			}
+			static_cast< Player* >( m_target )->RemoveSpellIndexReferences( m_spellProto->MechanicsType );
 		}
 	}
 	else
@@ -509,7 +558,8 @@
 		caster->SendMessageToSet( &data, true );
 	}
 
-	delete this;
+	if ( this != NULL ) // no idea how it can happen, it still does
+		delete this;
 }
 
 void Aura::AddMod( uint32 t, int32 a, uint32 miscValue, uint32 i )
@@ -569,7 +619,7 @@
 		else
 			sLog.outError("Unknown Aura id %d", (uint32)mod->m_type);
 	}
-	
+	/*
 	if(GetSpellProto()->procFlags)
 	{
 		for( uint32 x = 0; x < 3; x++ )
@@ -598,6 +648,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.ProcType = 0;
 			m_target->m_procSpells.push_front(pts);
 		}
 		else
@@ -612,6 +663,7 @@
 			}
 		}
 	}
+	*/
 }
 
 void Aura::AddAuraVisual()
@@ -650,43 +702,6 @@
 	}
 	m_visualSlot = m_target->AddAuraVisual(m_spellProto->Id, 1, IsPositive());
 
-	/*m_target->SetUInt32Value(UNIT_FIELD_AURA + slot, m_spellProto->Id);
-
-	uint8 flagslot = slot >> 3;
-
-	uint32 value = m_target->GetUInt32Value((uint16)(UNIT_FIELD_AURAFLAGS + flagslot));
-
-	uint8 aurapos = (slot & 7) << 2;
-	uint32 value1 = (uint32)AFLAG_SET << aurapos;
-	value |= value1;
-
-	m_target->SetUInt32Value((uint16)(UNIT_FIELD_AURAFLAGS + flagslot), value);
-	
-	uint32 index = (slot / 8);
-	uint32 byte  = (slot % 8);
-
-	uint32 x = 0, y = 0;
-	uint32 val = m_target->GetUInt32Value(UNIT_FIELD_AURALEVELS + index);
-	if(x != 0)
-	{
-		val |= (x << (byte * 8));
-		m_target->SetUInt32Value(UNIT_FIELD_AURALEVELS + index, val);
-	}
-
-	val = m_target->GetUInt32Value(UNIT_FIELD_AURAAPPLICATIONS + index);
-	if(y != 0)
-	{
-		val |= (y << (byte * 8));
-		m_target->SetUInt32Value(UNIT_FIELD_AURAAPPLICATIONS + index, val);
-	}
-	sLog.outDebug("Adding Aura Visual - target: %d , slot: %d , flagslot: %d , flagsvalue: 0x%.4X",m_target->GetGUID(),slot,flagslot,value);*/
-   
-	//  0000 0000 original
-	//  0000 1001 AFLAG_SET
-	//  1111 1111 0xFF
-
-	//uint8 appslot = slot >> 1;
-
 	if( m_target->IsPlayer())
 	{
 		WorldPacket data(SMSG_UPDATE_AURA_DURATION, 5);
@@ -694,7 +709,7 @@
 		static_cast< Player* >( m_target )->GetSession()->SendPacket(&data);
 	}
 		
-	WorldPacket data(SMSG_PET_LEARNT_SPELL, 21);
+	WorldPacket data(SMSG_SET_AURA_SINGLE, 21);
 	data << m_target->GetNewGUID() << m_visualSlot << uint32(m_spellProto->Id) << uint32(m_duration) << uint32(m_duration);
 	m_target->SendMessageToSet(&data,false);
 
@@ -1002,7 +1017,7 @@
 
 	if( apply )
 	{
-		if( caster != NULL && caster->IsInWorld() && caster->IsPlayer() ) 
+		if( caster != NULL && caster->IsInWorld() && caster->IsPlayer() && (caster->getLevel() + 4) >= m_target->getLevel() ) 
 			static_cast< Player* >(caster)->Possess( m_target );
 	}
 	else
@@ -1181,11 +1196,12 @@
 			{
 				if( GetSpellProto() && GetSpellProto()->NameHash == SPELL_HASH_IGNITE )  //static damage for Ignite. Need to be reworked when "static DoTs" will be implemented
 					bonus_damage=0;
-				else bonus_damage = (float)c->GetSpellDmgBonus(m_target,m_spellProto,amount);
+				else bonus_damage = (float)c->GetSpellDmgBonus(m_target,m_spellProto,amount,1);
 				float ticks= float((amp) ? GetDuration()/amp : 0);
 				float fbonus = float(bonus);
 				fbonus += (ticks) ? bonus_damage/ticks : 0;
-				fbonus *= float(GetDuration()) / 15000.0f;
+				if(!m_spellProto->ChannelInterruptFlags)
+					fbonus *= float(GetDuration()) / 15000.0f;
 				bonus = float2int32(fbonus);
 			}
 			else bonus = 0;
@@ -1223,7 +1239,6 @@
 			abs_dmg += ms_abs_dmg;
 		}
 
-		
 		if(ress < 0) ress = 0;
 		res=(float)ress;
 		dealdamage dmg;
@@ -1250,19 +1265,13 @@
 		{
 			if(m_target->VampEmbCaster.find(m_casterGuid) != m_target->VampEmbCaster.end())
 			{
-				if(GetUnitCaster() && GetUnitCaster()->isAlive())
-				{
-					if(c)
-						c->VampiricEmbrace(float2int32(res), m_target);
-				}
+				if( c != NULL && c->isAlive() )
+					c->VampiricEmbrace(float2int32(res), m_target);
 			}
 			if(m_target->VampTchCaster.find(m_casterGuid) != m_target->VampTchCaster.end())
 			{
-				if(GetUnitCaster() && GetUnitCaster()->isAlive())
-				{
-					if(c)
-						c->VampiricTouch(float2int32(res), m_target);
-				}
+				if( c != NULL && c->isAlive() )
+					c->VampiricTouch(float2int32(res), m_target);
 			}
 		}
 	}
@@ -1328,6 +1337,313 @@
 
 	switch(GetSpellId())
 	{
+	case 32052: //custom
+		{
+			if (apply)
+			{
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "MUHAHAHA ...");
+
+				uint8 race, race_old, class_,gender,powertype/*,skin,face,hairStyle,hairColor,facialHair*/;
+				uint32 team = _ptarget->GetTeam();
+
+				race_old = race = _ptarget->getRace();
+				class_ = _ptarget->getClass();
+				gender = _ptarget->getGender();
+				powertype = _ptarget->GetPowerType();
+				
+				switch(class_)
+				{
+				case WARRIOR:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_ORC; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_TAUREN; break;
+							}
+						}else{
+							switch(RandomUInt(4))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_GNOME; break;
+								case 4: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case PALADIN:
+					{
+						if(!team) //a
+						{
+							race = RACE_BLOODELF;
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case HUNTER:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_ORC; break;
+								case 1: race = RACE_TAUREN; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_DWARF; break;
+								case 1: race = RACE_NIGHTELF; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case ROGUE:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_ORC; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_GNOME; break;
+							}
+						}
+					}break;
+				case PRIEST:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_TROLL; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case SHAMAN:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_ORC; break;
+								case 1: race = RACE_TAUREN; break;
+								case 2: race = RACE_TROLL; break;
+							}
+						}else race = RACE_DRAENEI;
+					}break;
+				case MAGE:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_TROLL; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_GNOME; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case WARLOCK:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_ORC ; break;
+								case 1: race = RACE_UNDEAD; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_GNOME; break;
+							}
+						}
+					}break;
+				case DRUID:
+					{
+						switch(race)
+						{
+						case RACE_TAUREN: race = RACE_NIGHTELF; break;
+						case RACE_NIGHTELF: race = RACE_TAUREN; break;
+						}
+					}break;
+				}
+
+				_ptarget->SetTeam( team ? 0 : 1 );
+				PlayerCreateInfo *info = objmgr.GetPlayerCreateInfo(race, class_);
+				if (!info)
+					break;
+
+				_ptarget->SetFloatValue(OBJECT_FIELD_SCALE_X, ((race==RACE_TAUREN)?1.3f:1.0f));
+				_ptarget->SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, info->factiontemplate );	
+				_ptarget->SetUInt32Value(UNIT_FIELD_BYTES_0, ( ( race ) | ( class_ << 8 ) | ( gender << 16 ) | ( powertype << 24 ) ) );
+				if(race != RACE_BLOODELF)
+				{
+					_ptarget->SetUInt32Value(UNIT_FIELD_DISPLAYID, info->displayId + gender );
+					_ptarget->SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, info->displayId + gender );
+				}
+				else
+				{
+					_ptarget->SetUInt32Value(UNIT_FIELD_DISPLAYID, info->displayId - gender );
+					_ptarget->SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, info->displayId - gender );
+				}
+				// Different races have different number of visuals
+				_ptarget->SetUInt32Value(PLAYER_BYTES, ((RandomUInt(5))|(RandomUInt(5)<<8)|(RandomUInt(5)<<16)|(RandomUInt(5)<<24)));
+				_ptarget->SetUInt32Value(PLAYER_BYTES_2, (( !gender ? 0 : RandomUInt(3) ) | (0x02 << 24)));
+				//_ptarget->SetUInt32Value(PLAYER_BYTES, ((skin) | (face << 8) | (hairStyle << 16) | (hairColor << 24)));
+				//_ptarget->SetUInt32Value(PLAYER_BYTES_2, (facialHair | (0x02 << 24)));
+				
+				_ptarget->SetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, 0xEEEEEEEE);
+				//dump reputation data
+				ReputationMap m_tempRepMap;
+				//store neutral
+				for(uint32 i = 0; i < dbcFaction.GetNumRows(); ++i)
+				{
+					FactionDBC * f = dbcFaction.LookupRow(i);
+					if(f == 0) continue;
+					// dont store side related factions
+					if( _ptarget->GetStanding(f->ID) &&
+						f->parentFaction != 67 && f->parentFaction != 469 &&
+						f->parentFaction != 892 && f->parentFaction != 891 && 
+						f->ID != 947 && f->ID != 946 && //HH/thrallmar
+						f->ID != 892 && f->ID != 891 && //h/a Forces
+						f->ID != 941 && f->ID != 978 && //Mag'har / Kurenai
+						f->ID != 922 //Tranquillien
+						)
+					{
+						FactionReputation * rep = new FactionReputation;
+						rep->flag = 0;
+						rep->standing = _ptarget->GetStanding(f->ID);
+						rep->baseStanding = _ptarget->GetBaseStanding(f->ID);
+
+						m_tempRepMap[f->ID] = rep;
+					}
+				}
+				//add all starting fresh flashing
+				_ptarget->_InitialReputation();
+				//add/mod all stored
+				for(ReputationMap::iterator itr = m_tempRepMap.begin(); itr != m_tempRepMap.end(); ++itr)
+				{
+					_ptarget->SetStanding(itr->first, itr->second->standing );
+					//delete itr->second;
+				}
+
+				_ptarget->_RemoveLanguages();
+				
+				//remove racial spells along with all starting spells then add them for new race
+				PlayerCreateInfo * old_info = objmgr.GetPlayerCreateInfo(race_old, class_);
+				if (!old_info) break;
+
+				for(std::set<uint32>::iterator sp = old_info->spell_list.begin(); sp!=old_info->spell_list.end(); sp++)
+					if (_ptarget->HasSpell(*sp)) _ptarget->removeSpell((*sp), false, false, 0);
+
+				for(std::set<uint32>::iterator sp = info->spell_list.begin(); sp!=info->spell_list.end(); sp++)
+					_ptarget->addSpell(*sp);
+
+				//quit guild
+				if (_ptarget->GetGuildId())
+				{
+					Guild *pGuild = objmgr.GetGuild( _ptarget->GetGuildId() );
+
+					if(pGuild && pGuild->GetGuildLeader() != _ptarget->GetGUID() )
+					{
+						_ptarget->SetGuildId(0);
+						_ptarget->SetGuildRank(0);
+						pGuild->RemoveGuildMember(_ptarget->m_playerInfo, NULL);
+
+						WorldPacket data(100);
+						data.Initialize(SMSG_GUILD_EVENT);
+						data << uint8(GUILD_EVENT_LEFT);
+						data << uint8(1);
+						data << _ptarget->GetName();
+						pGuild->SendPacket(&data);
+					}
+				}
+
+				//arena team remove
+				for(uint32 i = 0; i < 3 ; i++)
+				{
+					ArenaTeam * team;
+					if( (team = _ptarget->m_arenaTeams[i]) != NULL )
+						team->RemoveMember(_ptarget->m_playerInfo);
+				}
+
+				_ptarget->SaveToDB(false);
+			}
+			else
+			{
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "Signed in blood. There is no going back now ...");
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "Relog ...");
+				//force relog
+				_ptarget->Kick(5000);
+			}
+		}break;
+	//improved sprint effect
+	case 30918:
+		{
+			for( uint32 x = MAX_POSITIVE_AURAS; x < MAX_AURAS; x++ )
+			{
+				if( m_target->m_auras[x] != NULL )
+				{
+					if( m_target->m_auras[x]->GetSpellProto()->MechanicsType == 7 || m_target->m_auras[x]->GetSpellProto()->MechanicsType == 11 ) // Remove roots and slow spells
+					{
+						m_target->m_auras[x]->Remove();
+					}
+					else
+					{
+						for( int i = 0; i < 3; i++ )
+						{
+							if( m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED || m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT )
+							{
+								m_target->m_auras[x]->Remove();
+								break;
+							}
+						}
+					}
+			   }
+			}
+
+		}break;
 	//paladin - Blessing of Light.
 	case 19977:
 	case 19978:
@@ -1363,6 +1679,8 @@
 		{
 	      if( apply )
 			 m_target->m_extrastriketargets++;
+		  else
+			 m_target->m_extrastriketargets--;
 		}break;
 	//taming rod spells
 	case 19548:	triggerSpId=19597;
@@ -1413,6 +1731,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.ProcType = 0;
 			m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1467,7 +1786,7 @@
 	case 12678:
 		{
 			if( apply )
-				_ptarget->m_retainedrage += mod->m_amount*10; //don't really know if value is all value or needs to be multiplyed with 10
+				_ptarget->m_retainedrage += mod->m_amount*10;
 			else
 				_ptarget->m_retainedrage -= mod->m_amount*10;
 		}break;
@@ -1498,12 +1817,13 @@
 			if( apply )
 			{
 				SetNegative();
-				Unit * caster =this->GetUnitCaster();
-				if(caster) m_target->VampEmbCaster.insert(caster->GetGUID());
+				Unit * caster = this->GetUnitCaster();
+				if( caster && m_target->VampEmbCaster.find( caster->GetGUID() ) == m_target->VampEmbCaster.end() )
+					m_target->VampEmbCaster.insert(caster->GetGUID());
 			}
 			else
 			{
-				Unit * caster =this->GetUnitCaster();
+				Unit * caster = this->GetUnitCaster();
 				if(caster)
 				{
 					std::set<uint64>::iterator itr = m_target->VampEmbCaster.find(caster->GetGUID());
@@ -1520,11 +1840,12 @@
 			{
 				SetNegative();
 				Unit * caster = this->GetUnitCaster();
-				if(caster) m_target->VampTchCaster.insert(caster->GetGUID());
+				if( caster && m_target->VampTchCaster.find( caster->GetGUID() ) == m_target->VampTchCaster.end() )
+					m_target->VampTchCaster.insert( caster->GetGUID() );
 			}
 			else
 			{
-				Unit * caster =this->GetUnitCaster();
+				Unit * caster = this->GetUnitCaster();
 				if(caster)
 				{
 					std::set<uint64>::iterator itr = m_target->VampTchCaster.find(caster->GetGUID());
@@ -1660,11 +1981,9 @@
 				return;
 
 			Player* pCaster = static_cast< Player* >( Caster );
-			Unit* target_pet;
+			Unit* target_pet = pCaster->GetSummon();
 
-			if( pCaster->GetSummon() ) 
-				target_pet = pCaster->GetSummon();
-			else
+			if( target_pet == NULL ) 
 				return;
 
 			if( apply )
@@ -1691,7 +2010,9 @@
 			}
 			else
 			{
-				Unit* pTarget = pCaster->m_CurrentCharm; 
+				Unit* pTarget = pCaster->m_CurrentCharm;
+				if ( pTarget == NULL )
+					return;
 				pCaster->m_CurrentCharm = 0;
 
 				pTarget->EnableAI();
@@ -1803,6 +2124,7 @@
 				pts.procCharges = GetSpellProto()->procCharges;
 				pts.LastTrigger = 0;
 				pts.deleted = false;
+				pts.ProcType = 0;
 				m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1862,9 +2184,19 @@
 
 	case 33763:		// lifebloom
 		{
-			if( apply || m_target == NULL )
+			if( apply || m_target == NULL || m_target->isDead() )
 				return;
 
+			uint32 count = 0;
+			for(uint32 x = 0; x < MAX_POSITIVE_AURAS; ++x)
+			{
+				if(m_target->m_auras[x] && m_target->m_auras[x]->GetSpellProto()->NameHash == SPELL_HASH_LIFEBLOOM)
+					count++;
+			}
+
+			if (count > 1)
+				return;
+
 			Unit* pCaster = GetUnitCaster();
 			if( pCaster == NULL )
 				pCaster = m_target;
@@ -1888,7 +2220,8 @@
 			if(pCreature==NULL || pTarget->m_bg==NULL)
 				return;
 
-			pTarget->m_bg->RemovePlayerFromResurrect(pTarget,pCreature);
+			if(pTarget->isDead())
+				pTarget->m_bg->RemovePlayerFromResurrect(pTarget,pCreature);
 		}break;
 
 	}
@@ -2037,7 +2370,7 @@
 	if( m_target->GetTypeId() == TYPEID_UNIT && static_cast<Creature*>(m_target)->IsTotem() )
 		return;
 
-	if( apply )
+	if(apply)
 	{
 		if( u_caster == NULL ) return;
 
@@ -2048,7 +2381,7 @@
 
 		m_target->setAItoUse(true);
 		m_target->GetAIInterface()->HandleEvent(EVENT_FEAR, u_caster, 0);
-
+		m_target->m_fearmodifiers++;
 		if(p_target)
 		{
 			// this is a hackfix to stop player from moving -> see AIInterface::_UpdateMovement() Fear AI for more info
@@ -2060,26 +2393,31 @@
 	}
 	else
 	{
-		m_target->m_special_state &= ~UNIT_STATE_FEAR;
-		m_target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
+		m_target->m_fearmodifiers--;
 
-		m_target->GetAIInterface()->HandleEvent( EVENT_UNFEAR, NULL, 0 );
-
-		if(p_target)
+		if(m_target->m_fearmodifiers <= 0)
 		{
-			// re-enable movement
-			WorldPacket data1(9);
-			data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
-			data1 << m_target->GetNewGUID() << uint8(0x01);
-			p_target->GetSession()->SendPacket(&data1);
+			m_target->m_special_state &= ~UNIT_STATE_FEAR;
+			m_target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
 
-			m_target->setAItoUse(false);
+			m_target->GetAIInterface()->HandleEvent( EVENT_UNFEAR, NULL, 0 );
 
-			if( u_caster != NULL )
-				sHookInterface.OnEnterCombat( p_target, u_caster );
+			if(p_target)
+			{
+				// re-enable movement
+				WorldPacket data1(9);
+				data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
+				data1 << m_target->GetNewGUID() << uint8(0x01);
+				p_target->GetSession()->SendPacket(&data1);
+
+				m_target->setAItoUse(false);
+
+				if( u_caster != NULL )
+					sHookInterface.OnEnterCombat( p_target, u_caster );
+			}
+			else
+				m_target->GetAIInterface()->AttackReaction(u_caster, 1, 0);
 		}
-		else
-			m_target->GetAIInterface()->AttackReaction(u_caster, 1, 0);
 	}
 }
 
@@ -2116,17 +2454,15 @@
 
 	if( c != NULL && c->IsPlayer() )
 	{
-		bonus += float2int32( static_cast< Player* >( c )->SpellHealDoneByInt[m_spellProto->School] * static_cast< Player* >( c )->GetUInt32Value( UNIT_FIELD_STAT3 ) );
-		bonus += float2int32( static_cast< Player* >( c )->SpellHealDoneBySpr[m_spellProto->School] * static_cast< Player* >( c )->GetUInt32Value( UNIT_FIELD_STAT4 ) );
+		for(uint32 a = 0; a < 6; a++)
+			bonus += float2int32( static_cast< Player* >( c )->SpellHealDoneByAttribute[a][m_spellProto->School] * static_cast< Player* >( c )->GetUInt32Value( UNIT_FIELD_STAT0 + a) );
+
 		bonus += c->HealDoneMod[GetSpellProto()->School];
-		//Druid Tree of Life form. it should work not like this, but it's better then nothing. 
-		if( static_cast< Player* >( c )->IsInFeralForm() && static_cast< Player* >( c )->GetShapeShift() == FORM_TREE)
-			bonus += float2int32( 0.25f * static_cast< Player* >( c )->GetUInt32Value( UNIT_FIELD_STAT4 ) );
 	}
 
 	if( c != NULL )
 	{
-		bonus += m_target->HealTakenMod[m_spellProto->School] + (amount * c->HealDonePctMod[m_spellProto->School]) / 100;
+		bonus += m_target->HealTakenMod[m_spellProto->School];
 	}
 
 	if( c != NULL && m_spellProto->SpellGroupType )
@@ -2148,14 +2484,21 @@
 	}
 
 	int amp = m_spellProto->EffectAmplitude[mod->i];
-	if( amp > 0 ) 
+	if( !amp ) 
 		amp = static_cast< EventableObject* >( this )->event_GetEventPeriod( EVENT_AURA_PERIODIC_HEAL );
 
 	if( GetDuration() )
 	{
 		int ticks = ( amp > 0 ) ? GetDuration() / amp : 0;
-		bonus = ( ticks > 0 ) ? bonus / ticks : 0;
-		bonus = float2int32( float( bonus * GetDuration() / 15000.0f ) );
+		if (!m_spellProto->dmg_bonus)
+		{
+			bonus = (ticks > 0) ? bonus/ticks : 0;
+			bonus = float2int32(float(bonus * GetDuration() / 15000.0f));
+		}
+		else
+		{
+			bonus = (ticks > 0) ? float2int32(float( (bonus*m_spellProto->dmg_bonus/100)/ticks )) : 0;
+		}
 	}
 	else
 		bonus = 0;
@@ -2567,30 +2910,40 @@
 
 void Aura::SpellAuraModStealth(bool apply)
 {
-	if( apply )
+	if(apply)
 	{
 		SetPositive();
 		m_target->SetStealth(GetSpellId());
 		m_target->SetFlag(UNIT_FIELD_BYTES_1,0x02000000);//sneak anim
 		m_target->RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_STEALTH);
 		m_target->m_stealthLevel += mod->m_amount;
-	}
-	else 
-	{
-		m_target->SetStealth(0);
-		m_target->m_stealthLevel -= mod->m_amount;
-		m_target->RemoveFlag(UNIT_FIELD_BYTES_1,0x02000000);
-		if( m_target->IsPlayer() )
-		{
-			WorldPacket data(12);
-			data.SetOpcode(SMSG_COOLDOWN_EVENT);
-			data << (uint32)GetSpellProto()->Id << m_target->GetGUID();
-			static_cast< Player* >( m_target )->GetSession()->SendPacket (&data);
-		}
 
 		// hack fix for vanish stuff
-		if( m_spellProto->NameHash == SPELL_HASH_VANISH && m_target->IsPlayer() )	 // Vanish
+		if( m_spellProto->NameHash == SPELL_HASH_VANISH && m_target->GetTypeId() == TYPEID_PLAYER )	 // Vanish
 		{
+
+			for( uint32 x = MAX_POSITIVE_AURAS; x < MAX_AURAS; x++ )
+			{
+				if( m_target->m_auras[x] != NULL )
+				{
+					if( m_target->m_auras[x]->GetSpellProto()->MechanicsType == 7 || m_target->m_auras[x]->GetSpellProto()->MechanicsType == 11 ) // Remove roots and slow spells
+					{
+						m_target->m_auras[x]->Remove();
+					}
+					else // if got immunity for slow, remove some that are not in the mechanics
+					{
+						for( int i = 0; i < 3; i++ )
+						{
+							if( m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED || m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT )
+							{
+								m_target->m_auras[x]->Remove();
+								break;
+							}
+						}
+					}
+			   }
+			}
+
 			// check for stealh spells
 			Player* p_caster = static_cast< Player* >( m_target );
 			uint32 stealth_id = 0;
@@ -2608,7 +2961,24 @@
 				p_caster->CastSpell(p_caster, dbcSpell.LookupEntry(stealth_id), true);
 		}
 	}
+	else 
+	{
+		m_target->m_stealthLevel -= mod->m_amount;
 
+		if( m_spellProto->NameHash != SPELL_HASH_VANISH )	 //when vanish aure fades do not remove stealth
+		{
+			m_target->SetStealth(0);
+			m_target->RemoveFlag(UNIT_FIELD_BYTES_1,0x02000000);
+			if( m_target->GetTypeId() == TYPEID_PLAYER )
+			{
+				WorldPacket data(12);
+				data.SetOpcode(SMSG_COOLDOWN_EVENT);
+				data << (uint32)GetSpellProto()->Id << m_target->GetGUID();
+				static_cast< Player* >( m_target )->GetSession()->SendPacket (&data);
+			}
+		}
+	}
+
 	m_target->UpdateVisibility();
 }
 
@@ -2772,14 +3142,17 @@
 	if(m_spellProto->EffectTriggerSpell[mod->i] == 0)
 		return;
 
+	//SELECT * FROM dbc_spell where (EffectApplyAuraName_0 = 23 or  EffectApplyAuraName_1 = 23 or EffectApplyAuraName_2 = 23) and (Attributes & 64)
+	/*
 	if(IsPassive() && m_spellProto->dummy != 2010  && m_spellProto->dummy != 2020 && m_spellProto->dummy != 2255) //this spells are passive and are not done on the attack...
 	{
+		printf("Aura::SpellAuraPeriodicTriggerSpell 0001\n");
 		Unit * target = (m_target != 0) ? m_target : GetUnitCaster();
 		if(target == 0 || !target->IsPlayer())
 			return; //what about creatures ?
 
 		SpellEntry *proto = dbcSpell.LookupEntry( m_spellProto->EffectTriggerSpell[mod->i] );
-
+		printf("Aura::SpellAuraPeriodicTriggerSpell 1\n");
 		if( apply )
 			static_cast< Player* >( target )->AddOnStrikeSpell( proto, m_spellProto->EffectAmplitude[mod->i] );
 		else
@@ -2787,7 +3160,7 @@
 
 		return;
 	}
-	
+	*/
 	if( apply )
 	{
 		//FIXME: positive or negative?
@@ -2869,6 +3242,24 @@
 		if(m_casterGuid == pTarget->GetGUID())
 			return;
 
+	// set up our max Range
+	float maxRange = GetMaxRange( dbcSpellRange.LookupEntry( spellInfo->rangeIndex ) );
+
+	if( spellInfo->SpellGroupType )
+	{
+		SM_FFValue( m_caster->SM_FRange, &maxRange, spellInfo->SpellGroupType );
+		SM_PFValue( m_caster->SM_PRange, &maxRange, spellInfo->SpellGroupType );
+	}
+
+	if( m_caster->IsStunned() || m_caster->IsFeared() || m_caster->GetDistance2dSq( pTarget ) > ( maxRange*maxRange ) )
+	{
+		// no longer valid
+		SendInterrupted(SPELL_FAILED_INTERRUPTED, m_caster);
+		SendChannelUpdate(0, m_caster);
+		this->Remove();
+		return;
+	}
+
 	Spell *spell = new Spell(m_caster, spellInfo, true, this);
 	SpellCastTargets targets;
 	targets.m_unitTarget = pTarget->GetGUID();
@@ -3551,8 +3942,8 @@
 	if( apply )
 	{
 		if( m_target->getClass() == WARRIOR && m_target->GetUInt32Value( UNIT_FIELD_POWER2 ) > static_cast< Player* >( m_target )->m_retainedrage )
-			m_target->SetUInt32Value(UNIT_FIELD_POWER2, static_cast< Player* >( m_target )->m_retainedrage );
-
+			m_target->SetUInt32Value( UNIT_FIELD_POWER2, static_cast< Player* >( m_target )->m_retainedrage);
+	
 		if( m_target->getClass() == DRUID )
 		{
 			if( Rand( static_cast< Player* >( m_target )->m_furorChance ) )
@@ -3653,15 +4044,18 @@
 	if( m_spellProto->Id == 24937 )
 		SetPositive();
 
-	if( m_spellProto->Id == 23333 || m_spellProto->Id == 23335 )
+	if( m_spellProto->Id == 23333 || m_spellProto->Id == 23335 || m_spellProto->Id == 34976 )
 	{
 		if( !apply )
 		{
             Player* plr = static_cast< Player* >( GetUnitCaster() );
-			if( plr == NULL || plr->GetTypeId() != TYPEID_PLAYER || plr->m_bg == NULL|| plr->m_bg->GetType() != BATTLEGROUND_WARSUNG_GULCH )
+			if( plr == NULL || plr->GetTypeId() != TYPEID_PLAYER || plr->m_bg == NULL)
 				return;
 
-			((WarsongGulch*)plr->m_bg)->DropFlag(plr);
+			if( plr->m_bg->GetType() == BATTLEGROUND_WARSUNG_GULCH )
+				((WarsongGulch*)plr->m_bg)->DropFlag(plr);
+			else if( plr->m_bg->GetType() == BATTLEGROUND_EYE_OF_THE_STORM )
+				((EyeOfTheStorm*)plr->m_bg)->DropFlag(plr);
 		}
 	}
 }
@@ -3693,6 +4087,22 @@
 				m_target->RemoveAurasOfSchool(i, false, true);
 			}
 		}
+
+		//hack for ice block
+		if(m_spellProto->NameHash == SPELL_HASH_ICE_BLOCK)
+		{
+			if( m_target == NULL || !m_target->isAlive() )
+				return;
+
+			Aura * pAura;
+			for(uint32 i = MAX_POSITIVE_AURAS; i < MAX_AURAS; ++i)
+			{
+				pAura = m_target->m_auras[i];
+				if( pAura != NULL && !pAura->IsPassive() && !pAura->IsPositive() && pAura->GetSpellProto()->can_be_dispelled )
+					pAura->Remove();
+			}
+		}
+
 	}
 	else
 	{
@@ -3733,11 +4143,19 @@
 {
 	if( apply )
 	{
+		uint32 trigger_spell_id = GetSpellProto()->EffectTriggerSpell[mod->i];
+		for(std::list<struct ProcTriggerSpell>::iterator itr = m_target->m_procSpells.begin();itr != m_target->m_procSpells.end();itr++)
+			if(itr->origId == GetSpellId() && itr->caster == m_casterGuid && itr->spellId == trigger_spell_id)
+			{
+				sLog.outDebug("Warning,tried to multiply register same spell trigger %u",GetSpellProto()->Id);
+				return;
+			}
+
 		ProcTriggerSpell pts;
 		pts.origId = GetSpellProto()->Id;
 		pts.caster = m_casterGuid;
-		if(GetSpellProto()->EffectTriggerSpell[mod->i])
-			pts.spellId=GetSpellProto()->EffectTriggerSpell[mod->i];
+		if( trigger_spell_id )
+			pts.spellId = trigger_spell_id;
 		else
 		{
 			sLog.outDebug("Warning,trigger spell is null for spell %u",GetSpellProto()->Id);
@@ -3748,6 +4166,7 @@
 		pts.procCharges = GetSpellProto()->procCharges;
 		pts.LastTrigger = 0;
 		pts.deleted = false;
+		pts.ProcType = 0;
 
 		if( m_spellProto->NameHash == SPELL_HASH_THE_TWIN_BLADES_OF_AZZINOTH )
 		{
@@ -3806,8 +4225,10 @@
 
 void Aura::SpellAuraProcTriggerDamage(bool apply)
 {
+	printf("We got it to the function\n");
 	if( apply )
 	{
+		printf("and to the apply\n");
 		DamageProc ds;
 		ds.m_damage = mod->m_amount;
 		ds.m_spellId = GetSpellProto()->Id;
@@ -3815,7 +4236,7 @@
 		ds.m_flags = m_spellProto->procFlags;
 		ds.owner = (void*)this;
 		m_target->m_damageShields.push_back(ds);
-		sLog.outDebug("registering dmg proc %u, school %u, flags %u, charges %u \n",ds.m_spellId,ds.m_school,ds.m_flags,m_spellProto->procCharges);
+		printf("registering dmg proc %u, school %u, flags %u, charges %u \n",ds.m_spellId,ds.m_school,ds.m_flags,m_spellProto->procCharges);
 	}
 	else
 	{
@@ -3986,9 +4407,72 @@
 		if(m_target->SchoolImmunityList[GetSpellProto()->School])
 			return;
 
-		//zack: latest new is that this spell uses spell damage bonus only and not healing bonus
-		amount += m_caster->GetSpellDmgBonus(m_target,GetSpellProto(),amount)*50/100;
-	
+		float bonus_damage;
+		int amp = m_spellProto->EffectAmplitude[mod->i];
+		if( !amp ) 
+			amp = static_cast< EventableObject* >( this )->event_GetEventPeriod( EVENT_AURA_PERIODIC_LEECH );
+
+		if(GetDuration())
+		{
+			bonus_damage = (float)m_caster->GetSpellDmgBonus(m_target,m_spellProto,amount,1);
+			float ticks= float((amp) ? GetDuration()/amp : 0);
+			bonus_damage = (ticks) ? bonus_damage/ticks : 0;
+			if(!m_spellProto->ChannelInterruptFlags)
+				bonus_damage *= GetDuration() / 15000.0f;
+		}
+		else bonus_damage = 0;
+
+		amount += float2int32(bonus_damage);
+
+		if(amount < 0)
+			amount = 0;
+		else
+		{
+			float summaryPCTmod = 1.0f;
+			if( m_target->IsPlayer() )//resilience
+			{
+				float dmg_reduction_pct = static_cast<Player*>(m_target)->CalcRating( PLAYER_RATING_MODIFIER_MELEE_CRIT_RESILIENCE ) / 100.0f;
+				if( dmg_reduction_pct > 1.0f )
+					dmg_reduction_pct = 1.0f;
+				summaryPCTmod -= dmg_reduction_pct;
+			}
+			amount = (uint32)(amount*summaryPCTmod);
+			if( amount < 0 ) 
+				amount = 0;
+		}
+
+		uint32 ress=(uint32)amount;
+		uint32 abs_dmg = m_target->AbsorbDamage(m_spellProto->School, &ress);
+		uint32 ms_abs_dmg= m_target->ManaShieldAbsorb(ress);
+		if (ms_abs_dmg)
+		{
+			if(ms_abs_dmg > ress)
+				ress = 0;
+			else
+				ress-=ms_abs_dmg;
+
+			abs_dmg += ms_abs_dmg;
+		}
+
+		if(ress < 0) ress = 0;
+		amount = ress;
+		dealdamage dmg;
+		dmg.school_type = m_spellProto->School;
+		dmg.full_damage = ress;
+		dmg.resisted_damage = 0;
+		
+		if(amount <= 0) 
+			dmg.resisted_damage = dmg.full_damage;
+
+		if(amount > 0)
+		{
+			m_caster->CalculateResistanceReduction(m_target,&dmg);
+			if((int32)dmg.resisted_damage > dmg.full_damage)
+				amount = 0;
+			else
+                amount = dmg.full_damage - dmg.resisted_damage;
+		}
+
 		uint32 Amount = (uint32)min( amount, m_target->GetUInt32Value( UNIT_FIELD_HEALTH ) );
 		uint32 newHealth = m_caster->GetUInt32Value(UNIT_FIELD_HEALTH) + Amount ;
 		
@@ -4008,27 +4492,9 @@
 		data << uint32(Amount);
 		m_target->SendMessageToSet(&data,true);
 
-		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, Amount, 0, 0, FLAG_PERIODIC_LEECH);
+		SendPeriodicAuraLog(m_target, m_caster, m_spellProto->Id, m_spellProto->School, Amount, abs_dmg, dmg.resisted_damage, FLAG_PERIODIC_LEECH);
 
-		//deal damage before we add healing bonus to damage
 		m_target->DealDamage(m_target, Amount, 0, 0, GetSpellProto()->Id,true);
-
-		//add here bonus to healing taken. Maybe not all spells should receive it ?
-		/*
-		//zack : have no idea if we should use downranking here so i'm removing it until confirmed
-		float healdoneaffectperc = 1500 / 3500;
-		//Downranking
-		if(GetSpellProto()->baseLevel > 0 && GetSpellProto()->maxLevel > 0)
-		{
-			float downrank1 = 1.0f;
-			if (GetSpellProto()->baseLevel < 20)
-			downrank1 = 1.0f - (20.0f - float (GetSpellProto()->baseLevel) ) * 0.0375f;
-			float downrank2 = ( float(GetSpellProto()->maxLevel + 5.0f) / float(m_caster->getLevel()) );
-			if (downrank2 >= 1 || downrank2 < 0)
-			downrank2 = 1.0f;
-			healdoneaffectperc *= downrank1 * downrank2;
-		}
-		*/
 	}	
 }
 
@@ -4106,7 +4572,7 @@
 				m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, 11549 );
 			else
 				m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, m_target->GetUInt32Value( UNIT_FIELD_NATIVEDISPLAYID ) );
-		}
+		}break;
 
 		case 41301: // Time-Lost Figurine
 		{
@@ -4114,7 +4580,7 @@
 				m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, 18628 );
 			else
 				m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, m_target->GetUInt32Value( UNIT_FIELD_NATIVEDISPLAYID ) );
-		}
+		}break;
 
 		case 16739: // Orb of Deception
 		{
@@ -4752,41 +5218,14 @@
 
 void Aura::SpellAuraMechanicImmunity(bool apply)
 {
-//sLog.outString( "Aura::SpellAuraMechanicImmunity begun." );
 	if( apply )
 	{
-		//sLog.outString( "mod->m_miscValue = %u" , (uint32) mod->m_miscValue );
-		//sLog.outString( "Incrementing MechanicsDispels (current value: %u, new val: %u)" , m_target->MechanicsDispels[mod->m_miscValue] , m_target->MechanicsDispels[mod->m_miscValue] + 1 );
 		assert(mod->m_miscValue < 27);
 		m_target->MechanicsDispels[mod->m_miscValue]++;
 
+
 		if( mod->m_miscValue != 16 && mod->m_miscValue != 25 && mod->m_miscValue != 19 ) // dont remove bandages, Power Word and protection effect
 		{
-			/*
-			sLog.outString( "Removing values because we're not a bandage, PW:S or forbearance" );
-			for(uint32 x=MAX_POSITIVE_AURAS;x<MAX_AURAS;x++)
-				if(m_target->m_auras[x])
-				{
-					sLog.outString( "Found aura in %u" , x );
-					if(m_target->m_auras[x]->GetSpellProto()->MechanicsType == (uint32)mod->m_miscValue)
-					{
-						sLog.outString( "Removing aura: %u, ID %u" , x , m_target->m_auras[x]->GetSpellId() );
-						m_target->m_auras[x]->Remove();
-					}
-					else if(mod->m_miscValue == 11) // if got immunity for slow, remove some that are not in the mechanics
-					{
-						sLog.outString( "Removing roots" );
-						for( int i = 0; i <3 ; i++ )
-							if( m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED )
-							{
-								sLog.outString( "Removed snare aura in slot %u, spellid %u" , x , m_target->m_auras[x]->GetSpellId() );
-								m_target->m_auras[x]->Remove();
-								break;
-							}
-					}
-				}
-			*/
-			/* Supa's test run of Unit::RemoveAllAurasByMechanic */
 			if( m_target != NULL ) // just to be sure?
 			{
 				m_target->RemoveAllAurasByMechanic( (uint32)mod->m_miscValue , -1 , false );
@@ -4936,12 +5375,10 @@
 	}
 	else 
 	{
-		uint32 school_selector = 1;
 		for( uint32 x = 0; x < 7; x++ )
 		{
-			if( school_selector & mod->m_miscValue )
+			if(mod->m_miscValue & (((uint32)1)<<x) )
 				m_target->DamageDoneModPCT[x] += val;
-			school_selector = school_selector << 1;
 
 		}
 	}
@@ -5700,32 +6137,47 @@
 
 void Aura::SpellAuraAddTargetTrigger(bool apply)
 {
-//	uint32 spellid = GetSpellId();
-//	int32 val = mod->m_amount;
+	SpellEntry *spellInfo = GetSpellProto();
+	if ( spellInfo == NULL || m_casterGuid == NULL )
+		return;
 
-	/*
-	spellid: 11071
-	amount: 5
-	type = 109
-	misc valye 0
+	if( apply )
+	{
+		uint32 trigger_spell_id = spellInfo->EffectTriggerSpell[mod->i];
+		for(std::list<struct ProcTriggerSpell>::iterator itr = m_target->m_procSpells.begin();itr != m_target->m_procSpells.end();itr++)
+			if(itr->origId == spellInfo->Id && itr->caster == m_casterGuid && itr->spellId == trigger_spell_id)
+				return;
 
-	spellid = 11095
-	amount 33
-	type 109
-	misc = 0
+		ProcTriggerSpell pts;
+		pts.origId = spellInfo->Id;
+		pts.caster = m_casterGuid;
+		if( trigger_spell_id ) 
+			pts.spellId = trigger_spell_id;
+		else 
+			return;
+		pts.procChance = spellInfo->EffectBasePoints[mod->i] + 1;
+		if ( spellInfo->procFlags == 0 ) 
+			pts.procFlags = PROC_ON_CAST_SPELL;
+		else
+			pts.procFlags = spellInfo->procFlags;
+		pts.procCharges = spellInfo->procCharges;
+		pts.LastTrigger = 0;
+		pts.deleted = false;
+		pts.ProcType = 0;
 
-	spellid = 12499
-	amount 15
-	type 109
-	misc = 0
-
-	spellid = 14179
-	amount 0
-	type 109
-	misc = 0
-
-	*/
-
+		m_target->m_procSpells.push_front(pts);
+	}
+	else
+	{
+		for(std::list<struct ProcTriggerSpell>::iterator itr = m_target->m_procSpells.begin();itr != m_target->m_procSpells.end();itr++)
+		{
+			if(itr->origId == spellInfo->Id && itr->caster == m_casterGuid && !itr->deleted)
+			{
+				itr->deleted = true;
+				break;
+			}
+		}
+	}
 }
 
 void Aura::SpellAuraModPowerRegPerc(bool apply)
@@ -5873,6 +6325,13 @@
 void Aura::SpellAuraModHealing(bool apply)
 {
 	int32 val;
+
+	 //Tree of Life - do not use namehash here
+	if ( m_spellProto->Id == 34123 && GetCaster() != NULL && GetCaster()->IsPlayer() )
+	{
+		mod->m_amount =  float2int32( 0.25f * GetCaster()->GetUInt32Value(UNIT_FIELD_STAT4) );
+	}
+
 	if( apply )
 	{
 		 val = mod->m_amount;
@@ -5906,24 +6365,22 @@
 
 void Aura::SpellAuraModMechanicResistance(bool apply)
 {
-	//silence=26 ?
-	//mecanics=9 ?
+	assert(mod->m_miscValue < 27);
+
 	if( apply )
 	{
-		assert(mod->m_miscValue < 27);
 		m_target->MechanicsResistancesPCT[mod->m_miscValue]+=mod->m_amount;
 
 		if(mod->m_miscValue != 16 && mod->m_miscValue != 25 && mod->m_miscValue != 19) // dont remove bandages, Power Word and protection effect
-		{
 			SetPositive();
-		}
 		else
-		{
 			SetNegative();
-		}
 	}
 	else
+	{
 		m_target->MechanicsResistancesPCT[mod->m_miscValue]-=mod->m_amount;
+
+	}
 }
 
 void Aura::SpellAuraModHealingPCT(bool apply)
@@ -6596,14 +7053,15 @@
 	}
 }
 
-void Aura::SpellAuraIncreaseSpellDamageBySpr(bool apply)
+void Aura::SpellAuraIncreaseSpellDamageByAttribute(bool apply)
 {
 	Unit * pCaster = GetUnitCaster();
-	if(!pCaster)
+	if( pCaster == NULL || !m_target->IsPlayer() )
 		return;
 
 	int32 val;
 	val = mod->m_amount;
+
 	SM_FIValue(pCaster->SM_FEffectBonus,&val,m_spellProto->SpellGroupType);
 
 	if( apply )
@@ -6616,29 +7074,39 @@
 	else
 		val =- val;
 
-	if( m_target->IsPlayer() )
-	{	
-		for(uint32 x=0;x<7;x++)
+	uint32 stat = 3;
+	for(uint32 i=0; i < 3; i++)
+	{ //bit hacky but it will work with all currently available spells
+		if (m_spellProto->EffectApplyAuraName[i] == SPELL_AURA_INCREASE_SPELL_HEALING_PCT)
 		{
-			if (mod->m_miscValue & (((uint32)1)<<x) )
-			{
-				m_target->SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x, m_target->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x) + val);
-				static_cast< Player* >( m_target )->SpellDmgDoneBySpr[x]+=((float)(val))/100;
-			}
+			if (m_spellProto->EffectMiscValue[i] < 5)
+				stat = m_spellProto->EffectMiscValue[i];
+			else
+				return;
 		}
-		if( m_target->IsPlayer() )
-			static_cast< Player* >( m_target )->UpdateChanceFields();
 	}
+
+	for(uint32 x=0;x<7;x++)
+	{
+		if (mod->m_miscValue & (((uint32)1)<<x) )
+		{
+			m_target->SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x, m_target->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x) + float2int32(((float)val/100)*m_target->GetUInt32Value(UNIT_FIELD_STAT0 + stat)));
+			static_cast< Player* >( m_target )->SpellDmgDoneByAttribute[stat][x] += ((float)(val))/100;
+		}
+	}
+
+	static_cast< Player* >( m_target )->UpdateChanceFields();
 }
 
-void Aura::SpellAuraIncreaseHealingBySpr(bool apply)
+void Aura::SpellAuraIncreaseHealingByAttribute(bool apply)
 {
 	Unit * pCaster = GetUnitCaster();
-	if(!pCaster)
+	if( pCaster == NULL || !m_target->IsPlayer() )
 		return;
 
 	int32 val;
 	val = mod->m_amount;
+
 	SM_FIValue(pCaster->SM_FEffectBonus,&val,m_spellProto->SpellGroupType);
 
 	if( apply )
@@ -6651,21 +7119,22 @@
 	else
 		val =- val;
 
-	if( m_target->IsPlayer() )
-	{	
-		for(uint32 x=1;x<7;x++)
-		{
-		   // if (mod->m_miscValue & (((uint32)1)<<x) )
-			{
-				static_cast< Player* >( m_target )->SpellHealDoneBySpr[x]+=((float)(val))/100;
-			}
-		}
-		if( m_target->IsPlayer() )
-		{
-			static_cast< Player* >( m_target )->UpdateChanceFields();
-			m_target->SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, m_target->GetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS) + val);
-		}
+	uint32 stat;
+	if (mod->m_miscValue < 5)
+		stat = mod->m_miscValue;
+	else
+	{
+		sLog.outError(
+			"Aura::SpellAuraIncreaseHealingByAttribute::Unknown spell attribute type %u in spell %u.\n",
+			mod->m_miscValue,GetSpellId());
+		return;
 	}
+
+	for(uint32 x=1;x<7;x++)
+		static_cast< Player* >( m_target )->SpellHealDoneByAttribute[stat][x] += ((float)(val))/100;
+
+	m_target->SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, m_target->GetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS) + float2int32(((float)val/100)*m_target->GetUInt32Value(UNIT_FIELD_STAT0 + stat)));
+	static_cast< Player* >( m_target )->UpdateChanceFields();
 }
 
 void Aura::SpellAuraAddFlatModifier(bool apply)
@@ -6967,11 +7436,55 @@
 
 void Aura::SpellAuraIncreaseTimeBetweenAttacksPCT(bool apply)
 {
-	int32 val =  (apply) ? mod->m_amount : -mod->m_amount;
-	float pct_value = -val/100.0f;
-	m_target->ModFloatValue(UNIT_MOD_CAST_SPEED,pct_value);
+	if( mod->m_amount < 0 )
+		SetNegative();
+	else 
+		SetPositive();
+
+	float pct_value = mod->m_amount/100.0f;
+	
+	if( m_target->IsPlayer() )
+	{
+		if( apply )
+		{
+			static_cast< Player* >( m_target )->m_meleeattackspeedmod += mod->m_amount;
+			m_target->ModFloatValue(UNIT_MOD_CAST_SPEED, -pct_value);
+		}
+		else
+		{
+			static_cast< Player* >( m_target )->m_meleeattackspeedmod -= mod->m_amount;
+			m_target->ModFloatValue(UNIT_MOD_CAST_SPEED, pct_value);
+		}
+		static_cast< Player* >(m_target)->UpdateAttackSpeed();
+	}
+	else
+	{
+		if( apply )
+		{
+			mod->fixed_amount[0] = m_target->GetModPUInt32Value( UNIT_FIELD_BASEATTACKTIME, mod->m_amount );
+			mod->fixed_amount[1] = m_target->GetModPUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, mod->m_amount );
+
+			if( (int32)m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME ) <= mod->fixed_amount[0] )
+				mod->fixed_amount[0] = m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME );
+			if( (int32)m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME_01 ) <= mod->fixed_amount[1] )
+				mod->fixed_amount[1] = m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME_01 );
+
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME, -mod->fixed_amount[0] );
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, -mod->fixed_amount[1] );
+
+			m_target->ModFloatValue(UNIT_MOD_CAST_SPEED, -pct_value);
+		}
+		else
+		{
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME, mod->fixed_amount[0] );
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, mod->fixed_amount[1] );
+			m_target->ModFloatValue( UNIT_MOD_CAST_SPEED, pct_value);
+		}
+	}
+
 }
 
+/*
 void Aura::SpellAuraIncreaseSpellDamageByInt(bool apply)
 {
 	 float val;
@@ -7023,6 +7536,7 @@
 		}
 	}
 }
+*/
 void Aura::SpellAuraModAttackerCritChance(bool apply)
 {
 	int32 val  = (apply) ? mod->m_amount : -mod->m_amount;
@@ -7518,20 +8032,58 @@
 	}
 }
 
-void Aura::SpellAuraAxeSkillModifier(bool apply)
+void Aura::SpellAuraHealingByAttackPowerPct(bool apply)
 {
+	Unit * pCaster = GetUnitCaster();
+	if( pCaster == NULL || !m_target->IsPlayer() )
+		return;
+
+	int32 val = mod->m_amount;
+
+	if( apply )
+		SetPositive();
+	else
+		val =- val;
+
+	int32 bonus = float2int32(((float)val/100)*(m_target->GetUInt32Value(UNIT_FIELD_ATTACK_POWER)+ m_target->GetUInt32Value(UNIT_FIELD_ATTACK_POWER_MODS)));
+	m_target->SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, m_target->GetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS) + bonus);
+
+	for( uint32 x=1; x<7; x++ )
+		m_target->HealDoneMod[x] += bonus;
+}
+
+void Aura::SpellAuraDamageByAttackPowerPct(bool apply)
+{
+	Unit * pCaster = GetUnitCaster();
+	if( pCaster == NULL || !m_target->IsPlayer() )
+		return;
+
+	int32 val = mod->m_amount;
+
+	if( apply )
+		SetPositive();
+	else
+		val =- val;
+
+	int32 bonus = float2int32(((float)val/100)*(m_target->GetUInt32Value(UNIT_FIELD_ATTACK_POWER)+ m_target->GetUInt32Value(UNIT_FIELD_ATTACK_POWER_MODS)));
+	for( uint32 x=1; x<7; x++ )
+		m_target->SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x, m_target->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x) + bonus);
+}
+
+void Aura::SpellAuraModExpertise(bool apply)
+{
 	if( p_target != NULL )
 	{
 		SetPositive();
 		if( apply )
 		{
-			p_target->_ModifySkillBonus( SKILL_AXES, mod->m_amount );
-			p_target->_ModifySkillBonus( SKILL_2H_AXES, mod->m_amount );
+			p_target->ModUInt32Value( PLAYER_RATING_MODIFIER_EXPERTISE, mod->m_amount );
+			p_target->ModUInt32Value( PLAYER_EXPERTISE, mod->m_amount );
 		}
 		else
 		{
-			p_target->_ModifySkillBonus( SKILL_AXES, -mod->m_amount );
-			p_target->_ModifySkillBonus( SKILL_2H_AXES, -mod->m_amount );
+			p_target->ModUInt32Value( PLAYER_RATING_MODIFIER_EXPERTISE, -mod->m_amount );
+			p_target->ModUInt32Value( PLAYER_EXPERTISE, -mod->m_amount );
 		}
 		p_target->UpdateStats();
 	}
Index: ascent-world/SpellAuras.h
===================================================================
--- ascent-world/SpellAuras.h	(revision 3944)
+++ ascent-world/SpellAuras.h	(working copy)
@@ -213,8 +213,8 @@
     SPELL_AURA_DETECT_AMORE = 170,                      // Detect Amore
 	SPELL_AURA_MOD_PARTY_SPEED = 171,					// Party Speed Increase
     SPELL_AURA_INCREASE_MOVEMENT_AND_MOUNTED_SPEED = 172,// Increase Movement and Mounted Speed (Non-Stacking)
-    SPELL_AURA_INCREASE_SPELL_DAMAGE_PCT = 174,         // Increase Spell Damage by % Spirit (Spells
-    SPELL_AURA_INCREASE_SPELL_HEALING_PCT = 175,        // Increase Spell Healing by % Spirit
+    SPELL_AURA_INCREASE_SPELL_DAMAGE_PCT = 174,         // Increase Spell Damage by % status
+    SPELL_AURA_INCREASE_SPELL_HEALING_PCT = 175,        // Increase Spell Healing by % status
     SPELL_AURA_SPIRIT_OF_REDEMPTION = 176,              // Spirit of Redemption Auras
     SPELL_AURA_AREA_CHARM = 177,                        // Area Charm 
     SPELL_AURA_INCREASE_ATTACKER_SPELL_CRIT = 179,      // Increase Attacker Spell Crit Type
@@ -231,8 +231,8 @@
     SPELL_AURA_SPEED_LIMIT = 191,                       // speed limit
     SPELL_AURA_MELEE_SLOW_PCT = 192,
     SPELL_AURA_INCREASE_TIME_BETWEEN_ATTACKS = 193,
-    SPELL_AURA_INREASE_SPELL_DAMAGE_PCT_OF_INTELLECT = 194,
-    SPELL_AURA_INCREASE_HEALING_PCT_OF_INTELLECT = 195,
+    SPELL_AURA_INREASE_SPELL_DAMAGE_PCT_OF_INTELLECT = 194,  // NOT USED ANYMORE - 174 used instead
+    SPELL_AURA_INCREASE_HEALING_PCT_OF_INTELLECT = 195,		// NOT USED ANYMORE - 175 used instead
     SPELL_AURA_MOD_ALL_WEAPON_SKILLS = 196,
     SPELL_AURA_REDUCE_ATTACKER_CRICTICAL_HIT_CHANCE_PCT = 197,
     SPELL_AURA_MOD_ALL_WEAPON_SKILLS_2 = 198,
@@ -317,7 +317,7 @@
 //    SpellEntry *ospinfo;
 //    SpellEntry *spinfo;
     uint32 LastTrigger;
-	uint32 ProcType; //0=talents/spells 1=weapon 2=armor  TODO: implement.
+	uint32 ProcType; //0=talents/spells 1=weapon 2=armor
     bool deleted;
 };
 
@@ -336,7 +336,7 @@
 {
 	uint64 periodic_target;
 public:
-    Aura(SpellEntry *proto, int32 duration,Object* caster, Unit *target);
+    Aura(SpellEntry *proto, int32 duration,Object* caster, Unit *target, Item* i_caster = NULL );
 	void ExpireRemove();
     void Remove();
     void Expire();
@@ -532,8 +532,8 @@
 	void SpellAuraIncreaseDamageTypePCT(bool apply);
 	void SpellAuraIncreaseCricticalTypePCT(bool apply);
 	void SpellAuraIncreasePartySpeed(bool apply);
-	void SpellAuraIncreaseSpellDamageBySpr(bool apply);
-	void SpellAuraIncreaseHealingBySpr(bool apply);
+	void SpellAuraIncreaseSpellDamageByAttribute(bool apply);
+	void SpellAuraIncreaseHealingByAttribute(bool apply);
 	void SpellAuraIncreaseArmorByPctInt(bool apply);
 	void SpellAuraReduceAttackerMHitChance(bool apply);
 	void SpellAuraReduceAttackerRHitChance(bool apply);
@@ -541,8 +541,8 @@
 	void SpellAuraReduceEnemyMCritChance(bool apply);
 	void SpellAuraReduceEnemyRCritChance(bool apply);
 	void SpellAuraIncreaseTimeBetweenAttacksPCT(bool apply);
-	void SpellAuraIncreaseSpellDamageByInt(bool apply);
-	void SpellAuraIncreaseHealingByInt(bool apply);
+	//void SpellAuraIncreaseSpellDamageByInt(bool apply);
+	//void SpellAuraIncreaseHealingByInt(bool apply);
 	void SpellAuraIncreaseAllWeaponSkill(bool apply);
 	void SpellAuraModAttackerCritChance(bool apply);
 	void SpellAuraIncreaseHitRate(bool apply);
@@ -566,8 +566,11 @@
 	//void SpellAuraModRangedDamageTakenPCT(bool apply);
 	void SpellAuraModBlockValue(bool apply);
 	void SpellAuraFinishingMovesCannotBeDodged(bool apply);
-	void SpellAuraAxeSkillModifier(bool apply);
+	void SpellAuraHealingByAttackPowerPct(bool apply);
+	void SpellAuraDamageByAttackPowerPct(bool apply);
 
+	void SpellAuraModExpertise(bool apply);
+
 	void SendModifierLog(int32 ** m,int32 v,uint64 mask,uint8 type,bool pct = false);
 	void SendDummyModifierLog(std::map<SpellEntry*,uint32> * m,SpellEntry * spellInfo,uint32 i,bool apply,bool pct = false);
 
Index: ascent-world/SpellEffects.cpp
===================================================================
--- ascent-world/SpellEffects.cpp	(revision 3944)
+++ ascent-world/SpellEffects.cpp	(working copy)
@@ -241,37 +241,31 @@
 			return;
 		}break;
 	case 18788: //Demonic Sacrifice (508745)
-		uint32 spellid1 = 0;
-		switch(unitTarget->GetEntry())
 		{
-			case 416: //Imp
-			{   
-				spellid1 = 18789;
-		
-			}break;
-			case 417: //Felhunter
+			uint32 spellid1 = 0;
+			switch(unitTarget->GetEntry())
 			{
-				spellid1 = 18792;
-		
-			}break;
-			case 1860: //VoidWalker
-			{
-				spellid1 = 18790;
-			}break;
-			case 1863: //Succubus
-			{
-				spellid1 = 18791;
-			}break;
-			case 17252: //felguard
-			{
-				spellid1 = 35701;
-			}break;
-		}
-		//now caster gains this buff
-		if( spellid1 > 0 )
-		{
-			u_caster->CastSpell( u_caster, dbcSpell.LookupEntry( spellid1 ), true );
-		}
+				case 416: //Imp  
+					spellid1 = 18789;
+				break;
+				case 417: //Felhunter
+					spellid1 = 18792;
+				break;
+				case 1860: //VoidWalker
+					spellid1 = 18790;
+				break;
+				case 1863: //Succubus
+					spellid1 = 18791;
+				break;
+				case 17252: //felguard
+					spellid1 = 35701;
+				break;
+			}
+			//now caster gains this buff
+			if( spellid1 != 0 )
+				u_caster->CastSpell( u_caster, dbcSpell.LookupEntry( spellid1 ), true );
+
+		}break;
 	}
 
 	//instant kill effects don't have a log
@@ -395,7 +389,20 @@
 		else 
 		{
 			if( u_caster != NULL )
-				u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, 0, 0, dmg, pSpellId == 0, true );
+			{
+				uint32 _type;
+				if( GetType() == SPELL_DMG_TYPE_RANGED )
+					_type = RANGED;
+				else
+				{
+					if (m_spellInfo->Flags4 & 0x1000000)
+						_type =  OFFHAND;
+					else
+						_type = MELEE;
+				}
+				u_caster->Strike( unitTarget, _type, m_spellInfo, 0, 0, dmg, pSpellId == 0, true );
+
+			}
 		}
 	}   
 }
@@ -410,6 +417,119 @@
 
 	switch( spellId )
 	{
+
+	case 5420: //Tree of Life
+		{
+			if( unitTarget == NULL )
+				return;
+
+			SpellEntry *spellInfo = dbcSpell.LookupEntry( 34123 );
+
+			Spell *sp = new Spell( unitTarget, spellInfo, true, NULL );
+			SpellCastTargets tgt;
+			tgt.m_unitTarget = unitTarget->GetGUID();
+			sp->prepare(&tgt);
+
+		} break;
+	case 5938: //shiv
+		{
+			if( p_caster == NULL || unitTarget == NULL )
+				return;
+
+			p_caster->Strike( unitTarget, OFFHAND, m_spellInfo, 0, 0, 0, false, true );
+			p_caster->AddComboPoints( unitTarget->GetGUID(), 1 );
+
+			if( p_caster->GetItemInterface() )
+			{
+				Item *it = p_caster->GetItemInterface()->GetInventoryItem( EQUIPMENT_SLOT_OFFHAND );
+				if( it == NULL )
+					return;
+		
+				EnchantmentInstance * ench = it->GetEnchantment( 1 ); // temp enchantment slot
+				if(ench)
+				{
+					EnchantEntry* Entry = ench->Enchantment;
+					for( uint32 c = 0; c < 3; c++ )
+					{
+						if( Entry->type[c] && Entry->spell[c] )
+						{
+							SpellEntry *sp = dbcSpell.LookupEntry( Entry->spell[c] );
+							if( sp == NULL )
+								return;
+
+							if( sp->c_is_flags & SPELL_FLAG_IS_POISON )
+							{
+								SpellCastTargets targets( unitTarget->GetGUID() );
+								Spell *spell = new Spell( p_caster, sp, true, 0 );
+								spell->prepare( &targets );
+							}
+						}
+					}
+				}
+			}
+
+		} break;
+	case 30427: // Extract Gas
+		{
+			bool check = false;
+			uint32 cloudtype;
+			Creature *creature;
+
+			if(!p_caster)
+				return;
+
+			for(Object::InRangeSet::iterator i = p_caster->GetInRangeSetBegin(); i != p_caster->GetInRangeSetEnd(); ++i)
+			{
+				if((*i)->GetTypeId() == TYPEID_UNIT)
+				{
+					creature=static_cast<Creature *>((*i));
+					cloudtype=creature->GetEntry();
+					if(cloudtype == 24222 || cloudtype == 17408 || cloudtype == 17407 || cloudtype == 17378)
+					{
+						if(p_caster->GetDistance2dSq((*i)) < 400)
+						{
+							p_caster->SetSelection(creature->GetGUID());
+							check = true;
+							break;
+						}
+					}
+				}
+			}
+			
+			if(check)
+			{
+				uint32 item,count = 3+(rand()%3);
+			
+				if (cloudtype==24222) item=22572;//-air
+				if (cloudtype==17408) item=22576;//-mana
+				if (cloudtype==17407) item=22577;//-shadow
+				if (cloudtype==17378) item=22578;//-water
+
+				Item *add = p_caster->GetItemInterface()->FindItemLessMax(item, count, false);
+				if (!add)
+				{
+					ItemPrototype* proto = ItemPrototypeStorage.LookupEntry(item);
+					SlotResult slotresult;
+
+					slotresult = p_caster->GetItemInterface()->FindFreeInventorySlot(proto);
+					if(!slotresult.Result)
+					{
+						p_caster->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+						return;
+					}
+					Item * it=objmgr.CreateItem(item,p_caster);  
+					it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
+					p_caster->GetItemInterface()->SafeAddItem(it,slotresult.ContainerSlot, slotresult.Slot);
+					creature->Despawn(3500,creature->proto->RespawnTime);
+				}
+				else
+				{
+					add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + count);
+					add->m_isDirty = true;
+					creature->Despawn(3500,creature->proto->RespawnTime);
+				}
+			}
+		}break; 
 /*	case 35029: //hunter: Focused Fire
 	case 35030:
 		{
@@ -547,6 +667,9 @@
 			if( !unitTarget || !p_caster) 
 				return;
 
+			if(!unitTarget->isAlive() || unitTarget->getClass()==WARRIOR || unitTarget->getClass() == ROGUE)
+				return;
+
 			uint32 count = 0;
 			for(uint32 x = 0; x < MAX_AURAS; ++x)
 			{
@@ -558,13 +681,16 @@
 			}
 
 			uint32 gain = (uint32)(count * (2.17*p_caster->getLevel()+9.136));
-			uint32 max = unitTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1);
-			if( unitTarget->GetUInt32Value( UNIT_FIELD_POWER1 ) + gain > max )
-				unitTarget->SetUInt32Value( UNIT_FIELD_POWER1, max );
-			else
-				unitTarget->SetUInt32Value( UNIT_FIELD_POWER1, unitTarget->GetUInt32Value( UNIT_FIELD_POWER1 ) + gain );
-			SendHealManaSpellOnPlayer( p_caster, static_cast< Player* >( unitTarget ), gain, 0 );
+			p_caster->Energize(unitTarget,28730,gain,POWER_TYPE_MANA);
 		}break;
+	case 39610://Mana Tide
+		{
+			if(unitTarget == NULL || unitTarget->isDead() || unitTarget->getClass()==WARRIOR || unitTarget->getClass() == ROGUE)
+				return;
+
+			uint32 gain = (uint32) (unitTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1)*0.06);
+			unitTarget->Energize(unitTarget,16191,gain,POWER_TYPE_MANA);
+		}break;
 	case 4141:// Summon Myzrael
 		{
 			//2755
@@ -1109,6 +1235,7 @@
 			ILotP.procFlags = PROC_ON_CRIT_ATTACK | PROC_TARGET_SELF;
 			ILotP.deleted = false;
 			ILotP.caster = u_caster->GetGUID();
+			ILotP.ProcType = 0;
 			ILotP.LastTrigger = 0;
 			u_caster->m_procSpells.push_back(ILotP);
 		}
@@ -1162,8 +1289,7 @@
 		{
 			/* try to get a selection */
  			unitTarget = m_caster->GetMapMgr()->GetUnit(p_caster->GetSelection());
-//			if( (unitTarget == NULL ) || !isHostile(p_caster, unitTarget) || (unitTarget->CalcDistance(p_caster) > 25.0f)) //removed by Zack : no idea why hostile is used. Isattackable should give a wider solution range
-			if( (unitTarget == NULL ) || !isAttackable(p_caster, unitTarget, !(m_spellInfo->c_is_flags & SPELL_FLAG_IS_TARGETINGSTEALTHED) ) || (unitTarget->CalcDistance(p_caster) > 25.0f))
+			if(unitTarget == NULL || (unitTarget->CalcDistance(p_caster) > 33.0f))
 				return;
 		}
 
@@ -1190,12 +1316,12 @@
 		}
 
 		// avoid teleporting into the model on scaled models
-		const static float shadowstep_distance = 1.6f * unitTarget->GetFloatValue(OBJECT_FIELD_SCALE_X);
+		const static float shadowstep_distance = 1.35f * max(unitTarget->GetFloatValue(OBJECT_FIELD_SCALE_X), 1.0f);
 		float new_x = unitTarget->GetPositionX() - (shadowstep_distance * cosf(ang));
 		float new_y = unitTarget->GetPositionY() - (shadowstep_distance * sinf(ang));
 		
 		/* Send a movement packet to "charge" at this target. Similar to warrior charge. */
-		p_caster->SafeTeleport(p_caster->GetMapId(), p_caster->GetInstanceID(), LocationVector(new_x, new_y, (unitTarget->GetPositionZ() + 0.1f), unitTarget->GetOrientation()));
+		p_caster->SafeTeleport(p_caster->GetMapId(), p_caster->GetInstanceID(), LocationVector(new_x, new_y, (unitTarget->GetPositionZ() + 0.2f), unitTarget->GetOrientation()));
 		
 		return;
 	}
@@ -1212,28 +1338,124 @@
 		return;
 
 	// can't apply stuns/fear/polymorph/root etc on boss
-	if( !unitTarget->IsPlayer() )
-	{
-		Creature* c = static_cast< Creature* >( unitTarget );
-		if( c != NULL && c->GetCreatureName() && c->GetCreatureName()->Rank == ELITE_WORLDBOSS )
-		{
-			switch( m_spellInfo->EffectApplyAuraName[i] )
-			{
-			case 5:  // confuse
-			case 6:  // charm
-			case 7:  // fear
-			case 12: // stun
-			case 25: // pacify
-			case 26: // root
-			case 27: // silence
-			case 31: // increase speed
-			case 33: // decrease speed
-				SendCastResult( SPELL_FAILED_IMMUNE );
-				return;
-			}
-		}
-	}
+	if (!unitTarget->IsPlayer())
+ 	{
+		if (u_caster && (u_caster != unitTarget))
+ 		{
+			Creature * c = (Creature*)( unitTarget );
+			if (c)
+ 			{
 
+				/*
+				Charm (Mind Control, enslave demon): 1
+				Confuse (Blind etc): 2
+				Fear: 4
+				Root: 8
+				Silence : 16
+				Stun: 32
+				Sheep: 64
+				Banish: 128
+				Taunt (applyaura): 256
+				Decrease Speed (Hamstring) (applyaura): 512
+				Spell Haste (Curse of Tongues) (applyaura): 1024
+				Interupt Cast: 2048
+				Mod Healing % (Mortal Strike) (applyaura):4096
+				*/
+
+				//Spells with Mechanic also add other ugly auras, but if the main aura is the effect --> immune to whole spell
+				if (c->proto && c->proto->modImmunities)
+				{
+					bool immune = false;
+					if (m_spellInfo->MechanicsType)
+					{
+						switch(m_spellInfo->MechanicsType)
+						{
+						case MECHANIC_CHARMED:
+							if (c->proto->modImmunities & 1)
+								immune = true;
+							break;
+						case MECHANIC_DISORIENTED:
+							if (c->proto->modImmunities & 2)
+								immune = true;
+							break;
+						case MECHANIC_FLEEING:
+							if (c->proto->modImmunities & 4)
+								immune = true;
+							break;
+						case MECHANIC_ROOTED:
+							if (c->proto->modImmunities & 8)
+								immune = true;
+							break;
+						case MECHANIC_SILENCED:
+							if ( c->proto->modImmunities & 16)
+								immune = true;
+							break;
+						case MECHANIC_STUNNED:
+							if (c->proto->modImmunities & 32)
+								immune = true;
+							break;
+						case MECHANIC_POLYMORPHED:
+							if (c->proto->modImmunities & 64)
+								immune = true;
+							break;
+						case MECHANIC_BANISHED:
+							if (c->proto->modImmunities & 128)
+								immune = true;
+							break;
+						}
+					}
+					else
+					{
+						// Spells wich do more than just one thing (damage and the effect) dont have a mechanic and we should only cancel the aura to be placed
+						switch (m_spellInfo->EffectApplyAuraName[i])
+						{
+						case SPELL_AURA_MOD_CONFUSE:
+							if (c->proto->modImmunities & 2)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_FEAR:
+							if (c->proto->modImmunities & 4)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_TAUNT:
+							if (c->proto->modImmunities & 256)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_STUN: // no idea if its needed, just to be sure
+							if (c->proto->modImmunities & 32)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_SILENCE:
+							if ((c->proto->modImmunities & 2048) || (c->proto->modImmunities & 16))
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_DECREASE_SPEED:
+							if (c->proto->modImmunities & 512)
+								immune = true;
+							break;
+						case SPELL_AURA_INCREASE_CASTING_TIME_PCT:
+							if (c->proto->modImmunities & 1024)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_LANGUAGE: //hacky way to prefer that the COT icon is set to mob
+							if (c->proto->modImmunities & 1024)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_HEALING_DONE_PERCENT:
+							if (c->proto->modImmunities & 4096)
+								immune = true;
+							break;
+						}
+					}
+					if (immune)
+					{
+						return;
+					}
+				}
+ 			}
+ 		}
+ 	}
+
 	// avoid map corruption.
 	if( unitTarget->GetInstanceID() != m_caster->GetInstanceID() )
 		return;
@@ -1260,7 +1482,7 @@
 		if( g_caster != NULL && g_caster->GetUInt32Value( OBJECT_FIELD_CREATED_BY ) && g_caster->m_summoner != NULL )
 			pAura = new Aura( m_spellInfo, Duration, g_caster->m_summoner, unitTarget);
 		else
-			pAura = new Aura( m_spellInfo, Duration, m_caster, unitTarget );
+			pAura = new Aura( m_spellInfo, Duration, m_caster, unitTarget, i_caster );
 
 		pAura->pSpellId = pSpellId; //this is required for triggered spells
 		
@@ -1281,7 +1503,11 @@
 
 	uint32 powerField = UNIT_FIELD_POWER1+m_spellInfo->EffectMiscValue[i];
 	uint32 curPower = unitTarget->GetUInt32Value(powerField);
-	uint32 amt=damage+((u_caster->GetDamageDoneMod(m_spellInfo->School)*80)/100);
+	uint32 amt;
+	if (m_spellInfo->NameHash == SPELL_HASH_DARK_PACT)
+		amt=damage+((u_caster->GetDamageDoneMod(m_spellInfo->School)*96)/100);
+	else
+		amt=damage;
 	if(amt>curPower)
 	{
 		amt=curPower;
@@ -1504,7 +1730,20 @@
 				m_spellInfo, (uint32)damage, EVENT_SPELL_DAMAGE_HIT, float2int32(time), 1, EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
 	}
 	else
-		u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, damage, 0, 0, false, true );
+	{
+
+		uint32 _type;
+		if( GetType() == SPELL_DMG_TYPE_RANGED )
+			_type = RANGED;
+		else
+		{
+			if (m_spellInfo->Flags4 & 0x1000000)
+				_type =  OFFHAND;
+			else
+				_type = MELEE;
+		}
+		u_caster->Strike( unitTarget, _type, m_spellInfo, damage, 0, 0, false, true );
+	}
 }
 
 void Spell::SpellEffectAddExtraAttacks(uint32 i) // Add Extra Attacks
@@ -1590,24 +1829,85 @@
 
 		if (skill && skill->skilline == SKILL_ALCHEMY)
 		{
+			// potions learned by discovery variables
+			uint32 cast_chance = 5;
+			uint32 learn_spell = 0;
+
 			//Potion Master
 			if (strstr(m_itemProto->Name1, "Potion"))
 			{
 				if(p_caster->HasSpell(28675)) 
 					while (Rand(20) && item_count<10) item_count++;
+
+				// Super Rejuvenation Potion
+				cast_chance = 2;
+				learn_spell = 28586;
 			}
-			//Elixir Master
+			//Elixirs
 			if (strstr(m_itemProto->Name1, "Elixir") || strstr(m_itemProto->Name1, "Flask"))
 			{
-				if(p_caster->HasSpell(28677)) 
+				if(p_caster->HasSpell(28677)) //Elixir Master
 					while (Rand(20) && item_count<10) item_count++;
+
+				uint32 spList[] = {28590,28587,28588,28591,28589};
+				cast_chance = 2;
+				learn_spell = spList[RandomUInt(4)];
 			}
-			//Transmutation Master
+			 //Transmutation
 			if (m_spellInfo->Category == 310)
 			{
-				if(p_caster->HasSpell(28672)) 
+				if(p_caster->HasSpell(28672))  //Transmutation Master
 					while (Rand(20) && item_count<10) item_count++;
+
+				uint32 spList[] = {28581,28585,28585,28584,28582,28580};
+				cast_chance = 5;
+				learn_spell = spList[RandomUInt(5)];
 			}
+
+			//random discovery by crafter item id
+			switch ( m_itemProto->ItemId )
+			{
+			case 22845: //Major Arcane Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41458;
+				}break;
+			case 22841: //Major Fire Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41500;
+				}break;
+			case 22842: //Major Frost Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41501;
+				}break;
+			case 22847: //Major Holy Protection Potion
+				{
+					// there is none
+				}break;
+			case 22844: //Major Nature Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41502;
+				}break;
+			case 22846: //Major Shadow Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41503;
+				}break;
+			}
+
+			if ( learn_spell && p_caster->getLevel() > 60 && !p_caster->HasSpell( learn_spell ) && Rand( cast_chance ) )
+			{
+				SpellEntry* _spellproto = dbcSpell.LookupEntry( learn_spell );
+				if( _spellproto != NULL )
+				{
+					p_caster->BroadcastMessage( "%sDISCOVERY! You discovered the %s !|r", MSG_COLOR_YELLOW, _spellproto->Name );
+					p_caster->addSpell( learn_spell );
+				}
+			}
+
 		}
 
 		// item count cannot be more than allowed in a single stack
@@ -1950,8 +2250,22 @@
 	       pCreature->SetUInt32Value(UNIT_FIELD_LEVEL, p_caster->getLevel());
 	       pCreature->SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, p_caster->GetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE));
 	       pCreature->_setFaction();
+		   pCreature->SetUInt64Value(UNIT_FIELD_SUMMONEDBY, p_caster->GetGUID());
+		   pCreature->SetUInt64Value(UNIT_FIELD_CREATEDBY, p_caster->GetGUID());
 	       p_caster->SetUInt64Value(UNIT_FIELD_SUMMON, pCreature->GetGUID());
+		  
 	       p_caster->m_tempSummon = pCreature;
+
+		   if ( m_spellInfo->EffectMiscValue[i] == 19668 ) //shadowfiend
+			{
+				float parent_bonus = (float)(p_caster->GetDamageDoneMod(SCHOOL_SHADOW)*0.065f);
+				pCreature->SetFloatValue(UNIT_FIELD_MINDAMAGE, pCreature->GetFloatValue(UNIT_FIELD_MINDAMAGE) + parent_bonus);
+				pCreature->SetFloatValue(UNIT_FIELD_MAXDAMAGE, pCreature->GetFloatValue(UNIT_FIELD_MAXDAMAGE) + parent_bonus);
+				pCreature->BaseDamage[0] += parent_bonus;
+				pCreature->BaseDamage[1] += parent_bonus;
+				//TODO add avoidance chance 75%
+			}
+
 	       pCreature->PushToWorld(p_caster->GetMapMgr());
 
 	       /*if(p_caster->isInCombat())
@@ -1962,7 +2276,7 @@
 	       }*/
 	       
 	       /* not sure on this */
-	       sEventMgr.AddEvent(pCreature, &Creature::SafeDelete, EVENT_CREATURE_REMOVE_CORPSE, /*GetDuration()*/45000, 1, 0);
+	       sEventMgr.AddEvent(pCreature, &Creature::SafeDelete, EVENT_CREATURE_REMOVE_CORPSE, GetDuration()+2000 /*45000*/, 1, 0);
 	}
 }
 
@@ -2132,7 +2446,19 @@
 		u_caster->SpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, dmg, false, false, false);
 	}
 	else
-		u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, add_damage, damage, 0, false, true );
+	{
+		uint32 _type;
+		if( GetType() == SPELL_DMG_TYPE_RANGED )
+			_type = RANGED;
+		else
+		{
+			if (m_spellInfo->Flags4 & 0x1000000)
+				_type =  OFFHAND;
+			else
+				_type = MELEE;
+		}
+		u_caster->Strike( unitTarget, _type, m_spellInfo, add_damage, damage, 0, false, true );
+	}
 }
 
 void Spell::SpellEffectTriggerMissile(uint32 i) // Trigger Missile
@@ -2228,9 +2554,9 @@
 		}
 		case LOCKTYPE_HERBALISM:
 		{
-			if(!gameObjTarget ) return;	  
+			if( !gameObjTarget ) return;	  
 			
-			uint32 v=GetGOReqSkill(gameObjTarget);
+			uint32 v = gameObjTarget->GetGOReqSkill();
 			bool bAlreadyUsed = false;
 		 
 			if(Rand(100.0f)) // 3% chance to fail//why?
@@ -2274,7 +2600,7 @@
 		{
 			if(!gameObjTarget ) return;
 
-			uint32 v = GetGOReqSkill(gameObjTarget);
+			uint32 v = gameObjTarget->GetGOReqSkill();
 			bool bAlreadyUsed = false;
 
 			if( Rand( 100.0f ) ) // 3% chance to fail//why?
@@ -2499,7 +2825,7 @@
 	std::map< uint32, Aura* >::iterator itr = unitTarget->tmpAura.find( m_spellInfo->Id );
 	if( itr == unitTarget->tmpAura.end() )
 	{
-		pAura = new Aura( m_spellInfo, GetDuration(), m_caster, unitTarget );
+		pAura = new Aura( m_spellInfo, GetDuration(), m_caster, unitTarget, i_caster  );
 
 		//unitTarget->tmpAura[m_spellInfo->Id] = pAura;
 		unitTarget->tmpAura.insert( make_pair( m_spellInfo->Id, pAura ) );
@@ -2649,7 +2975,7 @@
 		pPet->AddSpell( dbcSpell.LookupEntry( m_spellInfo->EffectTriggerSpell[i] ), true );
 
 		// Send Packet
-		WorldPacket data(SMSG_PET_LEARNT_SPELL, 21);
+		WorldPacket data(SMSG_SET_AURA_SINGLE, 21);
 		data << pPet->GetGUID() << uint8(0) << uint32(m_spellInfo->EffectTriggerSpell[i]) << uint32(-1) << uint32(0);
 		p_caster->GetSession()->SendPacket(&data);
 	}
@@ -3019,7 +3345,6 @@
 	}
 	else
 	{
-		//portal, lightwell
 		posx = px;
 		posy = py;		
 		GameObjectInfo* goI = GameObjectNameStorage.LookupEntry(entry);
@@ -3071,10 +3396,17 @@
 			go->m_ritualtarget = pTarget->GetGUIDLow();
 			go->m_ritualspell = m_spellInfo->Id;	 
 		}
-		else//Lightwell,if there is some other type -- add it
+		else if( entry == 186811 || entry == 181622) // Portal for Ritual of Refreshment/Souls
 		{
-			go->charges=5;//Max 5 charges
+			go->m_ritualmembers[0] = p_caster->GetGUIDLow();
+			go->m_ritualcaster = p_caster->GetGUIDLow();
+			go->m_ritualspell = m_spellInfo->Id;	 
 		}
+		else
+		{
+			go->charges = goI->sound1;
+		}
+		
 		p_caster->SetSummonedObject(go);		
 	}
 }
@@ -3159,72 +3491,69 @@
 
 void Spell::SpellEffectSummonPet(uint32 i) //summon - pet
 {
-	uint32 entry = m_spellInfo->EffectMiscValue[i];
-	CreatureInfo *ci = CreatureNameStorage.LookupEntry(entry);
-	CreatureProto *cp = CreatureProtoStorage.LookupEntry(entry);
-	if (ci == NULL || cp == NULL)
-		return;
+    uint32 entry = m_spellInfo->EffectMiscValue[i];
+    CreatureInfo *ci = CreatureNameStorage.LookupEntry(entry);
+    switch(m_spellInfo->Id)
+     {
+        case 883:// "Call Pet"
+        {        
+            if(!p_caster || p_caster->getClass() != HUNTER)
+                break;
+            if(p_caster->GetSummon() != 0)
+            {
+                p_caster->GetSession()->SendNotification("You already have a pet summoned.");
+                break;
+            }
+            uint32 petno = p_caster->GetUnstabledPetNumber();
+            if(petno)
+            {
+                p_caster->SpawnPet(petno);
+            }
+            else
+            {
+                WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 50);
+                data << uint32(0) << "You do not have any pets to call." << uint8(0);
+                p_caster->GetSession()->SendPacket(&data);
+            }
+        }break;
+        case 688:// "Summon Imp"
+        case 697:// "Summon Voidwalker"
+        case 712:// "Summon Succubus"
+        case 691:// "Summon Felhunter"
+        case 30146:// "Summon Felguard"
+         {
+           //VoidWalker:torment, sacrifice, suffering, consume shadows
+            //Succubus:lash of pain, soothing kiss, seduce , lesser invisibility
+            //felhunter:     Devour Magic,Paranoia,Spell Lock,    Tainted Blood
+            if(!p_caster || p_caster->getClass() != WARLOCK)
+                break;
 
-	switch(m_spellInfo->Id)
-	{
-	case 883:// "Call Pet"
-		{		
-			if(!p_caster)
-				return; 
-			if(p_caster->GetSummon() != 0)
-			{
-				p_caster->GetSession()->SendNotification("You already have a pet summoned.");
-				return;
-			}
-			uint32 petno = p_caster->GetUnstabledPetNumber();
-			if(petno)
-				p_caster->SpawnPet(petno);
-			else
-			{
-				WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 50);
-				data << uint32(0) << "You do not have any pets to call." << uint8(0);
-				p_caster->GetSession()->SendPacket(&data);
-			}
-		}break;
-	case 688:// "Summon Imp"
-	case 697:// "Summon Voidwalker"
-	case 712:// "Summon Succubus"
-	case 691:// "Summon Felhunter"
-	case 30146:// "Summon Felguard"
-		{
-			//VoidWalker:torment, sacrifice, suffering, consume shadows
-			//Succubus:lash of pain, soothing kiss, seduce , lesser invisibility
-			//felhunter:	 Devour Magic,Paranoia,Spell Lock,	Tainted Blood
-			if(!p_caster || !u_caster)
-				return;
-			// remove old pet
-			Pet *old = static_cast<Player*>(m_caster)->GetSummon();
-			if(old)
-				old->Dismiss(false);
+            // remove old pet
+            Pet *old = static_cast<Player*>(m_caster)->GetSummon();
+            if(old)
+                old->Dismiss(false);
 
-			p_caster->RemoveAura(18789);
-			p_caster->RemoveAura(18790);
-			p_caster->RemoveAura(18791);
-			p_caster->RemoveAura(18792);
-			p_caster->RemoveAura(35701);
-
-			Pet *summon = objmgr.CreatePet();
-			summon->SetInstanceID(m_caster->GetInstanceID());
-			summon->CreateAsSummon(m_spellInfo->EffectMiscValue[i], ci, NULL, u_caster, m_spellInfo, 1, 0);
-		}break;
-	default:
-		{
-			if( u_caster == NULL )
-				return;
-			if( u_caster->summonPet )
-			{
-				u_caster->summonPet->RemoveFromWorld(false,true);
-				delete u_caster->summonPet;
-				u_caster->summonPet = NULL;
-			}			
-			u_caster->create_guardian(entry, -1, (float(-(M_PI/2))));
-		}break;
-	}
+            p_caster->RemoveAura(18789);
+            p_caster->RemoveAura(18790);
+            p_caster->RemoveAura(18791);
+            p_caster->RemoveAura(18792);
+            p_caster->RemoveAura(35701);
+            
+            Pet *summon = objmgr.CreatePet();
+            summon->SetInstanceID(m_caster->GetInstanceID());
+            summon->CreateAsSummon(m_spellInfo->EffectMiscValue[i], ci, NULL, u_caster, m_spellInfo, 1, 0);
+        }break;
+        default:
+         {
+            if(u_caster->summonPet)
+            {
+                u_caster->summonPet->RemoveFromWorld(false,true);
+                delete u_caster->summonPet;
+                u_caster->summonPet = NULL;
+            }            
+            u_caster->create_guardian(entry, -1, (float(-(M_PI/2))));
+        }break;
+     }
 }
 
 void Spell::SpellEffectWeapondamage( uint32 i ) // Weapon damage +
@@ -3232,8 +3561,8 @@
 	if( unitTarget == NULL || u_caster == NULL )
 		return;
 
-	//Hackfix for Mangle and Hemorrhage
-	if( (m_spellInfo->NameHash == SPELL_HASH_MANGLE__CAT_ || m_spellInfo->NameHash == SPELL_HASH_HEMORRHAGE) && u_caster->IsPlayer() )
+	//Hackfix for Mangle
+	if( m_spellInfo->NameHash == SPELL_HASH_MANGLE__CAT_ && u_caster->IsPlayer() )
 			static_cast< Player* >( u_caster )->AddComboPoints( unitTarget->GetGUID(), 1 );
 
 	// Hacky fix for druid spells where it would "double attack".
@@ -3242,7 +3571,19 @@
 		add_damage += damage;
 		return;
 	}
-	u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, damage, 0, 0, false, true );
+	
+	uint32 _type;
+	if( GetType() == SPELL_DMG_TYPE_RANGED )
+		_type = RANGED;
+	else
+	{
+		if (m_spellInfo->Flags4 & 0x1000000)
+			_type =  OFFHAND;
+		else
+			_type = MELEE;
+	}
+
+	u_caster->Strike( unitTarget, _type, m_spellInfo, damage, 0, 0, false, true );
 }
 
 void Spell::SpellEffectPowerBurn(uint32 i) // power burn
@@ -3273,7 +3614,7 @@
 	if(!unitTarget)
 		return;
 
-	Spell*sp=new Spell(m_caster,dbcSpell.LookupEntry(m_spellInfo->EffectTriggerSpell[i]),true,NULL);
+	Spell* sp = new Spell(m_caster,dbcSpell.LookupEntry(m_spellInfo->EffectTriggerSpell[i]),true,NULL);
 	SpellCastTargets tgt(unitTarget->GetGUID());
 	sp->prepare(&tgt);
 
@@ -3323,9 +3664,15 @@
 	// can't apply stuns/fear/polymorph/root etc on boss
 	if(unitTarget->GetTypeId()==TYPEID_UNIT)
 	{
-		Creature * c = (Creature*)( unitTarget );
-		if (c&&c->GetCreatureName()&&c->GetCreatureName()->Rank == ELITE_WORLDBOSS)
-			return;
+		if (u_caster && (u_caster != unitTarget))
+		{
+			Creature *c = (Creature*)( unitTarget );
+			if (c && c->proto && c->proto->modImmunities)
+			{
+				if (c->proto->modImmunities & 2048)
+						return;
+			}
+		}
 	}
 	// FIXME:This thing prevent target from spell casting too but cant find.
 	uint32 school=0;
@@ -3374,7 +3721,7 @@
 		return;
 
 	Creature *target = static_cast<Creature*>( unitTarget );
-	if(target->IsPickPocketed() || (target->GetCreatureName() && target->GetCreatureName()->Type != HUMANOID))
+	if(target->IsPickPocketed() || !lootmgr.IsPickpocketable( target->GetEntry() ) )
 	{
 		SendCastResult(SPELL_FAILED_TARGET_NO_POCKETS);
 		return;
@@ -4253,7 +4600,7 @@
 		pTotem->EnableAI();
 		pTotem->GetAIInterface()->Init(pTotem, AITYPE_TOTEM, MOVEMENTTYPE_NONE, p_caster);
 		pTotem->GetAIInterface()->totemspell = TotemSpell;
-		uint32 timer = 2000;	// need a proper resource for this.
+		uint32 timer = 3000;	// need a proper resource for this.
 
 		switch(TotemSpell->Id)
 		{
@@ -4377,7 +4724,7 @@
 		return;
 	if( p_caster == NULL )
 		return;
-    if( p_caster->IsStunned() || p_caster->m_rooted || p_caster->IsPacified() )
+    if (p_caster->IsStunned() || p_caster->m_rooted || p_caster->IsPacified() || p_caster->IsFeared())
         return;
 
 	float x, y, z;
@@ -4401,7 +4748,7 @@
 
 	x = d*cosf(alpha)+m_caster->GetPositionX();
 	y = d*sinf(alpha)+m_caster->GetPositionY();
-	z = unitTarget->GetPositionZ();
+	z = unitTarget->GetPositionZ() + 0.2f;
 
 	uint32 time = uint32( (m_caster->CalcDistance(unitTarget) / ((m_caster->m_runSpeed * 3.5) * 0.001f)) + 0.5);
 
@@ -4523,9 +4870,16 @@
 	float dx,dy;//,dz;
 	float affect = float(damage)/10;
 
-	//Not sure about /100
-	dx = sinf(m_caster->GetOrientation());
-	dy = cosf(m_caster->GetOrientation());
+	if (u_caster == NULL || u_caster != unitTarget)
+	{
+		dx = sinf(m_caster->GetOrientation());
+		dy = cosf(m_caster->GetOrientation());
+	}
+	else
+	{
+		dx = 0.0f;
+		dy = 0.0f;
+	}
 
 	WorldPacket data(SMSG_MOVE_KNOCK_BACK, 50);
 	data << unitTarget->GetNewGUID();
@@ -4542,20 +4896,26 @@
 void Spell::SpellEffectDisenchant(uint32 i)
 {
 	Player* caster = static_cast< Player* >( m_caster );
-	Item* it = caster->GetItemInterface()->SafeRemoveAndRetreiveItemByGuid( m_targets.m_itemTarget, true );
+	Item* it = caster->GetItemInterface()->GetItemByGUID(m_targets.m_itemTarget);
 	if( it == NULL )
 		return;
    
 	//Check for skill first, we can increase it upto 75 
 	uint32 skill=caster->_GetSkillLineCurrent( SKILL_ENCHANTING );
 	if(skill < 75)//can up skill
-	if(Rand(float(100-skill*100.0/75.0)))
-		caster->_AdvanceSkillLine(SKILL_ENCHANTING, float2int32( 1.0f * sWorld.getRate(RATE_SKILLRATE)));
-	AddItemFromDisenchant(it->GetProto(),caster);
+		if(Rand(float(100-skill*100.0/75.0)))
+			caster->_AdvanceSkillLine(SKILL_ENCHANTING, float2int32( 1.0f * sWorld.getRate(RATE_SKILLRATE)));
+ 
+	caster->SetLootGUID(it->GetGUID());
+	if(!it->loot)
+	{
+		it->loot = new Loot;
+		lootmgr.FillDisenchantingLoot(it->loot, it->GetEntry());
+	}
+	caster->SendLoot(it->GetGUID(), 2);
 
 	if(it==i_caster)
 		i_caster=NULL;
-	delete it;
 }
 
 void Spell::SpellEffectInebriate(uint32 i) // lets get drunk!
@@ -4698,9 +5058,11 @@
 	if(pPet)
 	{
 		pPet->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
-		pPet->SetUInt32Value(UNIT_FIELD_HEALTH, (uint32)(pPet->GetUInt32Value(UNIT_FIELD_MAXHEALTH) * 0.5));
+		// stored in EffectBasePoints[] but since only one spell uses this effect ...
+		pPet->SetUInt32Value(UNIT_FIELD_HEALTH, (uint32)(pPet->GetUInt32Value(UNIT_FIELD_MAXHEALTH) * 0.15));
 		pPet->setDeathState(ALIVE);
 		pPet->GetAIInterface()->HandleEvent(EVENT_FOLLOWOWNER, pPet, 0);
+		pPet->SendSpellsToOwner();
 		sEventMgr.RemoveEvents(pPet, EVENT_PET_DELAYED_REMOVE);
 	}
 }
@@ -4977,7 +5339,7 @@
 			}
 		}
 		if(!spellInfo)
-			return; //omg how did this happen ?
+			return;
 		//we should also cast sunder armor effect on target with or without dmg
 		Spell *spell = new Spell(u_caster, spellInfo ,true, NULL);
 		spell->ProcedOnSpell = m_spellInfo;
@@ -4985,25 +5347,37 @@
 		SpellCastTargets targets(unitTarget->GetGUID());
 		spell->prepare(&targets);
 		if(!sunder_count)
-			return; //no damage = no joy
-		damage = damage*sunder_count;
+			return;
+		if ( sunder_count > 5 ) sunder_count = 5;
+		damage = (int32)(0.01*damage*(m_spellInfo->EffectBasePoints[0]+1)+(1+ m_spellInfo->EffectBasePoints[1])*sunder_count);
 	}
 
+	//hemorage
+	if( p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_HEMORRHAGE )
+		p_caster->AddComboPoints(p_caster->GetSelection(), 1);
+
 	if( m_spellInfo->Effect[0] == SPELL_EFFECT_WEAPON_PERCENT_DAMAGE || m_spellInfo->Effect[1] == SPELL_EFFECT_WEAPON_PERCENT_DAMAGE)
 	{
 		add_damage = (uint32)(damage * 1.5);
 		return;
 	}
 
-	//hemorage
-	if( p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_HEMORRHAGE )
-		p_caster->AddComboPoints(p_caster->GetSelection(), 1);
-
 	//rogue - mutilate ads dmg if target is poisoned
 	if(	m_spellInfo->NameHash == SPELL_HASH_MUTILATE && unitTarget->IsPoisoned() )
 		damage = damage + float2int32( (float)damage * 0.5f );
 
-	u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, damage, 0, 0, false, true );
+	uint32 _type;
+	if( GetType() == SPELL_DMG_TYPE_RANGED )
+		_type = RANGED;
+	else
+	{
+		if (m_spellInfo->Flags4 & 0x1000000)
+			_type =  OFFHAND;
+		else
+			_type = MELEE;
+	}
+
+	u_caster->Strike( unitTarget, _type, m_spellInfo, damage, 0, 0, false, true );
 }
 
 void Spell::SpellEffectSpellSteal( uint32 i )
@@ -5036,13 +5410,27 @@
 				data << m_caster->GetNewGUID();
 				data << unitTarget->GetNewGUID();
 				data << (uint32)1;
-				data << aur->GetSpellId();
-				m_caster->SendMessageToSet(&data,true);
-				Aura *aura = new Aura(aur->GetSpellProto(), (aur->GetDuration()>120000) ? 120000 : aur->GetDuration(), u_caster, u_caster);
-				u_caster->AddAura(aura);
-				unitTarget->RemoveAura(aur);
-				if( --spells_to_steal <= 0 )
-					break; //exit loop now
+ 				data << aur->GetSpellId();
+ 				m_caster->SendMessageToSet(&data,true);
+				uint32 dur = aur->GetDuration();
+				if (dur > 120000)
+					dur = 120000;
+ 				u_caster->CastSpell(u_caster, aur->GetSpellProto(), true);
+ 				unitTarget->RemoveAllAuras(aur->GetSpellProto()->Id,aur->GetCasterGUID());
+				Aura *aura = u_caster->FindAura(aur->GetSpellId());
+				if (aura)
+				{
+					aura->SetDuration(dur);
+					sEventMgr.ModifyEventTimeLeft(aura, EVENT_AURA_REMOVE, dur);
+					if(u_caster->IsPlayer())
+					{
+						WorldPacket data(5);
+						data.SetOpcode(SMSG_UPDATE_AURA_DURATION);
+						data << (uint8)(aura)->GetAuraSlot() << dur;
+						p_caster->GetSession()->SendPacket(&data);
+					}
+				}
+				return;
 			}			
 		}
 	}   
@@ -5062,7 +5450,9 @@
 
 	if(p_caster->GetItemInterface()->RemoveItemAmt(entry, 5))
 	{
-		AddItemFromProspecting(entry, p_caster);
+		p_caster->SetLootGUID(p_caster->GetGUID());
+		lootmgr.FillProspectingLoot(&p_caster->loot, entry);
+		p_caster->SendLoot(p_caster->GetGUID(), 2);
 	}
 	else // this should never happen either
 	{
Index: ascent-world/SpellTarget.cpp
===================================================================
--- ascent-world/SpellTarget.cpp	(revision 3944)
+++ ascent-world/SpellTarget.cpp	(working copy)
@@ -276,6 +276,7 @@
 void Spell::SpellTargetSelf(uint32 i, uint32 j)
 {
 	TargetsList *tmpMap=&m_targetUnits[i];
+
 	if(p_caster)
 	{
 		if(m_spellInfo->RequiredShapeShift && (p_caster->getClass()==DRUID || p_caster->getClass()==WARRIOR))
@@ -289,6 +290,7 @@
 			}
 		}
 	}
+
 	SafeAddTarget(tmpMap,m_caster->GetGUID());
 }
 void Spell::SpellTargetInvisibleAOE(uint32 i, uint32 j)
@@ -370,20 +372,20 @@
 
 	if(m_spellInfo->EffectChainTarget[i])
 	{
-		uint32 jumps=m_spellInfo->EffectChainTarget[i]-1;
+		uint32 jumps = m_spellInfo->EffectChainTarget[i]-1;
 		float range=GetMaxRange(dbcSpellRange.LookupEntry(m_spellInfo->rangeIndex));//this is probably wrong
 		range*=range;
-		std::set<Object*>::iterator itr;
-		for( itr = m_caster->GetInRangeSetBegin(); itr != m_caster->GetInRangeSetEnd(); itr++ )
+
+		for(std::set<Object*>::iterator itr = m_caster->GetInRangeSetBegin(); itr != m_caster->GetInRangeSetEnd(); itr++ )
 		{
-			if((*itr)->GetGUID()==m_targets.m_unitTarget)
+			if((*itr)->GetGUID() == m_targets.m_unitTarget)
 				continue;
 			if( !((*itr)->IsUnit()) || !((Unit*)(*itr))->isAlive())
 				continue;
 
 			if(IsInrange(m_caster->GetPositionX(),m_caster->GetPositionY(),m_caster->GetPositionZ(),(*itr),range))
 			{
-				if(isAttackable(u_caster,(Unit*)(*itr)))
+				if(isAttackable(u_caster,(Unit*)(*itr)) )
 				{
 					did_hit_result = DidHit(i,((Unit*)*itr));
 					if(did_hit_result==SPELL_DID_HIT_SUCCESS)
@@ -396,6 +398,7 @@
 				}
 			}
 		}
+
 	}
 }
 
@@ -508,7 +511,7 @@
 		//is Creature in range
 		if(m_caster->isInRange((Unit*)(*itr),GetRadius(i)))
 		{
-			if(m_caster->isInFront((Unit*)(*itr)))
+			if(m_caster->isInCone((Unit*)(*itr)))
 			{
 				if(isAttackable(u_caster, (Unit*)(*itr)))
 				{
@@ -747,6 +750,132 @@
 		return;
 
 	TargetsList *tmpMap=&m_targetUnits[i];
+	//float range = GetMaxRange(dbcSpellRange.LookupEntry(m_spellInfo->rangeIndex));
+	//range *= range;
+	float range = 400; //taken from wow-europe forum
+	Unit *currentTarget = m_caster->GetMapMgr()->GetUnit(m_targets.m_unitTarget);
+	if (!currentTarget)
+		return;
+
+	uint32 jumps=m_spellInfo->EffectChainTarget[i];
+	if(m_spellInfo->SpellGroupType && u_caster)
+	{
+		SM_FIValue(u_caster->SM_FAdditionalTargets,(int32*)&jumps,m_spellInfo->SpellGroupType);
+	}
+	SafeAddTarget(tmpMap, currentTarget->GetGUID());
+	if (!jumps)
+		return;
+	jumps--;
+
+	bool groupOnly = false;
+	if (p_caster != NULL && p_caster->InGroup())
+		if (currentTarget->GetTypeId() == TYPEID_PLAYER && p_caster->GetSubGroup() == static_cast<Player*>(currentTarget)->GetSubGroup())
+			groupOnly = true;
+
+	Unit *newTarget = NULL;
+	int newTargetHealthPct = 100;
+	if (groupOnly)
+	{
+		SubGroup *pGroup = p_caster->GetGroup()->GetSubGroup(p_caster->GetSubGroup());
+		if(pGroup)
+		{
+			p_caster->GetGroup()->Lock();
+			while (jumps)
+			{
+				for(GroupMembersSet::iterator itr = pGroup->GetGroupMembersBegin(); itr != pGroup->GetGroupMembersEnd(); itr++)
+				{
+					if(!(*itr)->m_loggedInPlayer)
+						continue;
+
+					Unit *temp = static_cast<Unit*>((*itr)->m_loggedInPlayer);
+
+					//Check if Unit is already in the TargetMap
+					bool foundUnit = false;
+					for(TargetsList::iterator i=tmpMap->begin();i!=tmpMap->end();i++)
+					{
+						if((*i) == temp->GetGUID())
+						{
+							foundUnit = true;
+							break;
+						}
+					}
+					if (foundUnit)
+						continue;
+
+					if (temp->isAlive() && !isAttackable(u_caster, temp) && currentTarget->GetDistanceSq(temp) <= range)
+					{
+						if ((newTarget == NULL && temp->GetHealthPct() < 100) || temp->GetHealthPct() < newTargetHealthPct)
+						{
+							newTarget = temp;
+							newTargetHealthPct = temp->GetHealthPct();
+						}
+					}
+				}
+				if (newTarget == NULL)
+				{
+					p_caster->GetGroup()->Unlock();
+					return;
+				}
+
+				else
+				{
+					currentTarget = newTarget;
+					newTarget = NULL;
+					newTargetHealthPct = 100;
+					SafeAddTarget(tmpMap, currentTarget->GetGUID());
+					jumps--;
+				}
+			}
+			p_caster->GetGroup()->Unlock();
+		}
+	}
+	else
+	{
+		while (jumps)
+		{
+			for(std::set<Object*>::iterator itr = currentTarget->GetInRangeSetBegin(); itr != currentTarget->GetInRangeSetEnd(); itr++)
+			{
+				if((*itr)->GetTypeId() != TYPEID_PLAYER && (*itr)->GetTypeId() != TYPEID_UNIT)
+					continue;
+
+				Unit *temp = static_cast<Unit*>(*itr);
+
+				//Check if Unit is already in the TargetMap
+				bool foundUnit = false;
+				for(TargetsList::iterator i=tmpMap->begin();i!=tmpMap->end();i++)
+				{
+					if((*i) == temp->GetGUID())
+					{
+						foundUnit = true;
+						break;
+					}
+				}
+				if (foundUnit)
+					continue;
+
+				if (temp && temp->isAlive() && !isAttackable(u_caster, temp) && currentTarget->GetDistanceSq(temp) <= range)
+				{
+					if ((newTarget == NULL && temp->GetHealthPct() < 100) || temp->GetHealthPct() < newTargetHealthPct)
+					{
+						newTarget = temp;
+						newTargetHealthPct = temp->GetHealthPct();
+					}
+				}
+			}
+			if (newTarget == NULL)
+				return;
+
+			else
+			{
+				currentTarget = newTarget;
+				newTarget = NULL;
+				newTargetHealthPct = 100;
+				SafeAddTarget(tmpMap, currentTarget->GetGUID());
+				jumps--;
+			}
+		}
+	}
+	/*
 	//if selected target is party member, then jumps on party
 	Unit* firstTarget;
 
@@ -824,6 +953,7 @@
 			}
 		}
 	}
+	*/
 }
 
 /// Spell target handling for commonly used simple target add's
Index: ascent-world/StdAfx.h
===================================================================
--- ascent-world/StdAfx.h	(revision 3944)
+++ ascent-world/StdAfx.h	(working copy)
@@ -126,7 +126,6 @@
 #include "MapScriptInterface.h"
 #include "Player.h"
 #include "faction.h"
-#include "Professions.h"
 #include "Skill.h"
 #include "SkillNameMgr.h"
 #include "SocialMgr.h"
Index: ascent-world/TerrainMgr.cpp
===================================================================
--- ascent-world/TerrainMgr.cpp	(revision 3944)
+++ ascent-world/TerrainMgr.cpp	(working copy)
@@ -23,6 +23,7 @@
 
 TerrainMgr::TerrainMgr(string MapPath, uint32 MapId, bool Instanced) : mapPath(MapPath), mapId(MapId), Instance(Instanced)
 {
+	FileDescriptor = NULL;
 	CellInformation = NULL;
 }
 
@@ -35,6 +36,7 @@
 		mutex.Acquire();
 		fclose(FileDescriptor);
 		mutex.Release();
+		FileDescriptor = NULL;
 	}
 
 	// Big memory cleanup, whee.
@@ -50,6 +52,7 @@
 			delete [] CellInformation[x];
 		}
 		delete CellInformation;
+		CellInformation = NULL;
 	}
 #else
 
Index: ascent-world/Unit.cpp
===================================================================
--- ascent-world/Unit.cpp	(revision 3944)
+++ ascent-world/Unit.cpp	(working copy)
@@ -25,6 +25,7 @@
 	m_attackTimer_1 = 0;
 	m_duelWield = false;
 
+	m_fearmodifiers = 0;
 	m_state = 0;
 	m_special_state = 0;
 	m_deathState = ALIVE;
@@ -561,6 +562,11 @@
 		for( int i = 0; i < active_player_count; i++ )
 		{
 			active_player_list[i]->GiveXP( float2int32( ( ( xp * active_player_list[i]->getLevel()) / total_level ) * xp_mod ), pVictim->GetGUID(), true );
+
+			active_player_list[i]->SetFlag(UNIT_FIELD_AURASTATE,AURASTATE_FLAG_LASTKILLWITHHONOR);
+			if(!sEventMgr.HasEvent(active_player_list[i],EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE))
+				sEventMgr.AddEvent((Unit*)active_player_list[i],&Unit::EventAurastateExpire,(uint32)AURASTATE_FLAG_LASTKILLWITHHONOR,EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE,20000,1,0);
+			else sEventMgr.ModifyEventTimeLeft(active_player_list[i],EVENT_LASTKILLWITHHONOR_FLAG_EXPIRE,20000);
 		}
 	}
 		/* old code start before 2007 04 22
@@ -608,7 +614,9 @@
 	bool can_delete = !bProcInUse; //if this is a nested proc then we should have this set to TRUE by the father proc
 	bProcInUse = true; //locking the proc list
 
-	std::list< uint32 > remove;
+	if ( m_procSpells.size() == 0 || m_procSpells.begin() == m_procSpells.end() )
+		return; // 2 of those should be the same but i've still added the 2nd in case
+
 	std::list< struct ProcTriggerSpell >::iterator itr,itr2;
 	for( itr = m_procSpells.begin(); itr != m_procSpells.end(); )  // Proc Trigger Spells for Victim
 	{
@@ -721,6 +729,18 @@
 				}
 			}
 
+			// some percentage chances for procs
+			switch( spellId )
+			{
+				case 42084:
+				case 33649:
+					proc_Chance = 10;
+					break;
+				case 37174:
+					proc_Chance = 25;
+					break;
+			}
+
 			SM_FIValue( SM_FChanceOfSuccess, (int32*)&proc_Chance, ospinfo->SpellGroupType );
 			if( spellId && Rand( proc_Chance ) )
 			{
@@ -754,6 +774,20 @@
 				//these are player talents. Fuckem they pull the emu speed down 
 				if( IsPlayer() )
 				{
+					if (itr2->ProcType == 1 && static_cast<Player*>(this)->IsInFeralForm()) 
+					{
+						switch (static_cast<Player*>(this)->GetShapeShift())
+						{
+							case FORM_CAT:
+							case FORM_BEAR:
+							case FORM_DIREBEAR:
+								continue;
+								break;
+							default:
+								break;
+						}
+					}
+
 					uint32 talentlevel = 0;
 					switch( origId )
 					{
@@ -773,6 +807,14 @@
 
 					switch( spellId )
 					{
+						case 37243: // Fathom-Brooch of the Tidewalker
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->School != SCHOOL_NATURE )
+								continue;
+						}break;
+
 						case 14189: //Seal Fate
 						case 16953: //Blood Frenzy
 						{
@@ -784,6 +826,132 @@
 								CastingSpell->NameHash != SPELL_HASH_MANGLE__CAT_ )
 								continue;
 						}break;
+
+						case 43839: // S1 relics
+						case 43848: // S2 relics
+						case 43849: // S3 relics
+						case 46089: // S4 relics
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_STORMSTRIKE && 
+								CastingSpell->NameHash != SPELL_HASH_FLAME_SHOCK && 
+								CastingSpell->NameHash != SPELL_HASH_EARTH_SHOCK && 
+								CastingSpell->NameHash != SPELL_HASH_FROST_SHOCK &&
+								CastingSpell->NameHash != SPELL_HASH_HOLY_SHIELD &&
+								CastingSpell->NameHash != SPELL_HASH_JUDGEMENT &&
+								CastingSpell->NameHash != SPELL_HASH_MOONFIRE &&
+								CastingSpell->NameHash != SPELL_HASH_MANGLE__CAT_ &&
+								CastingSpell->NameHash != SPELL_HASH_MANGLE__BEAR_ )
+								continue;
+						}break;
+
+						case 37563: // Renewal ( T4 priest healing set 2 items bonus )
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_PRAYER_OF_HEALING )
+								continue;
+						}break;
+
+						case 22009: // Greater Heal Renew ( T2 priest healing set 2 items bonus )
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_GREATER_HEAL )
+								continue;
+						}break;
+
+						case 32747: // Deadly Throw Interrupt (rogue arena gloves set)
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_DEADLY_THROW )
+								continue;
+						}break;
+
+						case 41043: // Tome of the Lightbringer
+						case 23590: // T2 paladin set(8) bonus
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_JUDGEMENT )
+								continue;
+						}break;
+
+						case 41038: // Mark of the White Stag
+						case 43738: // Idol of Terror
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_MANGLE__CAT_ && CastingSpell->NameHash != SPELL_HASH_MANGLE__BEAR_ )
+								continue;
+						}break;
+
+						case 28788: // T3 paladin set(8) bonus
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_CLEANSE )
+								continue;
+						}break;
+
+						case 28820: // T3 shaman set(8) bonus
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_LIGHTNING_SHIELD )
+								continue;
+						}break;
+
+						case 28815: // T3 rogue set(8) bonus
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_EVISCERATE )
+								continue;
+						}break;
+
+						case 37523: // T3 warrior set(8) bonus
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_SHIELD_BLOCK )
+								continue;
+						}break;
+
+						case 28839: // T3 warlock set(8) bonus
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_SHADOW_BOLT )
+								continue;
+						}break;
+
+						case 37508: // Talon of Al'ar
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_ARCANE_SHOT )
+								continue;
+						}break;
+
+						case 34324: // Idol of the Claw
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_FEROCIOUS_BITE && CastingSpell->NameHash != SPELL_HASH_RIP && CastingSpell->NameHash != SPELL_HASH_MAIM )
+								continue;
+						}break;
+
+						case 24405: // Glacial Spike
+						{
+							if( CastingSpell == NULL )
+								continue;
+							if( CastingSpell->NameHash != SPELL_HASH_FROSTBOLT )
+								continue;
+						}break;
+
 						case 17106: //druid intencity
 						{
 							if( CastingSpell == NULL )
@@ -797,19 +965,24 @@
 							if( GetHealthPct() > 30 )
 								continue;
 						}break;
-						case 37309:
+
+						case 37309: // Bloodlust
+						case 17769: // Wolfshead Helm
 						{
 							if( static_cast< Player* >( this )->GetShapeShift() != FORM_BEAR ||
 								static_cast< Player* >( this )->GetShapeShift() != FORM_DIREBEAR )
 								continue;
 						}break;
-						case 37310:
+
+						case 37310: // Bloodlust
+						case 17770: // Wolfshead Helm
 						{
 							if( static_cast< Player* >( this )->GetShapeShift() != FORM_CAT )
 								continue;
 						}break;
-                        case 34754: //holy concentration
-                        {
+
+						case 34754: //holy concentration
+						{
 							if( CastingSpell == NULL )
 								continue;
 							if( CastingSpell->NameHash != SPELL_HASH_FLASH_HEAL &&
@@ -842,6 +1015,7 @@
 							if( !Rand( chance ) )
 								continue;
 						}break;
+						case 16459:
 						case 4350:
 						{
 							//sword specialization
@@ -869,8 +1043,7 @@
 								it = static_cast< Player* >( this )->GetItemInterface()->GetInventoryItem( EQUIPMENT_SLOT_MAINHAND );
 								if( it != NULL && it->GetProto() )
 								{
-									//class 2 means weapons ;)
-									if( it->GetProto()->Class != 2 )
+									if(it->GetProto()->Class != ITEM_CLASS_WEAPON)
 										continue;
 								}
 								else continue; //no weapon no joy
@@ -1283,7 +1456,6 @@
 								uint32 dmg = static_cast< Player* >( this )->GetMainMeleeDamage( AP_owerride );
 								SpellEntry* sp_for_the_logs = dbcSpell.LookupEntry( spellId );
 								Strike( victim, MELEE, sp_for_the_logs, dmg, 0, 0, true, false );
-								Strike( victim, MELEE, sp_for_the_logs, dmg, 0, 0, true, false );
 								//nothing else to be done for this trigger
 								continue;
 							}break;
@@ -1789,6 +1961,7 @@
 	iter=m_chargeSpells.begin();
 	while(iter!= m_chargeSpells.end())
 	{
+		
 		iter2=iter++;
 		if(iter2->second.count)
 		{
@@ -1832,6 +2005,69 @@
 						}break;
 					}
 				}
+
+				if ( iter2->second.spellId == 41635 ) //Prayer of Mending
+				{
+
+					SpellEntry* sp = dbcSpell.LookupEntryForced( 41635 );
+					if ( sp != NULL ) //heal us up
+					{
+						Spell spell( this, sp , true, NULL );
+						spell.SetUnitTarget( this );
+						spell.Heal( 800 );
+					}
+
+					//count charges left
+					uint32 count = 0;
+					for( uint32 x = 0; x < MAX_POSITIVE_AURAS; ++x )
+					{
+						if(m_auras[x] && m_auras[x]->GetSpellProto()->NameHash == SPELL_HASH_PRAYER_OF_MENDING)
+							count++;
+					}
+
+					this->RemoveAllAuraByNameHash( SPELL_HASH_PRAYER_OF_MENDING );
+
+					if ( count <= 1 )
+					{
+						this->RemoveAllAuraByNameHash(SPELL_HASH_PRAYER_OF_MENDING);
+						continue;
+					}
+					--count;
+
+					//get new target
+					SubGroup* pGroup = static_cast< Player* >( this )->GetGroup() ?
+						static_cast< Player* >( this )->GetGroup()->GetSubGroup( static_cast< Player* >( this )->GetSubGroup() ) : NULL;
+					if( pGroup == NULL )
+						continue;
+
+					Player* newTarget = NULL;
+					uint32 minHP = uint32(-1);
+
+					GroupMembersSet::iterator itr;
+					static_cast< Player* >( this )->GetGroup()->Lock();
+					for(itr = pGroup->GetGroupMembersBegin(); itr != pGroup->GetGroupMembersEnd(); ++itr)
+					{
+						Player *p = (*itr)->m_loggedInPlayer;
+						if( p && p != this && p->isAlive() && this->GetDistance2dSq( p ) <= 500 && p->GetUInt32Value(UNIT_FIELD_HEALTH) < minHP )
+						{
+							minHP = p->GetUInt32Value(UNIT_FIELD_HEALTH);
+							newTarget = p;
+						}
+					}
+					static_cast< Player* >( this )->GetGroup()->Unlock();
+
+					if ( newTarget == NULL )
+						continue;
+
+					sp->procCharges = count; //ugly hack :(
+					Spell* spe = new Spell( this, sp, true, NULL );
+					SpellCastTargets tgt( newTarget->GetGUID() );
+					spe->prepare(&tgt);
+					sp->procCharges = 5;
+
+					//continue;
+				}
+
 				if(iter2->second.lastproc!=0)
 				{
 					if(iter2->second.procdiff>3000)
@@ -2281,7 +2517,7 @@
 //==========================================================================================
 //==============================Unacceptable Cases Processing===============================
 //==========================================================================================
-	if(!pVictim->isAlive() || !isAlive()  || IsStunned() || IsPacified())
+	if(!pVictim->isAlive() || !isAlive()  || IsStunned() || IsPacified() || IsFeared())
 		return;
 	if(!isInFront(pVictim))
 		if(IsPlayer())
@@ -2741,12 +2977,16 @@
 			// burlex: fixed this crap properly
 			float inital_dmg = float(dmg.full_damage);
 			float dd_mod = GetDamageDonePctMod( dmg.school_type );
+			float dd_mod2 = 1.0f + DamageDoneModPCT[dmg.school_type];
 			if( pVictim->DamageTakenPctMod[dmg.school_type] > 1.0f )
 				dmg.full_damage += float2int32( ( inital_dmg * pVictim->DamageTakenPctMod[ dmg.school_type ] ) - inital_dmg );
 
-			if( dd_mod > 1.0f )
+			if( dd_mod > 1.0f && ( dmg.school_type != SCHOOL_NORMAL ) )
 				dmg.full_damage += float2int32( ( inital_dmg * dd_mod) - inital_dmg );
 
+			if (dd_mod2 > 1.0f)
+				dmg.full_damage += float2int32( ( inital_dmg * dd_mod2) - inital_dmg );
+
 			if( ability != NULL && ability->NameHash == SPELL_HASH_SHRED )
 				dmg.full_damage += float2int32( ( inital_dmg * (1 + pVictim->ModDamageTakenByMechPCT[MECHANIC_BLEEDING]) ) - inital_dmg );
 
@@ -2810,13 +3050,14 @@
 							blocked_damage = 0;
 						}
 
-						if(dmg.full_damage <= (int32)blocked_damage)
-						{
-							CALL_SCRIPT_EVENT(pVictim, OnTargetBlocked)(this, blocked_damage);
-							CALL_SCRIPT_EVENT(this, OnBlocked)(pVictim, blocked_damage);
-							vstate = BLOCK;
-							vproc |= PROC_ON_BLOCK_VICTIM;
-						}
+						// should always be procing block victim
+						vproc |= PROC_ON_BLOCK_VICTIM;
+						CALL_SCRIPT_EVENT(pVictim, OnTargetBlocked)(this, blocked_damage);
+						CALL_SCRIPT_EVENT(this, OnBlocked)(pVictim, blocked_damage);
+
+						if(dmg.full_damage <= (int32)blocked_damage)   
+							vstate = BLOCK;   // BLOCK is actually full block, a partially blocked hit is registered as a normal hit
+          
 						if( pVictim->IsPlayer() )//not necessary now but we'll have blocking mobs in future
 						{            
 							pVictim->SetFlag(UNIT_FIELD_AURASTATE,AURASTATE_FLAG_DODGE_BLOCK);	//SB@L: Enables spells requiring dodge
@@ -2831,15 +3072,18 @@
 //--------------------------------critical hit----------------------------------------------
 			case 5:
 				{
+					if ( ability && (ability->Flags3 & FLAGS3_CANNOT_CRIT) )
+						break;
+
 					hit_status |= HITSTATUS_CRICTICAL;
 					int32 dmgbonus = dmg.full_damage;
 					//sLog.outString( "DEBUG: Critical Strike! Full_damage: %u" , dmg.full_damage );
 					if(ability && ability->SpellGroupType)
 					{
-						SM_FIValue(SM_PCriticalDamage,&dmgbonus,ability->SpellGroupType);
+						SM_PIValue(SM_PCriticalDamage,&dmgbonus,ability->SpellGroupType);
 #ifdef COLLECTION_OF_UNTESTED_STUFF_AND_TESTERS
 						int spell_flat_modifers=0;
-						SM_FIValue(SM_PCriticalDamage,&spell_flat_modifers,ability->SpellGroupType);
+						SM_PIValue(SM_PCriticalDamage,&spell_flat_modifers,ability->SpellGroupType);
 						if(spell_flat_modifers!=0)
 							printf("!!!!!spell crit dmg bonus mod flat %d , spell crit dmg bonus %d, spell group %u\n",spell_flat_modifers,dmgbonus,ability->SpellGroupType);
 #endif
@@ -2978,7 +3222,7 @@
 		pVictim->HandleProc(vproc,this, ability,realdamage,abs);
 		pVictim->m_procCounter = 0;
 
-		if(realdamage > 0)
+		if(realdamage > 0 || vproc & PROC_ON_BLOCK_VICTIM)
 		{
 			pVictim->HandleProcDmgShield(vproc,this);
 			HandleProcDmgShield(aproc,pVictim);
@@ -3045,7 +3289,7 @@
 		// rather than fuck with duration
 		for( uint32 x = MAX_POSITIVE_AURAS; x <= MAX_AURAS; x++ )
 		{
-			if( pVictim->m_auras[x] != NULL && pVictim->m_auras[x]->GetUnitCaster() != NULL && pVictim->m_auras[x]->GetUnitCaster()->GetGUID() == GetGUID() && pVictim->m_auras[x]->GetSpellProto()->buffIndexType == SPELL_TYPE_INDEX_JUDGEMENT )
+			if( pVictim->m_auras[x] != NULL && pVictim->m_auras[x]->GetUnitCaster() != NULL && pVictim->m_auras[x]->GetUnitCaster()->GetGUID() == GetGUID() && (pVictim->m_auras[x]->GetSpellProto()->c_is_flags & SPELL_FLAG_IS_JUDGEMENT) )
 			{
 				pVictim->m_auras[x]->SetDuration( 20000 ); // 20 seconds?
 				sEventMgr.ModifyEventTimeLeft( pVictim->m_auras[x], EVENT_AURA_REMOVE, 20000 );
@@ -3065,6 +3309,14 @@
 			}
 		}
 
+		//ugly hack for shadowfiend restoring mana
+		if( GetUInt64Value(UNIT_FIELD_SUMMONEDBY) != 0 && GetUInt32Value(OBJECT_FIELD_ENTRY) == 19668 )
+		{
+			Player* owner = GetMapMgr()->GetPlayer((uint32)GetUInt64Value(UNIT_FIELD_SUMMONEDBY));
+			if ( owner != NULL )
+				this->Energize(owner, 34433, uint32(2.5f*realdamage + 0.5f), POWER_TYPE_MANA );
+		}
+
 	}
 	
 //==========================================================================================
@@ -3274,7 +3526,7 @@
 		m_extraAttackCounter = false;
 	}
 
-	if(m_extrastriketargets)
+	if(m_extrastriketargets > 0)
 	{
 		int32 m_extra = m_extrastriketargets;
 		int32 m_temp = m_extrastriketargets;
@@ -3282,16 +3534,19 @@
 
 		for(set<Object*>::iterator itr = m_objectsInRange.begin(); itr != m_objectsInRange.end() && m_extra; ++itr)
 		{
-			if(m_extra == 0)
+			if(m_extra <= 0)
 				break;
+			if (!(*itr) || (*itr) == pVictim || !(*itr)->IsUnit())
+				continue;
 
-			if((*itr) != pVictim && (*itr)->IsUnit() && CalcDistance(*itr) < 10.0f && isAttackable(this, (*itr)) && (*itr)->isInFront(this) && !((Unit*)(*itr))->IsPacified())
+			//if((*itr) != pVictim && (*itr)->IsUnit() && CalcDistance(*itr) < 10.0f && isAttackable(this, (*itr)) && (*itr)->isInFront(this) && !((Unit*)(*itr))->IsPacified())
+			if(CalcDistance(*itr) < 10.0f && isAttackable(this, (*itr)) && (*itr)->isInFront(this) && !((Unit*)(*itr))->IsPacified())
 			{
-				Strike( static_cast< Unit* >( *itr ), weapon_damage_type, ability, add_damage, pct_dmg_mod, exclusive_damage, false ,false );
+				Strike( static_cast< Unit* >( *itr ), weapon_damage_type, ability, 0, pct_dmg_mod, exclusive_damage, false ,false );
 				--m_extra;
 			}
 		}
-		m_extrastriketargets = m_temp;
+		m_extrastriketargets += m_temp;
 	}
 }	
 
@@ -3453,15 +3708,19 @@
 						//update duration,the same aura (update the whole stack whenever we cast a new one)
 						m_auras[x]->SetDuration(aur->GetDuration());
 						sEventMgr.ModifyEventTimeLeft(m_auras[x], EVENT_AURA_REMOVE, aur->GetDuration());
-						if(this->IsPlayer())
-						{
-							data.Initialize(SMSG_UPDATE_AURA_DURATION);
-							data << (uint8)m_auras[x]->m_visualSlot <<(uint32) aur->GetDuration();
-							static_cast< Player* >( this )->GetSession()->SendPacket( &data );
-						}
-						data.Initialize(SMSG_PET_LEARNT_SPELL);
-						data << GetNewGUID() << m_auras[x]->m_visualSlot << uint32(m_auras[x]->GetSpellProto()->Id) << uint32(aur->GetDuration()) << uint32(aur->GetDuration());
-						SendMessageToSet(&data,false);
+						if(maxStack <= 1)
+ 						{
+							if(this->IsPlayer())
+							{
+								data.Initialize(SMSG_UPDATE_AURA_DURATION);
+								data << (uint8)m_auras[x]->m_visualSlot <<(uint32) aur->GetDuration();
+								((Player*)this)->GetSession()->SendPacket(&data);
+							}
+							
+							data.Initialize(SMSG_SET_AURA_SINGLE);
+							data << GetNewGUID() << m_auras[x]->m_visualSlot << uint32(m_auras[x]->GetSpellProto()->Id) << uint32(aur->GetDuration()) << uint32(aur->GetDuration());
+							SendMessageToSet(&data,false);
+ 						}
 					}
 					if(maxStack <= f)
 					{
@@ -3821,7 +4080,7 @@
 		static_cast< Player* >( this )->GetSession()->SendPacket( &data );
 	}
 
-	WorldPacket data(SMSG_PET_LEARNT_SPELL,21);
+	WorldPacket data(SMSG_SET_AURA_SINGLE,21);
 	data << GetNewGUID() << aur->m_visualSlot << uint32(spellId) << uint32(duration) << uint32(duration);
 	SendMessageToSet(&data,false);
 			
@@ -3846,7 +4105,7 @@
 		data << (uint8)(aur)->GetAuraSlot() << duration;
 		static_cast< Player* >( this )->GetSession()->SendPacket( &data );
 	}
-	WorldPacket data(SMSG_PET_LEARNT_SPELL,21);
+	WorldPacket data(SMSG_SET_AURA_SINGLE,21);
 	data << GetNewGUID() << aur->m_visualSlot << uint32(spellId) << uint32(duration) << uint32(duration);
 	SendMessageToSet(&data,false);
 
@@ -3929,7 +4188,7 @@
 	pLastSpell = pSpell->m_spellInfo;
 }
 
-int32 Unit::GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg)
+int32 Unit::GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg, uint32 isDot)
 {
 	int32 plus_damage = 0;
 	Unit* caster = this;
@@ -3940,8 +4199,8 @@
 
 	if( caster->IsPlayer() )
 	{
-		plus_damage += float2int32(static_cast< Player* >(caster)->SpellDmgDoneByInt[school] * float(caster->GetUInt32Value(UNIT_FIELD_STAT3)));
-		plus_damage += float2int32(static_cast< Player* >(caster)->SpellDmgDoneBySpr[school] * float(caster->GetUInt32Value(UNIT_FIELD_STAT4)));
+		for(uint32 a = 0; a < 6; a++)
+			plus_damage += float2int32(static_cast< Player* >(caster)->SpellDmgDoneByAttribute[a][school] * float(caster->GetUInt32Value(UNIT_FIELD_STAT0 + a)));
 	}
 //------------------------------by school---------------------------------------------------
 	plus_damage += caster->GetDamageDoneMod(school);
@@ -3953,21 +4212,32 @@
 //==============================+Spell Damage Bonus Modifications===========================
 //==========================================================================================
 //------------------------------by cast duration--------------------------------------------
-	SpellCastTime *sd = dbcSpellCastTime.LookupEntry(spellInfo->CastingTimeIndex);
-	float castaff = float(GetCastTime(sd));
-	if(castaff < 1500) castaff = 1500;
-	else
-		if(castaff > 7000) castaff = 7000;
+	float dmgdoneaffectperc = 1.0f;
+	// exception for spell with both dot and direct dmg - use bonus only for direct dmg for now
+	if (spellInfo->dmg_bonus && ((isDot && spellInfo->Effect[0] != SPELL_EFFECT_SCHOOL_DAMAGE && 
+		spellInfo->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE && spellInfo->Effect[2] != SPELL_EFFECT_SCHOOL_DAMAGE)
+		|| !isDot))
+	{
+		dmgdoneaffectperc = spellInfo->dmg_bonus/100.0f;
+	}
+	else if (!isDot) // this isnt valid for DoTs
+	{
+		SpellCastTime *sd = dbcSpellCastTime.LookupEntry(spellInfo->CastingTimeIndex);
+		float castaff = float(GetCastTime(sd));
+		if(castaff < 1500) castaff = 1500;
+		else
+			if(castaff > 7000) castaff = 7000;
 
-	float dmgdoneaffectperc = castaff / 3500;
-
+		dmgdoneaffectperc = castaff / 3500.0f;
+	}
+ 	else
+	{
+		//DOT-DD (Moonfire-Immolate-IceLance-Pyroblast)(Hack Fix)
+		float td = float( GetDuration( dbcSpellDuration.LookupEntry( spellInfo->DurationIndex )  ));
+		if( spellInfo->NameHash == SPELL_HASH_MOONFIRE || spellInfo->NameHash == SPELL_HASH_IMMOLATE || spellInfo->NameHash == SPELL_HASH_ICE_LANCE || spellInfo->NameHash == SPELL_HASH_PYROBLAST )
+			dmgdoneaffectperc *= float( 1.0f - ( ( td / 15000.0f ) / ( ( td / 15000.0f ) + dmgdoneaffectperc ) ) );
+	}
 	//------------------------------by downranking----------------------------------------------
-	//DOT-DD (Moonfire-Immolate-IceLance-Pyroblast)(Hack Fix)
-
-	float td = float( GetDuration( dbcSpellDuration.LookupEntry( spellInfo->DurationIndex )  ));
-	if( spellInfo->NameHash == SPELL_HASH_MOONFIRE || spellInfo->NameHash == SPELL_HASH_IMMOLATE || spellInfo->NameHash == SPELL_HASH_ICE_LANCE || spellInfo->NameHash == SPELL_HASH_PYROBLAST )
-		dmgdoneaffectperc *= float( 1.0f - ( ( td / 15000.0f ) / ( ( td / 15000.0f ) + dmgdoneaffectperc ) ) );
-
 	if(spellInfo->baseLevel > 0 && spellInfo->maxLevel > 0)
 	{
 		float downrank1 = 1.0f;
@@ -4276,6 +4546,9 @@
 		}break;
 	case CHAT_MSG_MONSTER_YELL:
 		{
+			if ( m_mapMgr == NULL )
+				return;
+
 			uint32 cell_radius = 2;
 			uint32 cellX = m_mapMgr->GetPosX(GetPositionX());
 			uint32 cellY = m_mapMgr->GetPosY(GetPositionY());
@@ -4314,8 +4587,31 @@
 					}
 				}
 			}
+		}break;
+	case CHAT_MSG_MONSTER_EMOTE:
+		{
+			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
+			{
+				if((*i)->GetTypeId() == TYPEID_PLAYER)
+				{
+					std::stringstream szMessage;
+					szMessage << UnitName << msg;
 
-
+					WorldPacket data(SMSG_MESSAGECHAT, 35 + UnitNameLength + MessageLength);
+					data << type;
+					data << lang;
+					data << GetGUID();
+					data << uint32(0);			// new in 2.1.0
+					data << uint32(UnitNameLength);
+					data << UnitName;
+					data << ((Player*)(*i))->GetGUID();
+					data << uint32(strlen(szMessage.str().c_str())+1);
+					data << szMessage.str().c_str();
+					data << uint8(0x00);
+					WorldSession *session = ((Player*)(*i))->GetSession();
+					session->SendPacket(&data);
+				}
+			}
 		}break;
 	case CHAT_MSG_CHANNEL:
 		{
@@ -4340,6 +4636,31 @@
 				}
 			}
 		}break;
+	case CHAT_MSG_RAID_BOSS_EMOTE:
+		{
+			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
+			{
+				if((*i)->GetTypeId() == TYPEID_PLAYER)
+				{
+					std::stringstream szMessage;
+					szMessage << UnitName << msg;
+
+					WorldPacket data(SMSG_MESSAGECHAT, 35 + UnitNameLength + MessageLength);
+					data << type;
+					data << lang;
+					data << GetGUID();
+					data << uint32(0);			// new in 2.1.0
+					data << uint32(UnitNameLength);
+					data << UnitName;
+					data << ((Player*)(*i))->GetGUID();
+					data << uint32(strlen(szMessage.str().c_str())+1);
+					data << szMessage.str().c_str();
+					data << uint8(0x00);
+					WorldSession *session = ((Player*)(*i))->GetSession();
+					session->SendPacket(&data);
+				}
+			}
+		}break;
 	}
 }
 
@@ -4474,7 +4795,7 @@
    if(this->IsPlayer())
 	   return m_floatValues[PLAYER_FIELD_MOD_DAMAGE_DONE_PCT+school];
 	else
-	   return ((Creature*)this)->ModDamageDonePct[school];
+		return static_cast< Creature* >(this)->ModDamageDonePct[school];
 }
 
 void Unit::CalcDamage()
@@ -4716,7 +5037,7 @@
 	for( uint32 x = 0; x < MAX_AURAS; x++ )
 	{
 		//a = m_auras[x];
-		if( m_auras[x] == NULL )
+		if( m_auras[x] == NULL || m_auras[x]->m_spellProto == NULL )
 			continue;
 		
 		//some spells do not get removed all the time only at specific intervals
@@ -4984,14 +5305,18 @@
 
 void Unit::RemoveAurasByBuffIndexType(uint32 buff_index_type, const uint64 &guid)
 {
-	if( buff_index_type == SPELL_TYPE_INDEX_JUDGEMENT )
-		return;
-
 	for( uint32 x = 0; x < MAX_AURAS; x++ )
 	{
-		if( m_auras[x] != NULL && m_auras[x]->GetSpellProto()->buffIndexType == buff_index_type )
-			if( !guid || ( guid && m_auras[x]->m_casterGuid == guid ) )
+		if( m_auras[x] != NULL && (m_auras[x]->GetSpellProto()->FlagsTargets & 0x0020) 
+			&& m_auras[x]->GetSpellProto()->MechanicsType == buff_index_type)
+		{
+			/*
+			if( m_auras[x]->GetSpellProto()->procCharges && guid == GetGUID())
+				continue;
+				*/
+			if( !guid || ( guid && m_auras[x]->m_casterGuid == guid ))
 				m_auras[x]->Remove();
+		}
 	}
 }
 
@@ -5132,7 +5457,7 @@
 			continue;
 
 		//some spells do not get removed all the time only at specific intervals
-		if( ( a->m_spellProto->AuraInterruptFlags & flag ) && ( a->m_spellProto->Id != skip ) && a->m_spellProto->proc_interval == 0 )
+		if( a->m_spellProto && ( a->m_spellProto->AuraInterruptFlags & flag ) && ( a->m_spellProto->Id != skip ) && a->m_spellProto->proc_interval == 0 )
 		{
 			//the black sheeps of sociaty
 			if( a->m_spellProto->AuraInterruptFlags & AURA_INTERRUPT_ON_CAST_SPELL )
@@ -5704,6 +6029,9 @@
 
 bool CombatStatusHandler::InternalIsInCombat()
 {
+	if(m_Unit->IsPlayer() && m_Unit->GetMapMgr() && m_Unit->GetMapMgr()->IsCombatInProgress())
+		return true;
+
 	if(m_healed.size() > 0)
 		return true;
 
Index: ascent-world/Unit.h
===================================================================
--- ascent-world/Unit.h	(revision 3944)
+++ ascent-world/Unit.h	(working copy)
@@ -812,7 +812,7 @@
 	void InterruptSpell();
 
 	//caller is the caster
-	int32 GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg);
+	int32 GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg, uint32 isDot);
    
 	Unit* create_guardian(uint32 guardian_entry,uint32 duration,float angle);//guardians are temporary spawn that will inherit master faction and will folow them. Apart from that they have their own mind
 
@@ -860,6 +860,7 @@
 	// DK:Affect
 	ASCENT_INLINE uint32 IsPacified() { return m_pacified; }
 	ASCENT_INLINE uint32 IsStunned() { return m_stunned; }
+	ASCENT_INLINE uint32 IsFeared() { return m_fearmodifiers; }
 	ASCENT_INLINE uint32 GetResistChanceMod() { return m_resistChance; }
 	ASCENT_INLINE void SetResistChanceMod(uint32 amount) { m_resistChance=amount; }
 	
@@ -1016,6 +1017,7 @@
 	int32 m_stunned;
 	int32 m_extraattacks;   
 	int32 m_extrastriketargets;
+	int32 m_fearmodifiers;
 	//std::set<SpellEntry*> m_onStrikeSpells;
 
 	int32 m_noInterrupt;
Index: ascent-world/WarsongGulch.cpp
===================================================================
--- ascent-world/WarsongGulch.cpp	(revision 3944)
+++ ascent-world/WarsongGulch.cpp	(working copy)
@@ -144,10 +144,14 @@
 		m_homeFlags[plr->GetTeam()]->PushToWorld( m_mapMgr );
 
 		/* give each player on that team a bonus 82 honor - burlex: is this correct amount? */
-		for(set<Player*>::iterator itr = m_players[plr->GetTeam()].begin(); itr != m_players[plr->GetTeam()].end(); ++itr)
+		for(set<uint32>::iterator itr = m_players[plr->GetTeam()].begin(); itr != m_players[plr->GetTeam()].end(); ++itr)
 		{
-			plr->m_bgScore.BonusHonor += 82;
-			HonorHandler::AddHonorPointsToPlayer(plr, 82);
+			Player *plr = objmgr.GetPlayer(*itr);
+			if ( plr != NULL )
+			{
+				plr->m_bgScore.BonusHonor += 82;
+				HonorHandler::AddHonorPointsToPlayer(plr, 82);
+			}
 		}
 
 		m_scores[plr->GetTeam()]++;
@@ -167,13 +171,17 @@
 			SpellEntry * loser_spell = dbcSpell.LookupEntry(24951);
 			for(uint32 i = 0; i < 2; ++i)
 			{
-				for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+				for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
 				{
-					(*itr)->Root();
-					if(i == m_winningteam)
-						(*itr)->CastSpell((*itr), winner_spell, true);
-					else
-						(*itr)->CastSpell((*itr), loser_spell, true);
+					Player *plr = objmgr.GetPlayer(*itr);
+					if ( plr != NULL )
+					{
+						plr->Root();
+						if(i == m_winningteam)
+							plr->CastSpell(plr, winner_spell, true);
+						else
+							plr->CastSpell(plr, loser_spell, true);
+					}
 				}
 			}
 			m_mainLock.Release();
@@ -324,7 +332,8 @@
 
 void WarsongGulch::OnAddPlayer(Player * plr)
 {
-	/* do we actually need to do anything special to the player? */
+	if(!m_started)
+		plr->CastSpell(plr, BG_PREPARATION, true);
 }
 
 void WarsongGulch::OnRemovePlayer(Player * plr)
@@ -332,6 +341,8 @@
 	/* drop the flag if we have it */
 	if( plr->m_bgHasFlag )
 		HookOnMount( plr );
+
+	plr->RemoveAura(BG_PREPARATION);
 }
 
 LocationVector WarsongGulch::GetStartingCoords(uint32 Team)
@@ -485,6 +496,17 @@
 
 void WarsongGulch::OnStart()
 {
+	m_started = true;
+
+	for(uint32 i = 0; i < 2; ++i) {
+		for(set<uint32>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
+		{
+			Player *plr = objmgr.GetPlayer(*itr);
+			if ( plr != NULL )
+				plr->RemoveAura(BG_PREPARATION);
+		}
+	}
+
 	/* open the gates */
 	for( list< GameObject* >::iterator itr = m_gates.begin(); itr != m_gates.end(); ++itr )
 	{
Index: ascent-world/World.cpp
===================================================================
--- ascent-world/World.cpp	(revision 3944)
+++ ascent-world/World.cpp	(working copy)
@@ -346,8 +346,6 @@
 	uint32 group_relation_rogue_elusiveness = 0;
 	uint32 group_relation_rogue_poisons = 0;
 	uint32 group_relation_rogue_find_weakness = 0;
-	uint32 group_relation_rogue_shadow_step = 0;
-	uint32 group_relation_rogue_lethality = 0;
 
 	// Start
 
@@ -808,61 +806,7 @@
 
 		// find diminishing status
 		sp->DiminishStatus = GetDiminishingGroup(namehash);
-		sp->buffIndexType = 0;
 
-		switch( namehash )
-		{
-		case SPELL_HASH_HUNTER_S_MARK:
-			sp->buffIndexType = SPELL_TYPE_INDEX_MARK;
-			break;
-
-		case SPELL_HASH_POLYMORPH:
-		case SPELL_HASH_POLYMORPH__CHICKEN:
-		case SPELL_HASH_POLYMORPH__PIG:
-		case SPELL_HASH_POLYMORPH__SHEEP:
-		case SPELL_HASH_POLYMORPH__TURTLE:
-			sp->buffIndexType = SPELL_TYPE_INDEX_POLYMORPH;
-			break;
-
-		case SPELL_HASH_FEAR:
-			sp->buffIndexType = SPELL_TYPE_INDEX_FEAR;
-			break;
-
-		case SPELL_HASH_SAP:
-			sp->buffIndexType = SPELL_TYPE_INDEX_SAP;
-			break;
-
-		case SPELL_HASH_SCARE_BEAST:
-			sp->buffIndexType = SPELL_TYPE_INDEX_SCARE_BEAST;
-			break;
-
-		case SPELL_HASH_HIBERNATE:
-			sp->buffIndexType = SPELL_TYPE_INDEX_HIBERNATE;
-			break;
-
-		//removed by Zack Earth shield stacks 10 times. Current code does not support it
-		//case SPELL_HASH_EARTH_SHIELD:
-		//	sp->buffIndexType = SPELL_TYPE_INDEX_EARTH_SHIELD;
-		//	break;
-
-		case SPELL_HASH_CYCLONE:
-			sp->buffIndexType = SPELL_TYPE_INDEX_CYCLONE;
-			break;
-
-		case SPELL_HASH_BANISH:
-			sp->buffIndexType = SPELL_TYPE_INDEX_BANISH;
-			break;
-
-		//case SPELL_HASH_JUDGEMENT_OF_VENGEANCE:
-		case SPELL_HASH_JUDGEMENT_OF_THE_CRUSADER:
-		case SPELL_HASH_JUDGEMENT_OF_LIGHT:
-		case SPELL_HASH_JUDGEMENT_OF_WISDOM:
-		case SPELL_HASH_JUDGEMENT_OF_JUSTICE:
-			sp->buffIndexType = SPELL_TYPE_INDEX_JUDGEMENT;
-			break;
-
-		}
-
 		// HACK FIX: Break roots/fear on damage.. this needs to be fixed properly!
 		if(!(sp->AuraInterruptFlags & AURA_INTERRUPT_ON_ANY_DAMAGE_TAKEN))
 		{
@@ -1003,14 +947,20 @@
 						pr|=PROC_ON_MELEE_ATTACK_VICTIM;
 					if( strstr( desc,"target casts a spell"))
 						pr|=PROC_ON_CAST_SPELL;
-                    if( strstr( desc,"your harmful spells land"))
-                        pr|=PROC_ON_CAST_SPELL;
-                    if( strstr( desc,"on spell critical hit"))
-                        pr|=PROC_ON_SPELL_CRIT_HIT;
-                    if( strstr( desc,"spell critical strikes"))
-                        pr|=PROC_ON_SPELL_CRIT_HIT;
-                    if( strstr( desc,"being able to resurrect"))
-                        pr|=PROC_ON_DIE;
+					if( strstr( desc,"your harmful spells land"))
+						pr|=PROC_ON_CAST_SPELL;
+					if( strstr( desc,"Nature spell have a chance"))
+						pr|=PROC_ON_CAST_SPELL;
+					if( strstr( desc,"Mangle ability has a chance"))
+						pr|=PROC_ON_CAST_SPELL;
+					if( strstr( desc,"Chance on spell cast"))
+						pr|=PROC_ON_CAST_SPELL;
+					if( strstr( desc,"on spell critical hit"))
+						pr|=PROC_ON_SPELL_CRIT_HIT;
+					if( strstr( desc,"spell critical strikes"))
+						pr|=PROC_ON_SPELL_CRIT_HIT;
+					if( strstr( desc,"being able to resurrect"))
+						pr|=PROC_ON_DIE;
 					if( strstr( desc,"any damage caused"))
 						pr|=PROC_ON_ANY_DAMAGE_VICTIM;
 					if( strstr( desc,"the next melee attack against the caster"))
@@ -1149,7 +1099,7 @@
 					if( strstr( nametext, "Bloodthirst"))
 						pr|=PROC_ON_MELEE_ATTACK | PROC_TARGET_SELF;
 					if( strstr( desc, "experience or honor"))
-						pr|=PROC_ON_GAIN_EXPIERIENCE;
+						pr|=PROC_ON_TARGET_DIE;
 					if( strstr( desc,"your next offensive ability"))
 						pr|=PROC_ON_CAST_SPELL;
 					if( strstr( desc,"hit by a melee or ranged attack"))
@@ -1313,9 +1263,6 @@
 		else if( strstr( nametext, "Shadow Weaving"))
 		{
 			sp->School = 5;
-			sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;
-			sp->procChance = sp->EffectBasePoints[0] + 1;
-			sp->procFlags = PROC_ON_CAST_SPECIFIC_SPELL;
 		}
 		//Improved Aspect of the Hawk
 		else if( strstr( nametext, "Improved Aspect of the Hawk"))
@@ -1407,7 +1354,7 @@
 			sp->SpellGroupType |= 16384; //some of them do have the flags but i's hard to write down those some from 130 spells
 			sp->c_is_flags |= SPELL_FLAG_IS_POISON;
 		}
-		else if( strstr( nametext, "Mind-Numbing Poison"))
+		else if( strstr( nametext, "Mind-numbing Poison"))
 		{
 			sp->SpellGroupType |= 32768; //some of them do have the flags but i's hard to write down those some from 130 spells
 			sp->c_is_flags |= SPELL_FLAG_IS_POISON;
@@ -1427,7 +1374,23 @@
 			sp->SpellGroupType |= 268435456; //some of them do have the flags but i's hard to write down those some from 130 spells
 			sp->c_is_flags |= SPELL_FLAG_IS_POISON;
 		}
+		else if( strstr( nametext, "Anesthetic Poison"))
+		{
+			//sp->SpellGroupType |= 268435456;
+			sp->c_is_flags |= SPELL_FLAG_IS_POISON;
+		}
 
+		switch( namehash )
+		{
+		//case SPELL_HASH_JUDGEMENT_OF_VENGEANCE:
+		case SPELL_HASH_JUDGEMENT_OF_THE_CRUSADER:
+		case SPELL_HASH_JUDGEMENT_OF_LIGHT:
+		case SPELL_HASH_JUDGEMENT_OF_WISDOM:
+		case SPELL_HASH_JUDGEMENT_OF_JUSTICE:
+			sp->c_is_flags = SPELL_FLAG_IS_JUDGEMENT;
+			break;
+		}
+
 		//warlock - shadow bolt
 		if( sp->NameHash == SPELL_HASH_SHADOW_BOLT )
 			sp->SpellGroupType |= 1; //some of them do have the flags but i's hard to write down those some from 130 spells
@@ -1475,6 +1438,7 @@
 			sp->procChance = 25;
 			sp->School = SCHOOL_HOLY; //the procspells of the original seal of command have fizical school instead of holy
 			sp->Spell_Dmg_Type = SPELL_DMG_TYPE_MAGIC; //heh, crazy spell uses melee/ranged/magic dmg type for 1 spell. Now which one is correct ?
+			sp->procFlags = PROC_ON_MELEE_ATTACK | PROC_ON_CRIT_ATTACK;
 		}
 
 		//Seal of Jusice - Proc Chance
@@ -1513,7 +1477,7 @@
 		}
 
 		if(
-			((sp->Attributes & ATTRIBUTES_TRIGGER_COOLDOWN) && (sp->AttributesEx & ATTRIBUTESEX_DELAY_SOME_TRIGGERS)) //rogue cold blood
+			((sp->Attributes & ATTRIBUTES_TRIGGER_COOLDOWN) && (sp->AttributesEx & ATTRIBUTESEX_NOT_BREAK_STEALTH)) //rogue cold blood
 			|| ((sp->Attributes & ATTRIBUTES_TRIGGER_COOLDOWN) && (!sp->AttributesEx || sp->AttributesEx & ATTRIBUTESEX_REMAIN_OOC))
 			)
 		{
@@ -1537,10 +1501,112 @@
 	if( parentsp != NULL && triggersp != NULL )
 		triggersp->EffectBasePoints[0] = parentsp->EffectBasePoints[0];
 
+	// Elemental Focus
 	SpellEntry* sp = dbcSpell.LookupEntryForced( 16164 );
 	if( sp != NULL && sp->Id == 16164 )
-		sp->procFlags = PROC_ON_SPELL_CRIT_HIT_VICTIM;
+		sp->procFlags = PROC_ON_SPELL_CRIT_HIT;
 
+	//"deal with the devil" custom spell based on unused dummy 
+	sp = dbcSpell.LookupEntry(32052);
+	if(sp != NULL)
+	{
+		sp->DurationIndex = 407;
+		sp->dummy = 1;
+		sp->procFlags = 0;
+		sp->Attributes = 0;
+		sp->AttributesEx = 0;
+		sp->Flags3 = 0;
+		sp->maxstack = 0;
+	}
+
+	//rogue - Vanish
+    sp = dbcSpell.LookupEntryForced( 18461 );
+    if( sp != NULL )
+        sp->AttributesEx |= ATTRIBUTESEX_NOT_BREAK_STEALTH;
+
+	sp = dbcSpell.LookupEntry(33076); //Prayer of Mending
+	if(sp != NULL)
+	{
+		sp->Effect[0] = 64;
+	}
+
+	sp = dbcSpell.LookupEntry( 33333 ); //Weakened Soul Reduction ( arena set bonus )
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0x20000000;
+
+
+	// Warp-Spring Coil
+	sp = dbcSpell.LookupEntry( 37173 );
+	if( sp != NULL )
+		sp->proc_interval = 30000;
+
+	// Hourglass of the Unraveler
+	sp = dbcSpell.LookupEntry( 33648 );
+	if( sp != NULL )
+		sp->proc_interval = 45000;
+
+	// Tsunami Talisman
+	sp = dbcSpell.LookupEntry( 42083 );
+	if( sp != NULL )
+		sp->proc_interval = 45000;
+	
+	// Dragonspine Trophy
+	sp = dbcSpell.LookupEntry( 34774 );
+	if( sp != NULL )
+		sp->proc_interval = 20000;
+
+	// Band of the Eternal ...
+	sp = dbcSpell.LookupEntry( 35080 );
+	if( sp != NULL )
+		sp->proc_interval = 60000;
+	sp = dbcSpell.LookupEntry( 35077 );
+	if( sp != NULL )
+		sp->proc_interval = 60000;
+	sp = dbcSpell.LookupEntry( 35086 );
+	if( sp != NULL )
+		sp->proc_interval = 60000;
+	sp = dbcSpell.LookupEntry( 35083 );
+	if( sp != NULL )
+		sp->proc_interval = 60000;
+
+	//Impale
+	sp = dbcSpell.LookupEntry( 16494 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
+	sp = dbcSpell.LookupEntry( 16493 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
+	//Mortal Shots
+	sp = dbcSpell.LookupEntry( 19485 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
+	sp = dbcSpell.LookupEntry( 19487 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
+	sp = dbcSpell.LookupEntry( 19488 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
+	sp = dbcSpell.LookupEntry( 19489 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
+	sp = dbcSpell.LookupEntry( 19490 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
+	sp = dbcSpell.LookupEntry( 36413 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
+
+
+	//Crusader Strike
+	sp = dbcSpell.LookupEntryForced( 35395 );
+	if( sp != NULL && sp->Id == 35395 )
+		sp->Spell_Dmg_Type = SPELL_DMG_TYPE_MELEE;
+
+	//Avenging Wrath
+	sp = dbcSpell.LookupEntryForced( 31884 );
+	if( sp != NULL && sp->Id == 31884 )
+		sp->MechanicsType = 25;
+
 	//remove stormstrike effect 0
 	sp = dbcSpell.LookupEntryForced( 17364 );
 	if( sp != NULL && sp->Id == 17364 )
@@ -1549,24 +1615,42 @@
 	//Warlock: Nether Protection
 	sp = dbcSpell.LookupEntryForced( 30299 );
 	if (sp != NULL)
+	{
 		sp->procChance = 10;
+		sp->proc_interval = 13000; //13 sec.
+	}
 	sp = dbcSpell.LookupEntryForced( 30301 );
 	if (sp != NULL)
+	{
 		sp->procChance = 20;
+		sp->proc_interval = 13000; //13 sec.
+	}
 	sp = dbcSpell.LookupEntryForced( 30302 );
 	if (sp != NULL)
+	{
 		sp->procChance = 30;
+		sp->proc_interval = 13000; //13 sec.
+	}
 
 	//Warlock: Backlash
 	sp = dbcSpell.LookupEntryForced( 34935 );
 	if (sp != NULL)
+	{
 		sp->procFlags |= PROC_ON_MELEE_ATTACK_VICTIM | PROC_TARGET_SELF;
+		sp->proc_interval = 8000;
+	}
 	sp = dbcSpell.LookupEntryForced( 34938 );
 	if (sp != NULL)
+	{
 		sp->procFlags |= PROC_ON_MELEE_ATTACK_VICTIM | PROC_TARGET_SELF;
+		sp->proc_interval = 8000;
+	}
 	sp = dbcSpell.LookupEntryForced( 34939 );
 	if (sp != NULL)
+	{
 		sp->procFlags |= PROC_ON_MELEE_ATTACK_VICTIM | PROC_TARGET_SELF;
+		sp->proc_interval = 8000;
+	}
 	sp = dbcSpell.LookupEntryForced( 34936 );
 	if (sp != NULL)
 	{
@@ -1626,6 +1710,20 @@
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
 	}
 
+	// Conjure Refreshment Table (Ritual of Refreshment)
+	sp = dbcSpell.LookupEntryForced( 43985 );
+    if( sp != NULL )
+    {
+		sp->EffectImplicitTargetA[0] = 47;
+    }
+
+	// Create Soulwell ( Ritual of Souls )
+	sp = dbcSpell.LookupEntryForced( 29886 );
+    if( sp != NULL )
+    {
+		sp->EffectImplicitTargetA[0] = 47;
+    }
+
     //Priest - Holy Nova
     sp = dbcSpell.LookupEntryForced( 15237 );
     if( sp != NULL )
@@ -1670,6 +1768,13 @@
         sp->EffectTriggerSpell[1] = 25329;
     }
 
+    // Mote Extractor
+	sp = dbcSpell.LookupEntryForced( 30427 );
+	if( sp != NULL )
+	{
+		sp->Effect[0] = SPELL_EFFECT_DUMMY;
+	}
+ 
 	// Moroes' garrote targets a single enemy instead of us
 	sp = dbcSpell.LookupEntryForced( 37066 );
     if( sp != NULL )
@@ -1771,6 +1876,24 @@
 		sp->EffectImplicitTargetB[2] = 0;
 	}
 
+	// Netherweave Net roots target instead of self
+	sp = dbcSpell.LookupEntryForced( 31368 );
+	if( sp != NULL )
+	{
+		sp->EffectImplicitTargetA[0] = 0;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_SINGLE_ENEMY;
+		sp->EffectImplicitTargetA[2] = 0;
+		sp->EffectImplicitTargetB[0] = 0;
+		sp->EffectImplicitTargetB[1] = 0;
+		sp->EffectImplicitTargetB[2] = 0;
+	}
+
+	sp = dbcSpell.LookupEntryForced( 34774 );
+	if( sp != NULL ) //dragonspine trophy proc
+	{
+		sp->procChance = 6;
+	}
+
 	//paladin - Blessing of Light. Changed to scripted because it needs to mod target and should not influence holy nova
 	sp = dbcSpell.LookupEntryForced( 19977 );
 	if( sp != NULL )
@@ -1918,6 +2041,7 @@
 	{
 		sp->procFlags = PROC_ON_MELEE_ATTACK;
         sp->EffectTriggerSpell[0] = 31803;
+		sp->procChance = 25;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;
 	}
 
@@ -2267,26 +2391,6 @@
 	sp = dbcSpell.LookupEntryForced( 16208 ); 
 	if( sp != NULL )
 		sp->EffectSpellGroupRelation[0] = group_relation_shaman_restorative_totems;
-	
-	//shaman - Healing Way
-	sp = dbcSpell.LookupEntryForced( 29202 ); 
-	if( sp != NULL )
-	{
-		sp->procFlags = PROC_ON_CAST_SPELL;
-		sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;
-	}
-	sp = dbcSpell.LookupEntryForced( 29205 ); 
-	if( sp != NULL )
-	{
-		sp->procFlags = PROC_ON_CAST_SPELL;
-		sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;
-	}
-	sp = dbcSpell.LookupEntryForced( 29206 ); 
-	if( sp != NULL )
-	{
-		sp->procFlags = PROC_ON_CAST_SPELL;
-		sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;
-	}
 
 	//shaman - Elemental Devastation
 	sp = dbcSpell.LookupEntryForced( 29179 ); 
@@ -2612,46 +2716,27 @@
 	if( sp != NULL )
 		sp->EffectSpellGroupRelation[0] = 1024 | 256; // Cheap Shot + Garrote
 
-
-	//rogue ( grouping ) Shadowstep
-	group_relation_rogue_shadow_step |= 512;//rogue - ambush (only a part of the whole group since it would affect other spells too)
-	group_relation_rogue_shadow_step |= 4;//rogue - Backstab (only a part of the whole group since it would affect other spells too)
-	group_relation_rogue_shadow_step |= 256;//Garrote
-	group_relation_rogue_shadow_step |= 536870912 | 16 | 8 | 8389120 | 41943040 | 33554432 | 32 | 67108864 | 64 | 128 ;
-
 	//rogue - Shadowstep
 	sp = dbcSpell.LookupEntryForced( 36563 ); 
 	if( sp != NULL )
-	{
-		sp->EffectSpellGroupRelation[1] = group_relation_rogue_shadow_step;
-		sp->EffectSpellGroupRelation_high[1] = 256 | 128 ;
-		sp->EffectMiscValue[1] = SMT_SPELL_VALUE;
-	}
+		sp->EffectSpellGroupRelation[1] = 0x800000;
 
-	//rogue ( grouping ) Lethality
-	group_relation_rogue_lethality |= 2;//rogue - Sinister Strike (only a part of the whole group since it would affect other spells too)
-	group_relation_rogue_lethality |= 4;//rogue - backstab (only a part of the whole group since it would affect other spells too)
-	group_relation_rogue_lethality |= 8;//rogue - Gouge (only a part of the whole group since it would affect other spells too)
-	group_relation_rogue_lethality |= 33554432UL;//rogue - Hemorrhage (only a part of the whole group since it would affect other spells too)
-	group_relation_rogue_lethality |= 536870912UL;//rogue - Shiv (only a part of the whole group since it would affect other spells too)
-	group_relation_rogue_lethality |= 1073741824UL;//rogue - Ghostly Strike (only a part of the whole group since it would affect other spells too)
-
 	//rogue Lethality
 	sp = dbcSpell.LookupEntryForced( 14128 ); 
 	if( sp != NULL )
-		sp->EffectSpellGroupRelation[0] = group_relation_rogue_lethality;
+		sp->EffectSpellGroupRelation[0] = 0x000002 | 0x000008 | 0x000004 | 0x4000000 | 0x20000000 | 0x800000 ;
 	sp = dbcSpell.LookupEntryForced( 14132 ); 
 	if( sp != NULL )
-		sp->EffectSpellGroupRelation[0] = group_relation_rogue_lethality;
+		sp->EffectSpellGroupRelation[0] = 0x000002 | 0x000008 | 0x000004 | 0x4000000 | 0x20000000 | 0x800000 ;
 	sp = dbcSpell.LookupEntryForced( 14135 ); 
 	if( sp != NULL )
-		sp->EffectSpellGroupRelation[0] = group_relation_rogue_lethality;
+		sp->EffectSpellGroupRelation[0] = 0x000002 | 0x000008 | 0x000004 | 0x4000000 | 0x20000000 | 0x800000 ;
 	sp = dbcSpell.LookupEntryForced( 14136 ); 
 	if( sp != NULL )
-		sp->EffectSpellGroupRelation[0] = group_relation_rogue_lethality;
+		sp->EffectSpellGroupRelation[0] = 0x000002 | 0x000008 | 0x000004 | 0x4000000 | 0x20000000 | 0x800000 ;
 	sp = dbcSpell.LookupEntryForced( 14137 ); 
 	if( sp != NULL )
-		sp->EffectSpellGroupRelation[0] = group_relation_rogue_lethality;
+		sp->EffectSpellGroupRelation[0] = 0x000002 | 0x000008 | 0x000004 | 0x4000000 | 0x20000000 | 0x800000 ;
 
 	//rogue - Endurance 
 	sp = dbcSpell.LookupEntryForced( 13742 ); 
@@ -3921,6 +4006,7 @@
 	}
 
 	//Mage - Spell Power
+	/*
 	sp = dbcSpell.LookupEntryForced( 35578 );
 	if( sp != NULL )
 	{
@@ -3933,7 +4019,7 @@
 		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;
 		//sp->EffectSpellGroupRelation_high[0] = 0xFFFFFFFF;
 	}
-
+*/
 	//Mage - Frost Channeling
 	sp = dbcSpell.LookupEntryForced( 11160 );
 	if( sp != NULL )
@@ -3983,27 +4069,28 @@
 	//Mage - Arcane Concentration
 	sp = dbcSpell.LookupEntryForced( 11213 );
 	if( sp != NULL )
-		sp->procFlags = PROC_ON_CAST_SPELL | PROC_TARGET_SELF;
+		sp->procFlags = PROC_ON_CAST_SPELL  | PROC_TARGET_SELF;
 	sp = dbcSpell.LookupEntryForced( 12574 );
 	if( sp != NULL )
-		sp->procFlags = PROC_ON_CAST_SPELL | PROC_TARGET_SELF;
+		sp->procFlags = PROC_ON_CAST_SPELL  | PROC_TARGET_SELF;
 	sp = dbcSpell.LookupEntryForced( 12575 );
 	if( sp != NULL )
-		sp->procFlags = PROC_ON_CAST_SPELL | PROC_TARGET_SELF;
+		sp->procFlags = PROC_ON_CAST_SPELL  | PROC_TARGET_SELF;
 	sp = dbcSpell.LookupEntryForced( 12576 );
 	if( sp != NULL )
-		sp->procFlags = PROC_ON_CAST_SPELL | PROC_TARGET_SELF;
+		sp->procFlags = PROC_ON_CAST_SPELL  | PROC_TARGET_SELF;
 	sp = dbcSpell.LookupEntryForced( 12577 );
 	if( sp != NULL )
 	{
-		sp->procFlags = PROC_ON_CAST_SPELL | PROC_TARGET_SELF;
-		//sp->procChance = 100;
+		sp->procFlags = PROC_ON_CAST_SPELL  | PROC_TARGET_SELF;
+		sp->procChance = 10;
 	}
 
 	//Mage - ClearCasting Effect
 	sp = dbcSpell.LookupEntryForced( 12536 );
 	if( sp != NULL )
 	{
+		sp->AuraInterruptFlags |= AURA_INTERRUPT_ON_CAST_SPELL;
 		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;		//!!!this will set value multiple times but we do not care since it is 100%
 		sp->EffectSpellGroupRelation_high[0] = 0xFFFFFFFF;	//!!!this will set value multiple times but we do not care since it is 100%
 	}	
@@ -4087,6 +4174,13 @@
 		sp->procChance = 100;
 	}
 
+	// Deadly Throw Interrupt
+	sp = dbcSpell.LookupEntryForced( 32748 );
+	if( sp != NULL )
+	{
+		sp->procFlags = PROC_ON_RANGED_ATTACK | PROC_ON_CAST_SPELL;
+	}
+
 	//druid Savage Fury
 	sp = dbcSpell.LookupEntryForced( 16998 );
 	if( sp != NULL ) 
@@ -4228,6 +4322,11 @@
 		sp->procFlags = PROC_ON_CAST_SPELL;
 		sp->procChance = 4;
 	}
+	sp = dbcSpell.LookupEntryForced( 17941 );
+	if( sp != NULL )
+	{
+		sp->AuraInterruptFlags |= AURA_INTERRUPT_ON_CAST_SPELL;
+	}
 
 	//warlock: Contagion
 	sp = dbcSpell.LookupEntryForced( 30060 );
@@ -4406,8 +4505,9 @@
 	sp = dbcSpell.LookupEntryForced( 12042 );
 	if( sp != NULL )
 	{
-		sp->EffectSpellGroupRelation[1] = 1 | 8192 | 4194304 | 8388608 | 262144 | 131072 | 536870912 | 524352 | 4 | 4096 | 2 | 2048 | 16;
-		sp->EffectSpellGroupRelation[2] = 1 | 8192 | 4194304 | 8388608 | 262144 | 131072 | 536870912 | 524352 | 4 | 4096 | 2 | 2048 | 16;
+		sp->EffectSpellGroupRelation[0] = 1 | 8192 | 4194304 | 8388608 | 262144 | 131072 | 536870912 | 524352 | 4 | 4096 | 2 | 2048 | 16;
+		sp->EffectSpellGroupRelation[1] = 0xFFFFFFFF;
+		sp->EffectSpellGroupRelation[2] = 0xFFFFFFFF;
 	}
 
 	//mage : Improved Blink
@@ -4689,10 +4789,6 @@
 	sp = dbcSpell.LookupEntryForced( 12497 );
 	if( sp != NULL )
 		sp->EffectApplyAuraName[0] = SPELL_AURA_DUMMY;
-	//rogue-shiv -> add 1 combo point
-	sp = dbcSpell.LookupEntryForced( 5938 );
-	if( sp != NULL )
-		sp->Effect[1]=80;
 
 	//warlock - Improved Curse of Weakness
 	sp = dbcSpell.LookupEntryForced( 18179 );
@@ -5515,29 +5611,6 @@
 		sp->procChance = 26; //god, save us from fixed values !
 	}
 
-	//Mage - Improved Scorch
-	sp = dbcSpell.LookupEntryForced( 11095 );
-	if( sp != NULL )
-	{
-		sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;
-		sp->procChance =33;
-		sp->procFlags = PROC_ON_CAST_SPELL;
-	}
-	sp = dbcSpell.LookupEntryForced( 12872 );
-	if( sp != NULL )
-	{
-		sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL; 
-		sp->procChance =66;
-		sp->procFlags = PROC_ON_CAST_SPELL;
-	}
-	sp = dbcSpell.LookupEntryForced( 12873 );
-	if( sp != NULL )
-	{
-		sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;
-		sp->procChance =100;
-		sp->procFlags = PROC_ON_CAST_SPELL;
-	}
-
 	//Nature's Grasp
 	sp = dbcSpell.LookupEntryForced( 16689 );
 	if( sp != NULL )
@@ -5815,14 +5888,6 @@
     if( sp != NULL )
         sp->rangeIndex = 4;
 
-	//Relentless Strikes
-	sp = dbcSpell.LookupEntryForced( 14179 );
-	if( sp != NULL )
-	{
-		sp->EffectApplyAuraName[0] = SPELL_AURA_PROC_TRIGGER_SPELL;//proc spell
-		sp->procFlags = PROC_ON_CAST_SPELL;
-		sp->EffectBasePoints[1] = 20; //client showes 20% chance but whe do not have it ? :O
-	}
 	//priest - surge of light
 	sp = dbcSpell.LookupEntryForced( 33150 );
 	if( sp != NULL )
@@ -5909,7 +5974,7 @@
 	{
 		sp->Effect[2] = 6;
 		sp->EffectApplyAuraName[2] = SPELL_AURA_PROC_TRIGGER_SPELL;
-		sp->EffectTriggerSpell[2] = 9174; //not sure if this is the one. In my time this adds 30 rage
+		sp->EffectTriggerSpell[2] = 23691;
 		sp->procFlags = PROC_ON_ANY_DAMAGE_VICTIM | PROC_TARGET_SELF;
 	}
 
@@ -5921,16 +5986,6 @@
 	if( sp != NULL )
 		sp->procFlags = PROC_ON_ANY_DAMAGE_VICTIM | PROC_TARGET_SELF;
 
-	//warrior - berserker rage is missing 1 effect = regenerate rage
-	sp = dbcSpell.LookupEntryForced( 18499 );
-	if( sp != NULL )
-	{
-		sp->Effect[2] = 6;
-		sp->EffectApplyAuraName[2] = SPELL_AURA_PROC_TRIGGER_SPELL;
-		sp->EffectTriggerSpell[2] = 9174; //not sure if this is the one. In my time this adds 30 rage
-		sp->procFlags = PROC_ON_ANY_DAMAGE_VICTIM | PROC_TARGET_SELF;
-	}
-
 	//warrior - Blood Frenzy
 	sp = dbcSpell.LookupEntryForced( 29836 );
 	if( sp != NULL )
@@ -6240,6 +6295,13 @@
         }
     }
 
+	// druid - Force of Nature
+	sp = dbcSpell.LookupEntryForced( 33831 );
+	if( sp != NULL )
+	{
+		sp->EffectRadiusIndex[1] = 13;
+	}
+
 	// druid - Tree of Life
 	sp = dbcSpell.LookupEntryForced( 5420 );
 	if( sp != NULL )
@@ -6248,6 +6310,13 @@
 		sp->EffectSpellGroupRelation_high[2] = 2 | 4096 | 128 | 524288 ;
 	}
 
+	// druid - Moonkin aura
+	sp = dbcSpell.LookupEntryForced( 24907 );
+	if( sp != NULL )
+	{
+		sp->RequiredShapeShift = 0;
+	}
+
 	// druid - Shredding Attacks
 	sp = dbcSpell.LookupEntryForced( 16966 );
 	if( sp != NULL )
@@ -6401,6 +6470,7 @@
 	sp = dbcSpell.LookupEntryForced( 16886 );
 	if( sp != NULL )
 	{
+		sp->AuraInterruptFlags |= AURA_INTERRUPT_ON_CAST_SPELL;
 		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF; //all spells, too bad not all spells have grouping flags :S
 		sp->procCharges = 0;
 	}
@@ -6471,6 +6541,74 @@
 	if( sp != NULL )
 		sp->EffectSpellGroupRelation[0] = 1;
 
+	//Libram of the Lightbringer
+	sp = dbcSpell.LookupEntryForced( 34231 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0x80000000;
+
+	//Libram of Absolute Truth
+	sp = dbcSpell.LookupEntryForced( 37739 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0x80000000;
+
+	//Libram of Divinity
+	sp = dbcSpell.LookupEntryForced( 28853 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0x40000000;
+
+	//Blessed Book of Nagrand
+	sp = dbcSpell.LookupEntryForced( 32403 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0x40000000;
+
+	//Libram of Light
+	sp = dbcSpell.LookupEntryForced( 28851 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 0x40000000;
+
+	//Libram of Truth
+	sp = dbcSpell.LookupEntryForced( 27850 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 64;
+
+	//Libram of the Eternal Rest
+	sp = dbcSpell.LookupEntryForced( 34252 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 32;
+
+	//Gladiator's Libram of Justice
+	sp = dbcSpell.LookupEntryForced( 34139 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 0x40000000;
+		sp->procFlags = PROC_ON_CAST_SPELL;
+	}
+
+	//Merciless Gladiator's Libram of Justice
+	sp = dbcSpell.LookupEntryForced( 42368 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 0x40000000;
+		sp->procFlags = PROC_ON_CAST_SPELL;
+	}
+
+	//Vengeful Gladiator's Libram of Justice
+	sp = dbcSpell.LookupEntryForced( 43726 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 0x40000000;
+		sp->procFlags = PROC_ON_CAST_SPELL;
+	}
+
+	//Libram of Mending
+	sp = dbcSpell.LookupEntryForced( 43741 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 0x80000000;
+		sp->procFlags = PROC_ON_CAST_SPELL | PROC_TARGET_SELF;
+	}
+
+
 	//Everbloom Idol
 	sp = dbcSpell.LookupEntryForced( 33693 );
 	if( sp != NULL )
@@ -7790,7 +7928,7 @@
 			{
 				mt = getMSTime();
 				itr->second->SaveToDB(false);
-				sLog.outString("Saved player `%s` (level %u) in %ums.", itr->second->GetName(), itr->second->GetUInt32Value(UNIT_FIELD_LEVEL), getMSTime() - mt);
+				//sLog.outString("Saved player `%s` (level %u) in %ums.", itr->second->GetName(), itr->second->GetUInt32Value(UNIT_FIELD_LEVEL), getMSTime() - mt);
 				++count;
 			}
 		}
@@ -8005,6 +8143,8 @@
 		new MailSystem;
 
 	channelmgr.seperatechannels = Config.MainConfig.GetBoolDefault("Server", "SeperateChatChannels", false);
+	PvpFactionLimitation = Config.MainConfig.GetBoolDefault("Server", "PvpFactionLimitation", true);
+	FriendFactionLimitation = Config.MainConfig.GetBoolDefault("Server", "FriendFactionLimitation", true);
 	sendRevisionOnJoin = Config.MainConfig.GetBoolDefault("Server", "SendBuildOnJoin", false);
 	MapPath = Config.MainConfig.GetStringDefault("Terrain", "MapPath", "maps");
 	UnloadMapFiles = Config.MainConfig.GetBoolDefault("Terrain", "UnloadMapFiles", true);
Index: ascent-world/World.h
===================================================================
--- ascent-world/World.h	(revision 3944)
+++ ascent-world/World.h	(working copy)
@@ -495,6 +495,8 @@
 
 	string MapPath;
 	bool UnloadMapFiles;
+	bool PvpFactionLimitation;
+	bool FriendFactionLimitation;
 	bool BreathingEnabled;
 
 	uint32 mInWorldPlayerCount;
Index: ascent-world/WorldCreator.cpp
===================================================================
--- ascent-world/WorldCreator.cpp	(revision 3944)
+++ ascent-world/WorldCreator.cpp	(working copy)
@@ -569,7 +569,7 @@
 				in = itr->second;
 				++itr;
 
-				if( in->m_mapInfo->type == INSTANCE_NONRAID && (plr->GetGroup() && plr->GetGroup()->GetID() == in->m_creatorGroup) || plr->GetGUIDLow() == in->m_creatorGuid )
+				if( ( in->m_mapInfo->type == INSTANCE_NONRAID && (plr->GetGroup() && plr->GetGroup()->GetID() == in->m_creatorGroup) ) || ( in->m_mapInfo->type == INSTANCE_NONRAID && plr->GetGUIDLow() == in->m_creatorGuid ) )
 				{
 					if(in->m_mapMgr && in->m_mapMgr->HasPlayers())
 					{
Index: ascent-world/WorldSession.cpp
===================================================================
--- ascent-world/WorldSession.cpp	(revision 3944)
+++ ascent-world/WorldSession.cpp	(working copy)
@@ -902,6 +902,7 @@
 	WorldPacketHandlers[MSG_MOVE_TELEPORT_CHEAT].handler = &WorldSession::HandleTeleportCheatOpcode;
 	WorldPacketHandlers[CMSG_TELEPORT_TO_UNIT].handler = &WorldSession::HandleTeleportToUnitOpcode;
 	WorldPacketHandlers[CMSG_WORLD_TELEPORT].handler = &WorldSession::HandleWorldportOpcode;
+	WorldPacketHandlers[CMSG_WHOIS].handler = &WorldSession::HandleWhoisOpcode;
 
 	// voicechat
 	WorldPacketHandlers[CMSG_ENABLE_MICROPHONE].handler = &WorldSession::HandleEnableMicrophoneOpcode;
Index: ascent-world/WorldSession.h
===================================================================
--- ascent-world/WorldSession.h	(revision 3944)
+++ ascent-world/WorldSession.h	(working copy)
@@ -670,6 +670,7 @@
 	void HandleTeleportCheatOpcode(WorldPacket & recv_data);
 	void HandleTeleportToUnitOpcode(WorldPacket & recv_data);
 	void HandleWorldportOpcode(WorldPacket & recv_data);
+	void HandleWhoisOpcode(WorldPacket & recv_data);
 	void HandleWrapItemOpcode(WorldPacket& recv_data);
 
 	// VOICECHAT
