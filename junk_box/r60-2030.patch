Index: trunk/src/game/AIInterface.cpp
===================================================================
--- trunk/src/game/AIInterface.cpp	(revision 2035)
+++ trunk/src/game/AIInterface.cpp	(working copy)
@@ -67,6 +67,7 @@
 	UnitToFear = NULL;
 	firstLeaveCombat = true;
 	m_outOfCombatRange = 2500;
+	m_outOfComabtInstanceMod = 1;
 
 	tauntedBy = NULL;
 	isTaunted = false;
@@ -636,6 +637,8 @@
 	AssistTargetSet::iterator i;
 	TargetMap::iterator itr;
 
+	if(m_outOfComabtInstanceMod == 1 && m_Unit->GetMapMgr()->GetMapInfo() && m_Unit->GetMapMgr()->GetMapInfo()->type != INSTANCE_NULL) m_outOfComabtInstanceMod = 16;
+
 	// Find new Assist Targets and remove old ones
 	if(m_AIState == STATE_FLEEING)
 	{
@@ -654,7 +657,7 @@
 		//modified for vs2005 compatibility
 		for(i = m_assistTargets.begin(); i != m_assistTargets.end(); ++i)
 		{
-			if(m_Unit->GetDistanceSq((*i)) > 2500.0f/*50.0f*/ || !(*i)->isAlive() || !(*i)->CombatStatus.IsInCombat())
+			if(m_Unit->GetDistanceSq((*i)) > (2500.0f*m_outOfComabtInstanceMod) || !(*i)->isAlive() || !(*i)->CombatStatus.IsInCombat())
 			{
 				tokill.push_back(*i);
 			}
@@ -737,11 +740,13 @@
 
 	uint16 agent = m_aiCurrentAgent;
 
+	if(m_outOfComabtInstanceMod == 1 && m_Unit->GetMapMgr()->GetMapInfo() && m_Unit->GetMapMgr()->GetMapInfo()->type != INSTANCE_NULL) m_outOfComabtInstanceMod = 16;
+
 	// If creature is very far from spawn point return to spawnpoint
 	// If at instance dont return -- this is wrong ... instance creatures always returns to spawnpoint, dunno how do you got this ideia. 
 
 	if(	m_AIType != AITYPE_PET 
-		&& (m_outOfCombatRange && m_Unit->GetDistanceSq(m_returnX,m_returnY,m_returnZ) > m_outOfCombatRange) 
+		&& (m_outOfCombatRange && m_Unit->GetDistanceSq(m_returnX,m_returnY,m_returnZ) > (m_outOfCombatRange*m_outOfComabtInstanceMod)) 
 		&& m_AIState != STATE_EVADE
 		&& m_AIState != STATE_SCRIPTMOVE)
 	{
Index: trunk/src/game/AIInterface.h
===================================================================
--- trunk/src/game/AIInterface.h	(revision 2035)
+++ trunk/src/game/AIInterface.h	(working copy)
@@ -395,6 +395,7 @@
 	bool m_hasFleed;
 	bool m_hasCalledForHelp;
 	uint32 m_outOfCombatRange;
+	uint32 m_outOfComabtInstanceMod;
 
 	Unit *m_Unit;
 	Unit *m_PetOwner;
Index: trunk/src/game/AreaTrigger.cpp
===================================================================
--- trunk/src/game/AreaTrigger.cpp	(revision 2035)
+++ trunk/src/game/AreaTrigger.cpp	(working copy)
@@ -193,6 +193,15 @@
 					return;
 				}
 
+				if((GetPlayer()->iInstanceType == MODE_HEROIC) && pMapinfo && (pMapinfo->heroic_keyid_1 || pMapinfo->heroic_keyid_2) && (!_player->GetItemInterface()->GetItemCount(pMapinfo->heroic_keyid_1, false) && (!_player->GetItemInterface()->GetItemCount(pMapinfo->heroic_keyid_2, false)))) 
+				{ 
+					WorldPacket msg(68); 
+					msg.Initialize(SMSG_AREA_TRIGGER_MESSAGE); 
+					msg << uint32(0) << "You do not have the required attunement to enter this instance."; 
+					SendPacket(&msg); 
+					return; 
+				} 
+
 				if(!GetPlayer()->isAlive())
 				{
 					pCorpse = objmgr.GetCorpseByOwner(GetPlayer()->GetGUIDLow());
Index: trunk/src/game/Arenas.cpp
===================================================================
--- trunk/src/game/Arenas.cpp	(revision 2035)
+++ trunk/src/game/Arenas.cpp	(working copy)
@@ -75,6 +75,70 @@
 	}
 
 	plr->m_deathVision = true;
+	plr->DropAurasOnDeath();
+
+	uint32 guid = (uint32)plr->GetSelection();
+
+	switch(plr->getClass())
+	{
+		case WARRIOR:
+		{
+			plr->ClearCooldownsOnLine(26, guid);
+			plr->ClearCooldownsOnLine(256, guid);
+			plr->ClearCooldownsOnLine(257 , guid);
+		} break;
+		case PALADIN:
+		{
+			plr->ClearCooldownsOnLine(594, guid);
+			plr->ClearCooldownsOnLine(267, guid);
+			plr->ClearCooldownsOnLine(184, guid);
+		} break;
+		case HUNTER:
+		{
+			plr->ClearCooldownsOnLine(50, guid);
+			plr->ClearCooldownsOnLine(51, guid);
+			plr->ClearCooldownsOnLine(163, guid);
+		} break;
+		case ROGUE:
+		{
+			plr->ClearCooldownsOnLine(253, guid);
+			plr->ClearCooldownsOnLine(38, guid);
+			plr->ClearCooldownsOnLine(39, guid);
+		} break;
+		case PRIEST:
+		{
+			plr->ClearCooldownsOnLine(56, guid);
+			plr->ClearCooldownsOnLine(78, guid);
+			plr->ClearCooldownsOnLine(613, guid);
+		} break;
+		case SHAMAN:
+		{
+			plr->ClearCooldownsOnLine(373, guid);
+			plr->ClearCooldownsOnLine(374, guid);
+			plr->ClearCooldownsOnLine(375, guid);
+		} break;
+		case MAGE:
+		{
+			plr->ClearCooldownsOnLine(6, guid);
+			plr->ClearCooldownsOnLine(8, guid);
+			plr->ClearCooldownsOnLine(237, guid);
+		} break;
+		case WARLOCK:
+		{
+			plr->ClearCooldownsOnLine(355, guid);
+			plr->ClearCooldownsOnLine(354, guid);
+			plr->ClearCooldownsOnLine(593, guid);
+		} break;
+		case DRUID:
+		{
+			plr->ClearCooldownsOnLine(573, guid);
+			plr->ClearCooldownsOnLine(574, guid);
+			plr->ClearCooldownsOnLine(134, guid);
+		} break;
+
+		default: break;
+	}
+
 	plr->CastSpell(plr, ARENA_PREPARATION, true);
 	UpdatePlayerCounts();
 
@@ -480,7 +544,7 @@
 
 void Player::FullHPMP()
 {
-	SetUInt32Value(UNIT_FIELD_HEALTH, m_uint32Values[UNIT_FIELD_MAXHEALTH]);
-	SetUInt32Value(UNIT_FIELD_POWER1, m_uint32Values[UNIT_FIELD_MAXPOWER1]);
-	SetUInt32Value(UNIT_FIELD_POWER4, m_uint32Values[UNIT_FIELD_MAXPOWER4]);
+	SetUInt32Value(UNIT_FIELD_HEALTH, GetUInt32Value(UNIT_FIELD_MAXHEALTH));
+	SetUInt32Value(UNIT_FIELD_POWER1, GetUInt32Value(UNIT_FIELD_MAXPOWER1));
+	SetUInt32Value(UNIT_FIELD_POWER4, GetUInt32Value(UNIT_FIELD_MAXPOWER4));
 }
Index: trunk/src/game/BattlegroundMgr.cpp
===================================================================
--- trunk/src/game/BattlegroundMgr.cpp	(revision 2035)
+++ trunk/src/game/BattlegroundMgr.cpp	(working copy)
@@ -963,7 +963,7 @@
 			data << uint8(0xC);
 			data << uint32(6);
 			data << uint16(0x1F90);
-			data << uint32(11);
+			data << InstanceID;
 			data << uint8(RatedMatch);		// 1 = rated match
 		}
 		else
Index: trunk/src/game/CharacterHandler.cpp
===================================================================
--- trunk/src/game/CharacterHandler.cpp	(revision 2035)
+++ trunk/src/game/CharacterHandler.cpp	(working copy)
@@ -26,6 +26,8 @@
 {
 	static const char * bannedCharacters = "\t\v\b\f\a\n\r\\\"\'\? <>[](){}_=+-|/!@#$%^&*~`.,0123456789\0";
 	const char * p;
+	if(stricmp(name, "Console") == 0)
+		return false;
 	for(size_t i = 0; i < nlen; ++i)
 	{
 		p = bannedCharacters;
@@ -264,7 +266,7 @@
 
 	//Same Faction limitation only applies to PVP and RPPVP realms :)
 	uint32 realmType = sLogonCommHandler.GetRealmType();
-	if(!HasGMPermissions() && (realmType==REALMTYPE_PVP||realmType==REALMTYPE_RPPVP))
+	if(!HasGMPermissions() && (realmType==REALMTYPE_PVP||realmType==REALMTYPE_RPPVP) && sWorld.PvpFactionLimitation)
 	{
 		if(
 			((pNewChar->GetTeam()== 0) && (_side == 2))||
Index: trunk/src/game/Creature.cpp
===================================================================
--- trunk/src/game/Creature.cpp	(revision 2035)
+++ trunk/src/game/Creature.cpp	(working copy)
@@ -832,15 +832,15 @@
 		ModUInt32Value(UNIT_FIELD_LEVEL, info->lvl_mod_a);
 
 	for(uint32 i = 0; i < 7; ++i)
-		SetUInt32Value(UNIT_FIELD_RESISTANCES+i,proto->Resistances[i]);
+		SetUInt32Value(UNIT_FIELD_RESISTANCES+i,(mode ? proto->Resistances[i]*1.5  : proto->Resistances[i]));
 
 	SetUInt32Value(UNIT_FIELD_BASEATTACKTIME,proto->AttackTime);
 	SetFloatValue(UNIT_FIELD_MINDAMAGE, (mode ? proto->MinDamage * 1.5  : proto->MinDamage));
 	SetFloatValue(UNIT_FIELD_MAXDAMAGE, (mode ? proto->MaxDamage * 1.5  : proto->MaxDamage));
 
 	SetUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,proto->RangedAttackTime);
-	SetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE,proto->RangedMinDamage);
-	SetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE,proto->RangedMaxDamage);
+	SetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE,(mode ? proto->RangedMinDamage * 1.5  : proto->RangedMinDamage));
+	SetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE,(mode ? proto->RangedMaxDamage * 1.5  : proto->RangedMaxDamage));
 
 	SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY, proto->Item1SlotDisplay);
 	SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY_01, proto->Item2SlotDisplay);
Index: trunk/src/game/GameObject.cpp
===================================================================
--- trunk/src/game/GameObject.cpp	(revision 2035)
+++ trunk/src/game/GameObject.cpp	(working copy)
@@ -512,7 +512,7 @@
 	//Open loot on success, otherwise FISH_ESCAPED.
 	if(Rand(((player->_GetSkillLineCurrent(SKILL_FISHING,true)-minskill)*100)/maxskill))
 	{			  
-		lootmgr.FillProfessionLoot(&lootmgr.FishingLoot,&loot,zone);
+		lootmgr.FillFishingLoot(&loot,zone);
 		player->SendLoot(GetGUID(),3);
 		EndFishing(player, false);
 	}
Index: trunk/src/game/HonorHandler.cpp
===================================================================
--- trunk/src/game/HonorHandler.cpp	(revision 2035)
+++ trunk/src/game/HonorHandler.cpp	(working copy)
@@ -97,6 +97,8 @@
 		return;
     if(pVictim && pVictim->IsPlayer() && static_cast<Player*>(pVictim)->m_bgTeam == pPlayer->m_bgTeam)
         return;
+	if(pPlayer->GetTeam() == static_cast<Player*>(pVictim)->GetTeam())
+		return;
 
 	// Calculate points
 	int32 Points = CalculateHonorPointsForKill(pPlayer, pVictim);
@@ -182,7 +184,7 @@
 	// Why are we multiplying by 10.. ho well
 	pPlayer->SetUInt32Value(PLAYER_FIELD_KILLS, pPlayer->m_killsToday);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, pPlayer->m_honorToday);
-	pPlayer->SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, pPlayer->m_killsYesterday | ( (pPlayer->m_honorYesterday * 10) << 16));
+	pPlayer->SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, pPlayer->m_killsYesterday /*| ( (pPlayer->m_honorYesterday * 10) << 16)*/);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS, pPlayer->m_killsLifetime);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_HONOR_CURRENCY, pPlayer->m_honorPoints);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_ARENA_CURRENCY, pPlayer->m_arenaPoints);
Index: trunk/src/game/Item.cpp
===================================================================
--- trunk/src/game/Item.cpp	(revision 2035)
+++ trunk/src/game/Item.cpp	(working copy)
@@ -677,16 +677,48 @@
 					TS.origId = 0;
 					TS.procFlags = PROC_ON_MELEE_ATTACK;
 					TS.procCharges = 0;
-					/* This needs to be modified based on the attack speed of the weapon.
-					 * Secondly, need to assign some static chance for instant attacks (ss,
-					 * gouge, etc.) */
-					if (!Entry->min[c] && GetProto()->Class == 2) {
-						uint32 speed = GetProto()->Delay;
-						TS.procChance = (uint32)((1.0*(float)speed)/600.0);
-					} else
+					if(!Entry->min[c])
+					{
+						//Crusader 20007
+						//Unholy Weapon 20006
+						//Lifestealing 20004
+						//Icy Weapon 20005
+						//Mongoose  28093
+						//Fiery Weapon 13897
+						float weapspeed = 1.0f;
+						if ((Entry->spell[c] >= 20004 && Entry->spell[c] <= 20007) || Entry->spell[c] == 28093 || Entry->spell[c] == 13897)
+						{
+							Item * itm = m_owner->GetItemInterface()->GetInventoryItem(EQUIPMENT_SLOT_MAINHAND);
+							if(itm)
+								weapspeed = itm->GetProto()->Delay / 1000;
+						}
+	
+						float base_proc = 5.0f;
+						switch(Entry->spell[c])
+						{
+							case 28093:
+							case 20007:
+								base_proc = 1.82f;
+							break;
+							case 13897:
+							case 20005:
+							case 20004:
+							case 20006:
+								base_proc = 7.87f;
+							break;
+							default: break;
+						}
+						
+						TS.procChance = (uint32)float(base_proc * weapspeed + 0.5);
+
+					}
+					else
+					{
 						TS.procChance = Entry->min[c];
-					Log.Debug("Enchant","Setting procChance to %u%%.", TS.procChance);
+					}
+
 					TS.deleted = false;
+					TS.from_weapon = (GetProto()->Class == ITEM_CLASS_WEAPON)? true : false;
 					TS.spellId = Entry->spell[c];
 					m_owner->m_procSpells.push_back(TS);
 				}
@@ -1046,7 +1078,7 @@
 	};
 
 	double value;
-	if(m_itemProto->Class == ITEM_CLASS_ARMOR && m_itemProto->Quality > ITEM_QUALITY_NORMAL_WHITE)
+	if(m_itemProto->Class == ITEM_CLASS_ARMOR && m_itemProto->Quality > ITEM_QUALITY_UNCOMMON_GREEN)
 		value = SuffixMods[m_itemProto->InventoryType] * 1.24;
 	else
 		value = SuffixMods[m_itemProto->InventoryType];
Index: trunk/src/game/ItemInterface.cpp
===================================================================
--- trunk/src/game/ItemInterface.cpp	(revision 2035)
+++ trunk/src/game/ItemInterface.cpp	(working copy)
@@ -1232,7 +1232,13 @@
 
 	if((slot < INVENTORY_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET) || (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET))
 	{
-		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat())
+		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat()
+			&& proto->InventoryType != INVTYPE_WEAPON && proto->InventoryType != INVTYPE_WEAPONMAINHAND
+			&& proto->InventoryType != INVTYPE_RANGED && proto->InventoryType != INVTYPE_WEAPONOFFHAND
+			&& proto->InventoryType != INVTYPE_SHIELD && proto->InventoryType != INVTYPE_2HWEAPON
+			&& proto->InventoryType != INVTYPE_AMMO && proto->InventoryType != INVTYPE_THROWN
+			&& proto->InventoryType != INVTYPE_RANGEDRIGHT
+			)
 			return INV_ERR_CANT_DO_IN_COMBAT;
 
 		// Check to see if we have the correct race
Index: trunk/src/game/LootMgr.cpp
===================================================================
--- trunk/src/game/LootMgr.cpp	(revision 2035)
+++ trunk/src/game/LootMgr.cpp	(working copy)
@@ -265,6 +265,7 @@
 			t.chance_2 = fields[4].GetFloat();
 			t.mincount = fields[5].GetUInt32();
 			t.maxcount = fields[6].GetUInt32();
+			t.ffa_loot = fields[7].GetUInt32();
 		}
 		else
 		{
@@ -330,6 +331,7 @@
 					list.items[ind].chance2 = itr2->chance_2;
 					list.items[ind].mincount = itr2->mincount;
 					list.items[ind].maxcount = itr2->maxcount;
+					list.items[ind].ffa_loot = itr2->ffa_loot;
 
 					if(LootTable == &GOLoot)
 					{
@@ -395,6 +397,8 @@
 			itm.iItemsCount = count;
 			itm.roll = NULL;
 			itm.passed = false;
+			itm.ffa_loot = list->items[x].ffa_loot;
+			itm.has_looted.clear();
 			
 			if (itemproto->Quality > 1 && itemproto->ContainerSlots==0)
 			{
@@ -435,6 +439,26 @@
 	else PushLoot(&tab->second,loot, heroic);
 }
 
+void LootMgr::FillFishingLoot(Loot * loot,uint32 loot_id)
+{
+	loot->items.clear();
+	loot->gold = 0;
+
+	LootStore::iterator tab = FishingLoot.find(loot_id);
+	if( FishingLoot.end() == tab) return;
+	else PushLoot(&tab->second, loot, false);
+}
+
+void LootMgr::FillSkinningLoot(Loot * loot,uint32 loot_id)
+{
+	loot->items.clear();
+	loot->gold = 0;
+
+	LootStore::iterator tab = SkinningLoot.find(loot_id);
+	if( SkinningLoot.end() == tab)return;
+	else PushLoot(&tab->second, loot, false);
+}
+
 void LootMgr::FillPickpocketingLoot(Loot * loot,uint32 loot_id)
 {
  loot->items.clear ();
@@ -445,54 +469,6 @@
  else PushLoot(&tab->second,loot,false);
 }
 
-//Puts 1 item always, no random properties
-void LootMgr::FillProfessionLoot(LootStore * store,Loot * loot,uint32 loot_id)
-{
-	loot->items.clear ();
-	loot->gold =0;
-	
-	LootStore::iterator tab =store->find(loot_id);
-	if( store->end()==tab)return;
-	StoreLootList *list=&(tab->second);
-	
-	// TODO: fix infinite loop with ' while(true) '
-	while(true)
-	for(uint32 x =0,pass=0; x<list->count; x++,pass++)
-	{
-		if(list->items[x].item.itemproto)// this check is needed until loot DB is fixed
-		{
-//			ItemPrototype *itemproto = ItemPrototypeStorage.LookupEntry(list->items[x].item.itemid);
-			if(Rand(list->items[x].chance))// || itemproto->Class == ITEM_CLASS_QUEST)
-			{
-				__LootItem itm;
-				itm.item =list->items[x].item;
-				itm.iItemsCount=1;
-				itm.passed = false;
-				itm.roll = 0;
-				/*if(itemproto->MaxCount>1)
-				{
-					uint32 c=1 + sRand.randInt(itemproto->MaxCount);
-					if(Rand(float(100.0/c)))
-						itm.iItemsCount=c;
-				
-				}*/
-				
-				itm.iRandomProperty=NULL;
-				itm.iRandomSuffix=NULL;
-			  
-				loot->items.push_back(itm);
-				return;
-			}	
-		}
-		
-		if(pass>100)
-		{
-			sLog.outError("WARNING: Loot %u has too low chances",loot_id);
-			return;		
-		}
-	}	
-}
-
 bool LootMgr::CanGODrop(uint32 LootId,uint32 itemid)
 {
 	LootStore::iterator tab =GOLoot.find(LootId);
@@ -564,55 +540,28 @@
 
 	WorldPacket data(34);
 
-	/* grab any player */
-	Player * gplr = NULL;
 	for(std::map<uint64, uint32>::iterator itr = NeedRolls.begin(); itr != NeedRolls.end(); ++itr)
 	{
-		gplr = _mgr->GetPlayer((uint32)itr->first);
-		if(gplr) break;
-	}
-	
-	if(!gplr)
-	{
-		for(std::map<uint64, uint32>::iterator itr = GreedRolls.begin(); itr != GreedRolls.end(); ++itr)
-		{
-			gplr = _mgr->GetPlayer((uint32)itr->first);
-			if(gplr) break;
-		}
-	}
-
-	for(std::map<uint64, uint32>::iterator itr = NeedRolls.begin(); itr != NeedRolls.end(); ++itr)
-	{
 		if(itr->second > highest)
 		{
 			highest = itr->second;
 			player = itr->first;
 			hightype = NEED;
 		}
-
-		data.Initialize(SMSG_LOOT_ROLL);
-		data << _guid << _slotid << itr->first;
-		data << _itemid << _itemunk1 << _itemunk2;
-		data << uint8(itr->second) << uint8(NEED);
-		if(gplr && gplr->GetGroup())
-			gplr->GetGroup()->SendPacketToAll(&data);
 	}
 
-	for(std::map<uint64, uint32>::iterator itr = GreedRolls.begin(); itr != GreedRolls.end(); ++itr)
+	if(!highest)
 	{
-		if(!highest && itr->second > highest)
+		for(std::map<uint64, uint32>::iterator itr = GreedRolls.begin(); itr != GreedRolls.end(); ++itr)
 		{
-			highest = itr->second;
-			player = itr->first;
-			hightype = GREED;
-		}
+			if(itr->second > highest)
+			{
+				highest = itr->second;
+				player = itr->first;
+				hightype = GREED;
+			}
 
-		data.Initialize(SMSG_LOOT_ROLL);
-		data << _guid << _slotid << itr->first;
-		data << _itemid << _itemunk1 << _itemunk2;
-		data << uint8(itr->second) << uint8(GREED);
-		if(gplr && gplr->GetGroup())
-			gplr->GetGroup()->SendPacketToAll(&data);
+		}
 	}
 
 	Loot * pLoot = 0;
@@ -752,14 +701,6 @@
 	if(NeedRolls.find(player->GetGUID()) != NeedRolls.end() || GreedRolls.find(player->GetGUID()) != GreedRolls.end())
 		return; // dont allow cheaters
 
-	std::map<uint64, uint32>* rmap = 0;
-	
-	if(choice == NEED) {
-		rmap = &NeedRolls;
-	} else if(choice == GREED) {
-		rmap = &GreedRolls;
-	}
-
 	int roll = sRand.randInt(99)+1;
 	// create packet
 	WorldPacket data(34);
@@ -767,14 +708,15 @@
 	data << _guid << _slotid << player->GetGUID();
 	data << _itemid << _itemunk1 << _itemunk2;
 
-	if(rmap)
+	if(choice == NEED) {
+		NeedRolls.insert( std::make_pair(player->GetGUID(), roll) );
+		data << uint8(roll) << uint8(NEED);
+	} 
+	else if(choice == GREED)
 	{
-		rmap->insert ( std::make_pair(player->GetGUID(), roll) );
-		if(choice == GREED)
-			data << uint8(0xF9) << uint8(0x00);
-		else
-			data << uint8(0xC1) << uint8(0x00);
-	}
+		GreedRolls.insert( std::make_pair(player->GetGUID(), roll) );
+		data << uint8(roll) << uint8(GREED);
+	} 
 	else
 	{
 		if(!_passedGuid)
@@ -782,8 +724,6 @@
 
 		data << uint8(128) << uint8(128);
 	}
-
-	data << uint8(roll) << uint8(choice);
 	
 	if(player->InGroup())
 		player->GetGroup()->SendPacketToAll(&data);
Index: trunk/src/game/LootMgr.h
===================================================================
--- trunk/src/game/LootMgr.h	(revision 2035)
+++ trunk/src/game/LootMgr.h	(working copy)
@@ -55,6 +55,8 @@
 	uint32 displayid;
 }_LootItem;
 
+typedef std::set<uint64> LooterSet;
+
 typedef struct
 {
 	_LootItem item;
@@ -63,6 +65,8 @@
 	ItemRandomSuffixEntry * iRandomSuffix;
 	LootRoll *roll;
 	bool passed;
+	LooterSet has_looted;
+	uint32 ffa_loot;
 }__LootItem;
 
 
@@ -73,6 +77,7 @@
 	float chance2;
 	uint32 mincount;
 	uint32 maxcount;
+	uint32 ffa_loot;
 }StoreLootItem;
 
 
@@ -82,8 +87,6 @@
 	StoreLootItem*items;
 }StoreLootList;
 
-typedef std::set<uint64> LooterSet;
-
 typedef struct
 {
 	std::vector<__LootItem> items;
@@ -98,6 +101,7 @@
 	float chance_2;
 	uint32 mincount;
 	uint32 maxcount;
+	uint32 ffa_loot;
 };
 
 
@@ -120,10 +124,11 @@
 	LootMgr();
 	~LootMgr();
 
-	void FillProfessionLoot(LootStore * store,Loot * loot,uint32 loot_id);
 	void FillCreatureLoot(Loot * loot,uint32 loot_id, bool heroic);
 	void FillGOLoot(Loot * loot,uint32 loot_id, bool heroic);
 	void FillItemLoot(Loot *loot, uint32 loot_id);
+	void FillFishingLoot(Loot * loot,uint32 loot_id);
+	void FillSkinningLoot(Loot * loot,uint32 loot_id);
 	void FillPickpocketingLoot(Loot *loot, uint32 loot_id);
 
 	bool CanGODrop(uint32 LootId,uint32 itemid);
Index: trunk/src/game/MiscHandler.cpp
===================================================================
--- trunk/src/game/MiscHandler.cpp	(revision 2035)
+++ trunk/src/game/MiscHandler.cpp	(working copy)
@@ -74,11 +74,26 @@
 
 	amt = pLoot->items.at(lootSlot).iItemsCount;
 
-	if (!amt)//Test for party loot
-	{  
-		GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
-		return;
-	} 
+	if (!pLoot->items.at(lootSlot).ffa_loot)
+	{
+		if (!amt)//Test for party loot
+		{  
+			GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
+			return;
+		}
+	}
+	else
+	{
+		//make sure this player can still loot it in case of ffa_loot
+		LooterSet::iterator itr = pLoot->items.at(lootSlot).has_looted.find(_player->GetGUID());
+
+		if (pLoot->items.at(lootSlot).has_looted.end() != itr)
+		{
+			GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
+			return;
+		}
+	}
+
 	itemid = pLoot->items.at(lootSlot).item.itemproto->ItemId;
 	ItemPrototype* it = pLoot->items.at(lootSlot).item.itemproto;
 
@@ -131,16 +146,29 @@
 		sQuestMgr.OnPlayerItemPickup(GetPlayer(),add);
 	}
 
-	pLoot->items.at(lootSlot).iItemsCount=0;
-	// this gets sent to all looters
-	WorldPacket data(1);
-	data.SetOpcode(SMSG_LOOT_REMOVED);
-	data << lootSlot;
-	Player * plr;
-	for(LooterSet::iterator itr = pLoot->looters.begin(); itr != pLoot->looters.end(); ++itr)
-	{
-		if((plr = _player->GetMapMgr()->GetPlayer(*itr)))
-			plr->GetSession()->SendPacket(&data);
+	//in case of ffa_loot update only the player who recives it.
+	if (!pLoot->items.at(lootSlot).ffa_loot)
+ 	{
+		pLoot->items.at(lootSlot).iItemsCount = 0;
+	
+		// this gets sent to all looters
+		WorldPacket data(1);
+		data.SetOpcode(SMSG_LOOT_REMOVED);
+		data << lootSlot;
+		Player * plr;
+		for(LooterSet::iterator itr = pLoot->looters.begin(); itr != pLoot->looters.end(); ++itr)
+		{
+			if((plr = _player->GetMapMgr()->GetPlayer(*itr)))
+				plr->GetSession()->SendPacket(&data);
+		}
+ 	}
+	else
+ 	{
+		pLoot->items.at(lootSlot).has_looted.insert(_player->GetGUID());
+		WorldPacket data(1);
+		data.SetOpcode(SMSG_LOOT_REMOVED);
+		data << lootSlot;
+		_player->GetSession()->SendPacket(&data);
 	}
 
     WorldPacket idata(45);
@@ -1605,11 +1633,26 @@
 
 	amt = pLoot->items.at(slotid).iItemsCount;
 
-	if (!amt)//Test for party loot
-	{  
-		GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
-		return;
-	} 
+	if (!pLoot->items.at(slotid).ffa_loot)
+	{
+		if (!amt)//Test for party loot
+		{  
+			GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
+			return;
+		} 
+	}
+	else
+	{
+		//make sure this player can still loot it in case of ffa_loot
+		LooterSet::iterator itr = pLoot->items.at(slotid).has_looted.find(player->GetGUID());
+
+		if (pLoot->items.at(slotid).has_looted.end() != itr)
+		{
+			GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
+			return;
+		}
+	}
+
 	itemid = pLoot->items.at(slotid).item.itemproto->ItemId;
 	ItemPrototype* it = pLoot->items.at(slotid).item.itemproto;
 
@@ -1648,19 +1691,26 @@
 	
 	sQuestMgr.OnPlayerItemPickup(player,item);
 
-	pLoot->items.at(slotid).iItemsCount=0;
+	if (!pLoot->items.at(slotid).ffa_loot)
+ 	{
+		pLoot->items.at(slotid).iItemsCount=0;
+ 
+		// this gets sent to all looters
+		WorldPacket data(1);
+		data.SetOpcode(SMSG_LOOT_REMOVED);
+		data << slotid;
+		Player * plr;
+		for(LooterSet::iterator itr = pLoot->looters.begin(); itr != pLoot->looters.end(); ++itr)
+		{
+			if((plr = _player->GetMapMgr()->GetPlayer(*itr)))
+				plr->GetSession()->SendPacket(&data);
+		}
+ 	}
+	else
+ 	{
+		pLoot->items.at(slotid).has_looted.insert(player->GetGUID());
+ 	}
 
-	// this gets sent to all looters
-	WorldPacket data(1);
-	data.SetOpcode(SMSG_LOOT_REMOVED);
-	data << slotid;
-	Player * plr;
-	for(LooterSet::iterator itr = pLoot->looters.begin(); itr != pLoot->looters.end(); ++itr)
-	{
-		if((plr = _player->GetMapMgr()->GetPlayer(*itr)))
-			plr->GetSession()->SendPacket(&data);
-	}
-
     WorldPacket idata(45);
     if(it->Class == ITEM_CLASS_QUEST)
     {
Index: trunk/src/game/Object.cpp
===================================================================
--- trunk/src/game/Object.cpp	(revision 2035)
+++ trunk/src/game/Object.cpp	(working copy)
@@ -2098,6 +2098,7 @@
 		Unit* caster = (Unit*)(this);
 		caster->RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_START_ATTACK);
 		int32 plus_damage = 0;
+		int32 plus_damage_victim = 0;
 		
 		if(caster->IsPlayer())
 		{
@@ -2106,10 +2107,10 @@
 		}
 //------------------------------by school---------------------------------------------------
 		plus_damage += caster->GetDamageDoneMod(school);
-		plus_damage += pVictim->DamageTakenMod[school];
+		plus_damage_victim += pVictim->DamageTakenMod[school];
 //------------------------------by victim type----------------------------------------------
 		if(((Creature*)pVictim)->GetCreatureName() && caster->IsPlayer()&& !pVictim->IsPlayer())
-			plus_damage += static_cast<Player*>(caster)->IncreaseDamageByType[((Creature*)pVictim)->GetCreatureName()->Type];
+			plus_damage_victim += static_cast<Player*>(caster)->IncreaseDamageByType[((Creature*)pVictim)->GetCreatureName()->Type];
 //==========================================================================================
 //==============================+Spell Damage Bonus Modifications===========================
 //==========================================================================================
@@ -2130,6 +2131,7 @@
 		if (spellInfo->NameHash == 0x695C4940 || spellInfo->NameHash == 0x3DD5C872 || spellInfo->NameHash == 0xddaf1ac7 || spellInfo->NameHash == 0xCB75E5D1)
 			dmgdoneaffectperc *= float (1.0f - (( td / 15000.0f ) / (( td / 15000.0f ) + dmgdoneaffectperc)));
 
+		float dmgdonepercdownrank = 1.0f;
 		if(spellInfo->baseLevel > 0 && spellInfo->maxLevel > 0)
 		{
 		   float downrank1 = 1.0f;
@@ -2138,12 +2140,20 @@
 		   float downrank2 = ( float(spellInfo->maxLevel + 5.0f) / float(static_cast<Player*>(this)->getLevel()) );
 		   if (downrank2 >= 1 || downrank2 < 0)
 		         downrank2 = 1.0f;
-			dmgdoneaffectperc *= downrank1 * downrank2;
+			dmgdonepercdownrank *= downrank1 * downrank2;
 		}
 //==========================================================================================
 //==============================Bonus Adding To Main Damage=================================
 //==========================================================================================
-		int32 bonus_damage = float2int32(plus_damage * dmgdoneaffectperc);
+		int32 bonus_damage = 0;
+		if(spellInfo->dmg_bonus)
+		{
+			bonus_damage = (int32)((plus_damage * spellInfo->dmg_bonus * dmgdonepercdownrank)/100);
+			bonus_damage += (int32)(plus_damage_victim * dmgdonepercdownrank);
+		}
+		else
+			bonus_damage = float2int32((plus_damage + plus_damage_victim) * dmgdoneaffectperc * dmgdonepercdownrank);
+
 		bonus_damage +=pVictim->DamageTakenMod[school];
 		if(spellInfo->SpellGroupType)
 		{
@@ -2260,14 +2270,10 @@
 	
 	if(this->IsUnit() && allowProc && spellInfo->Id != 25501)
 	{
+		static_cast<Unit*>(this)->HandleProc(aproc,pVictim,spellInfo, float2int32(res));
+		static_cast<Unit*>(this)->m_procCounter = 0;
 		pVictim->HandleProc(vproc,(Unit*)this,spellInfo, float2int32(res));
 		pVictim->m_procCounter = 0;
-
-		static_cast<Unit*>(this)->HandleProc(PROC_ON_CAST_SPECIFIC_SPELL | PROC_ON_CAST_SPELL,static_cast<Player*>(this), spellInfo);
-		static_cast<Unit*>(this)->m_procCounter = 0;
-
-		static_cast<Unit*>(this)->HandleProc(aproc,pVictim,spellInfo, float2int32(res));
-		static_cast<Unit*>(this)->m_procCounter = 0;
 	}
 	
 	DealDamage(pVictim, float2int32(res),  2, 0, spellID);
Index: trunk/src/game/ObjectMgr.cpp
===================================================================
--- trunk/src/game/ObjectMgr.cpp	(revision 2035)
+++ trunk/src/game/ObjectMgr.cpp	(working copy)
@@ -1817,6 +1817,32 @@
 	} while(result->NextRow());
 	delete result;
 	Log.Notice("ObjectMgr", "%u spell fixes loaded.", fixed_count);
+
+/*##########################################################################################*/
+
+	// Loads data from spell_data_extra table
+	QueryResult * result1 = WorldDatabase.Query("SELECT * FROM spell_data_extra");
+	if(result1 == 0) return;
+
+	uint32 override_count = 0;
+	do
+	{
+		Field * fields1 = result1->Fetch();
+		uint32 spell_id = fields1[0].GetUInt32();
+		SpellEntry * sp = dbcSpell.LookupEntry(spell_id);
+		if(sp == 0) 
+			continue;
+
+		if(sp->dmg_bonus == 0)
+		{
+			sp->dmg_bonus = fields1[1].GetUInt32();
+			override_count++;
+		}
+
+	} while (result1->NextRow());
+
+	delete result1;
+	Log.Notice("ObjectMgr", "%u spell data extra loaded.", override_count);
 }
 
 void ObjectMgr::LoadSpellOverride()
@@ -2441,9 +2467,19 @@
 			replimit = i->mob_rep_reward;
 		}
 
-		if(!value || (replimit && pPlayer->GetStanding(i->faction[team]) >= replimit))
+		if(!value)
 			continue;
 
+		if (pPlayer->iInstanceType != MODE_HEROIC)
+			if(replimit && pPlayer->GetStanding(i->faction[team]) >= replimit)
+				continue;
+
+		/*
+		Standing rank = pPlayer->GetReputationRankFromStanding(pPlayer->GetStanding(((Creature*)pVictim)->m_factionDBC->ID));
+		if(STANDING_EXALTED <= rank || STANDING_HATED >= rank)
+			continue;
+*/
+
 		//value *= sWorld.getRate(RATE_KILLREPUTATION);
 		value = float2int32(float(value) * sWorld.getRate(RATE_KILLREPUTATION));
 		pPlayer->ModStanding(i->faction[team], value);
Index: trunk/src/game/ObjectStorage.cpp
===================================================================
--- trunk/src/game/ObjectStorage.cpp	(revision 2035)
+++ trunk/src/game/ObjectStorage.cpp	(working copy)
@@ -34,7 +34,7 @@
 const char * gTeleportCoordFormat						= "uxufffx";
 const char * gPvPAreaFormat								= "ush";
 const char * gFishingFormat								= "uuu";
-const char * gWorldMapInfoFormat						= "uuuuufffusuuuuu";
+const char * gWorldMapInfoFormat						= "uuuuufffusuuuuuuu";
 const char * gZoneGuardsFormat							= "uuu";
 
 /** SQLStorage symbols
Index: trunk/src/game/Player.cpp
===================================================================
--- trunk/src/game/Player.cpp	(revision 2035)
+++ trunk/src/game/Player.cpp	(working copy)
@@ -352,7 +352,8 @@
 	m_ModInterrMRegenPCT = 0;
 	m_RegenManaOnSpellResist=0;
 	m_rap_mod_pct = 0;
-	m_modblockvalue = 0;
+	m_modblockabsorbvalue = 0;
+	m_modblockvaluefromspells = 0;
 	m_summoner = m_summonInstanceId = m_summonMapId = 0;
 	m_lastMoveType = 0;
 	m_tempSummon = 0;
@@ -3342,6 +3343,7 @@
 				ts.caster=this->GetGUID();
 				ts.procFlags=PROC_ON_MELEE_ATTACK;
 				ts.deleted = false;
+				ts.from_weapon = (item->GetProto()->Class == ITEM_CLASS_WEAPON)? true : false;
 				this->m_procSpells.push_front(ts);			
 			}
 		}
@@ -4855,6 +4857,10 @@
 		if (iter->iItemsCount == 0)
 			continue;
 
+		LooterSet::iterator itr = iter->has_looted.find(GetGUID());
+		if (iter->has_looted.end() != itr)
+			continue;
+
 		ItemPrototype* itemProto =iter->item.itemproto;
 		if (!itemProto)		   
 			continue;
@@ -4927,6 +4933,10 @@
 			/* if all people passed anyone can loot it? :P */
 			if(iter->passed)
 				slottype = 0;					// All players passed on the loot
+
+			//if it is ffa loot and not an masterlooter
+			if(iter->ffa_loot && slottype != 2)
+				slottype = 0;
 		}
 
 		data << uint8(x); 
@@ -4955,7 +4965,7 @@
 		
 		if(slottype == 1)
 		{
-			if(iter->roll == NULL && !iter->passed)
+			if(iter->roll == NULL && !iter->passed && !iter->ffa_loot)
 			{
 				int32 ipid = 0;
 				uint32 factor=0;
@@ -5134,6 +5144,22 @@
 	}
 }
 
+void Player::removeDeletedSpellByHashName(uint32 hash)
+{
+	SpellSet::iterator it,iter;
+	
+	for(iter= mDeletedSpells.begin();iter != mDeletedSpells.end();)
+	{
+		it = iter++;
+		uint32 SpellID = *it;
+		SpellEntry *e = dbcSpell.LookupEntry(SpellID);
+		if(e->NameHash == hash)
+		{
+			mDeletedSpells.erase(it);
+		}
+	}
+}
+
 void Player::removeSpellByHashName(uint32 hash)
 {
 	SpellSet::iterator it,iter;
@@ -5361,11 +5387,14 @@
 							//remove higher ranks of this spell too (like earth shield lvl 1 is talent and the rest is thought from trainer) 
 							SpellEntry *spellInfo2;
 							spellInfo2 = dbcSpell.LookupEntry( spellInfo->EffectTriggerSpell[k] );
-							if(spellInfo2)
-								removeSpellByHashName(spellInfo2->NameHash);
-						}
-					//remove them all in 1 shot
+							if(spellInfo2) {
+ 								removeSpellByHashName(spellInfo2->NameHash);
+								removeDeletedSpellByHashName(spellInfo2->NameHash);
+							}
+ 						}
+ 					//remove them all in 1 shot
 					removeSpellByHashName(spellInfo->NameHash);
+					removeDeletedSpellByHashName(spellInfo->NameHash);
 				}
 			}
 			else
@@ -5767,7 +5796,7 @@
 	const static float ClassFlatMod[12]={
 			0.0f,6.0f,6.0f,6.0f,2.0f,4.0f,0.0f,6.0f,4.0f,6.0f,0.0f,6.5f};
 
-	float amt;
+	float amt = 0.0f;
 	uint32 cur = GetUInt32Value(UNIT_FIELD_HEALTH);
 	uint32 mh = GetUInt32Value(UNIT_FIELD_MAXHEALTH);
 	if(cur >= mh)
Index: trunk/src/game/Player.h
===================================================================
--- trunk/src/game/Player.h	(revision 2035)
+++ trunk/src/game/Player.h	(working copy)
@@ -847,6 +847,7 @@
 	void smsg_InitialSpells();
 	void addSpell(uint32 spell_idy);
 	void removeSpellByHashName(uint32 hash);
+	void removeDeletedSpellByHashName(uint32 hash);
 	bool removeSpell(uint32 SpellID, bool MoveToDeleted, bool SupercededSpell, uint32 SupercededSpellID);
 
     // PLEASE DO NOT INLINE!
@@ -1256,7 +1257,8 @@
 	void EventAllowTiggerPort(bool enable);
 	int32 m_rangedattackspeedmod;
 	int32 m_meleeattackspeedmod;
-	uint32 m_modblockvalue;
+	uint32 m_modblockabsorbvalue;
+	uint32 m_modblockvaluefromspells;
 	void SendInitialLogonPackets();
 	void Reset_Spells();
 	void Reset_Talents();
Index: trunk/src/game/ReputationHandler.cpp
===================================================================
--- trunk/src/game/ReputationHandler.cpp	(revision 2035)
+++ trunk/src/game/ReputationHandler.cpp	(working copy)
@@ -427,7 +427,7 @@
 		{
 			for(it = m_Group->GetSubGroup(i)->GetGroupMembersBegin(); it != m_Group->GetSubGroup(i)->GetGroupMembersEnd(); ++it)
 			{
-				if(it->player)
+				if(it->player && it->player->isInRange(this,100.0f))
 					it->player->Reputation_OnKilledUnit(pUnit, true);
 			}
 		}
@@ -446,12 +446,21 @@
 				continue;
 
 			/* rep limit? */
-			if((*itr).replimit)
+			if (!IS_INSTANCE(GetMapId()) || (IS_INSTANCE(GetMapId()) && this->iInstanceType != MODE_HEROIC))
 			{
-				if(GetStanding((*itr).faction[team]) >= (int32)(*itr).replimit)
-					continue;
+				if((*itr).replimit)
+				{
+					if(GetStanding((*itr).faction[team]) >= (int32)(*itr).replimit)
+						continue;
+				}
 			}
 
+			/*
+			Standing rank = GetReputationRankFromStanding(GetStanding(pUnit->m_factionDBC->ID));
+			if(STANDING_EXALTED <= rank || STANDING_HATED >= rank)
+				continue;
+			*/
+
 			int32 value = int32(float(itr->value) * sWorld.getRate(RATE_KILLREPUTATION));
 			//value *= sWorld.getRate(RATE_KILLREPUTATION);
 			ModStanding(itr->faction[team], value);
Index: trunk/src/game/SocialMgr.cpp
===================================================================
--- trunk/src/game/SocialMgr.cpp	(revision 2035)
+++ trunk/src/game/SocialMgr.cpp	(working copy)
@@ -165,9 +165,9 @@
 		plr->GetSession()->SendPacket( &data );
 		return;
 	}
-	if( friendInfo->team != playerInfo->team )
+	if( friendInfo->team != playerInfo->team && sWorld.FriendFactionLimitation )
 	{
-		sLog.outDebug("SocialMgr: %s tried to add an ennemy to his friendlist", plr->GetName());
+		sLog.outDebug("SocialMgr: %s tried to add an enemy to his friendlist", plr->GetName());
 		data << (uint8)FRIEND_ENEMY << (uint64)friendInfo->guid;
 		plr->GetSession()->SendPacket( &data );
 		return;
@@ -244,7 +244,7 @@
 
 	if( pGuid == iGuid )
 	{
-		sLog.outDebug("SocialMgr: %s tried to add himself to his friendlist", plr->GetName());
+		sLog.outDebug("SocialMgr: %s tried to add himself to his ignorelist", plr->GetName());
 		data << (uint8)FRIEND_IGNORE_SELF << (uint64)iGuid;
 		plr->GetSession()->SendPacket(&data);
 		return;
Index: trunk/src/game/Spell.cpp
===================================================================
--- trunk/src/game/Spell.cpp	(revision 2035)
+++ trunk/src/game/Spell.cpp	(working copy)
@@ -1217,10 +1217,11 @@
 								HandleEffects((*i),x);
                             }
 						}
-						else if(m_spellInfo->Effect[x] == SPELL_EFFECT_TELEPORT_UNITS)
-                        {
-							HandleEffects(m_caster->GetGUID(),x);
-                        }
+						else
+							{
+								if(m_spellInfo->Effect[x] == SPELL_EFFECT_TELEPORT_UNITS)
+ 									HandleEffects(m_caster->GetGUID(),x);
+							}
 					}
 				}
 	
@@ -1951,7 +1952,21 @@
 	if(m_spellInfo->ManaCostPercentage)//Percentage spells cost % of !!!BASE!!! mana
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
-			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)*m_spellInfo->ManaCostPercentage)/100;
+		{
+			uint32 mana_from_base_int = 0;
+			if(m_caster->IsPlayer())
+			{
+				Player * plr = static_cast<Player*>(m_caster);
+
+				LevelInfo * Info = objmgr.GetLevelInfo(plr->getRace(), plr->getClass(), plr->getLevel());
+				LevelInfo * InfoFirst = objmgr.GetLevelInfo(plr->getRace(), plr->getClass(), 1);
+
+				if(Info != 0 && InfoFirst != 0)
+					mana_from_base_int = (Info->Stat[3] - InfoFirst->Stat[3])*15;
+			}
+
+			cost = ((m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)-mana_from_base_int)*m_spellInfo->ManaCostPercentage)/100;
+		}
 		else
 			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_HEALTH)*m_spellInfo->ManaCostPercentage)/100;
 	}
@@ -1961,7 +1976,14 @@
 	}
 
 	if(m_spellInfo->powerType==POWER_TYPE_HEALTH)
-		cost -= m_spellInfo->baseLevel;//FIX for life tap	
+		{
+		// For Life Tap don't do repeat damage process
+		if (m_spellInfo->NameHash == 0x0807C866) return true;
+
+		// The caster doesnt have enough health to use this spell...stop casting
+		if (u_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= (uint32)cost) 
+			return false;
+	}
 	else if(u_caster)
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
@@ -2049,7 +2071,20 @@
 	if(m_spellInfo->ManaCostPercentage)//Percentage spells cost % of !!!BASE!!! mana
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
-			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)*m_spellInfo->ManaCostPercentage)/100;
+		{
+			uint32 mana_from_base_int = 0;
+			if(m_caster->IsPlayer())
+			{
+				Player * plr = static_cast<Player*>(m_caster);
+
+				LevelInfo * Info = objmgr.GetLevelInfo(plr->getRace(), plr->getClass(), plr->getLevel());
+				LevelInfo * InfoFirst = objmgr.GetLevelInfo(plr->getRace(), plr->getClass(), 1);
+
+				if(Info != 0 && InfoFirst != 0)
+					mana_from_base_int = (Info->Stat[3] - InfoFirst->Stat[3])*15;
+			}
+			cost = ((m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)-mana_from_base_int)*m_spellInfo->ManaCostPercentage)/100;
+		}
 		else
 			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_HEALTH)*m_spellInfo->ManaCostPercentage)/100;
 	}
@@ -2654,6 +2689,14 @@
 
 	if(p_caster)
 	{
+		// Caster is confused. They can't cast any spells except...
+		if ((p_caster->HasFlag(UNIT_FIELD_FLAGS, U_FIELD_FLAG_UNKNOWN18)) && 
+			// Divine Protection, Divine Shield, Arcane Bubble, Ice Block
+			((m_spellInfo->EffectMiscValue[3] != SPELL_EFFECT_UNKNOWN5) && (m_spellInfo->Category != 37) || 
+			// Stoneform
+			(m_spellInfo->Id != 20594)))
+			return SPELL_FAILED_SILENCED;
+
 		if (p_caster->m_bgHasFlag)
 		{
 			switch(m_spellInfo->Id)
@@ -3390,7 +3433,11 @@
 
 		float healdoneaffectperc = castaff / 3500;
 		
-		amount += float2int32(u_caster->HealDoneMod[m_spellInfo->School] * healdoneaffectperc);
+		if(!m_spellInfo->dmg_bonus)
+			amount += float2int32(u_caster->HealDoneMod[m_spellInfo->School] * healdoneaffectperc);
+		else
+			amount += float2int32((u_caster->HealDoneMod[m_spellInfo->School]*m_spellInfo->dmg_bonus)/100);
+
 		amount += (amount*u_caster->HealDonePctMod[m_spellInfo->School])/100;
 		amount += unitTarget->HealTakenMod[m_spellInfo->School];//amt of health that u RECIVE, not heal
 		amount += float2int32(unitTarget->HealTakenPctMod[m_spellInfo->School]*amount);
@@ -3446,9 +3493,6 @@
 	else
 		unitTarget->ModUInt32Value(UNIT_FIELD_HEALTH, amount);
 
-	if(p_caster)
-		p_caster->HandleProc(PROC_ON_CAST_SPECIFIC_SPELL | PROC_ON_CAST_SPELL,p_caster, m_spellInfo);
-	
 	int doneTarget = 0;
 
 	// add threat
Index: trunk/src/game/SpellAuras.cpp
===================================================================
--- trunk/src/game/SpellAuras.cpp	(revision 2035)
+++ trunk/src/game/SpellAuras.cpp	(working copy)
@@ -170,7 +170,7 @@
 		&Aura::SpellAuraNULL,//SPELL_AURA_ADD_CREATURE_IMMUNITY = 147,//http://wow.allakhazam.com/db/spell.html?wspell=36798
 		&Aura::SpellAuraRetainComboPoints,//SPELL_AURA_RETAIN_COMBO_POINTS = 148,
 		&Aura::SpellAuraResistPushback,//SPELL_AURA_RESIST_PUSHBACK = 149,//	Resist Pushback //Simply resist spell casting delay
-		&Aura::SpellAuraModShieldBlockPCT,//SPELL_AURA_MOD_SHIELD_BLOCK_PCT = 150,//	Mod Shield Block %
+		&Aura::SpellAuraModShieldBlockPCT,//SPELL_AURA_MOD_SHIELD_BLOCK_PCT = 150,//	Mod Shield Absorbed dmg %
 		&Aura::SpellAuraTrackStealthed,//SPELL_AURA_TRACK_STEALTHED = 151,//	Track Stealthed
 		&Aura::SpellAuraModDetectedRange,//SPELL_AURA_MOD_DETECTED_RANGE = 152,//	Mod Detected Range
 		&Aura::SpellAuraSplitDamageFlat,//SPELL_AURA_SPLIT_DAMAGE_FLAT= 153,//	Split Damage Flat
@@ -559,6 +559,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.from_weapon = false;
 			m_target->m_procSpells.push_front(pts);
 		}
 		else
@@ -1057,7 +1058,7 @@
 			c->RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_START_ATTACK);
 			
 			float bonus_damage = c->GetDamageDoneMod(school);
-			bonus_damage += float(m_target->DamageTakenMod[school]);
+			float bonus_damage_victim = float(m_target->DamageTakenMod[school]);
 			if(c->IsPlayer())
 			{
 				bonus_damage += static_cast<Player*>(c)->SpellDmgDoneByInt[school] * c->GetUInt32Value(UNIT_FIELD_STAT3);
@@ -1073,8 +1074,18 @@
 			if(GetDuration())
 			{
 				int ticks= (amp) ? GetDuration()/amp : 0;
-				bonus += (ticks) ? bonus_damage/ticks : 0;
-				bonus *= GetDuration() / 15000.0f;
+
+				if (m_spellProto->dmg_bonus && m_spellProto->Effect[0] != SPELL_EFFECT_SCHOOL_DAMAGE && 
+					m_spellProto->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE && m_spellProto->Effect[2] != SPELL_EFFECT_SCHOOL_DAMAGE )
+				{
+					bonus += (ticks) ? ((bonus_damage*m_spellProto->dmg_bonus*0.01)+bonus_damage_victim)/ticks : 0;
+				}
+				else
+				{
+					bonus += (ticks) ? (bonus_damage+bonus_damage_victim)/ticks : 0;
+					if(!m_spellProto->ChannelInterruptFlags)
+						bonus *= GetDuration() / 15000.0f;
+				}
 			}
 			else bonus = 0;
 			res += bonus;
@@ -1273,6 +1284,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.from_weapon = false;
 			m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1649,6 +1661,7 @@
 				pts.procCharges = GetSpellProto()->procCharges;
 				pts.LastTrigger = 0;
 				pts.deleted = false;
+				pts.from_weapon = false;
 				m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1791,9 +1804,14 @@
 
 		if(p_target)
 		{
+			static_cast<Player*>(m_target)->EventAttackStop();
 			m_target->setAItoUse(true);
+
+			WorldPacket data1(9);
+			data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
+			data1 << m_target->GetNewGUID() << uint8(0x00);
+			static_cast<Player*>(m_target)->GetSession()->SendPacket(&data1);
 		}
-		m_target->m_pacified++;
 		m_target->m_special_state |= UNIT_STATE_FEAR;
 		m_target->SetFlag(UNIT_FIELD_FLAGS, U_FIELD_FLAG_FEARED);
 		m_target->GetAIInterface()->HandleEvent(EVENT_FEAR, u_caster, 0);
@@ -1803,12 +1821,16 @@
 		m_target->GetAIInterface()->HandleEvent(EVENT_UNFEAR, u_caster, 0);
 		m_target->RemoveFlag(UNIT_FIELD_FLAGS, U_FIELD_FLAG_FEARED);
 		m_target->m_special_state &= ~UNIT_STATE_FEAR;
-		m_target->m_pacified--;
 
 		if(p_target)
 		{
 			m_target->setAItoUse(false);
 			sHookInterface.OnEnterCombat(p_target, u_caster);
+
+			WorldPacket data1(9);
+			data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
+			data1 << m_target->GetNewGUID() << uint8(0x01);
+			static_cast<Player*>(m_target)->GetSession()->SendPacket(&data1);
 		}
 		else
 			m_target->GetAIInterface()->AttackReaction(u_caster, 1, 0);
@@ -1832,6 +1854,7 @@
 	Unit * c = GetUnitCaster();
 
 	int bonus = 0;
+	int bonus_target = 0;
 
 	if(c && c->IsPlayer())
 	{
@@ -1842,17 +1865,25 @@
 		if (static_cast<Player*>(c)->IsInFeralForm() && static_cast<Player*>(c)->GetShapeShift() == FORM_TREE)
 			bonus += float2int32(0.25f*((Player*)c)->GetUInt32Value(UNIT_FIELD_STAT4));
 	}
-	bonus += m_target->HealTakenMod[GetSpellProto()->School];
+	bonus_target += m_target->HealTakenMod[GetSpellProto()->School];
 
 	int amp = m_spellProto->EffectAmplitude[mod->i];
-	if(!amp) 
+	if(!amp)
 		amp=((EventableObject*)this)->event_GetEventPeriod(EVENT_AURA_PERIODIC_HEAL);
 
 	if(GetDuration())
 	{
 		int ticks= (amp) ? GetDuration()/amp : 0;
-		bonus= (ticks) ? bonus/ticks : 0;
-		bonus *= GetDuration() / 15000.0f;
+		if (!m_spellProto->dmg_bonus)
+		{
+			bonus = (ticks) ? (bonus+bonus_target)/ticks : 0;
+			if(!m_spellProto->ChannelInterruptFlags)
+				bonus *= GetDuration() / 15000.0f;
+		}
+		else
+		{
+			bonus = (ticks) ? ((bonus*m_spellProto->dmg_bonus/100)+bonus_target)/ticks : 0;
+		}
 	}
 	else bonus = 0;
 
@@ -2480,7 +2511,7 @@
 {
 	// Trigger Spell
 	// check for spell id
-
+	printf("\n\n+++Aura::EventPeriodicTriggerSpell ID: %u\n\n\n",spellInfo->Id);
 	Unit *m_caster=GetUnitCaster();
 	if(!m_caster || !m_caster->IsInWorld())
 		return;
@@ -3343,6 +3374,7 @@
 		pts.procCharges = GetSpellProto()->procCharges;
 		pts.LastTrigger = 0;
 		pts.deleted = false;
+		pts.from_weapon = false;
 
 		if(m_spellProto->NameHash == 0xE4573D4A)
 		{
@@ -3524,7 +3556,6 @@
 		else 
 			amt = -mod->m_amount;
 
-		//static_cast<Player*>(m_target)->SetBlockFromSpellPCT(static_cast<Player*>(m_target)->GetBlockFromSpellPCT() + amt );
 		static_cast<Player*>(m_target)->SetBlockFromSpell(static_cast<Player*>(m_target)->GetBlockFromSpell() + amt);
 		static_cast<Player*>(m_target)->UpdateChances();
 	}
@@ -4542,7 +4573,17 @@
 void Aura::SpellAuraModRegenPercent(bool apply)
 {
 	if(apply)
+	{
 		m_target->PctRegenModifier += ((float)(mod->m_amount))/100.0;
+
+		if (GetSpellProto()->Flags3 & FLAGS3_FUNNEL) 
+		{
+			uint32 dmg = GetSpellProto()->manaPerSecond;
+			sEventMgr.AddEvent(this, &Aura::EventPeriodicDamage,dmg, 
+				EVENT_AURA_PERIODIC_DAMAGE,GetSpellProto()->EffectAmplitude[0],0,EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
+			SetNegative();
+		}
+	}
 	else
 		m_target->PctRegenModifier -= ((float)(mod->m_amount))/100.0;
 }
@@ -5648,25 +5689,17 @@
 
 void Aura::SpellAuraModShieldBlockPCT(bool apply)
 {
-	//old = this is wrong since we will overwrite it at first state recalc
-//	m_target->ModFloatValue(PLAYER_BLOCK_PERCENTAGE, apply ? mod->m_amount : -mod->m_amount);
-	//new
-	if (m_target->GetTypeId() == TYPEID_PLAYER)
+
+	if(p_target)
 	{
-		int32 amt;
 		if(apply)
 		{
-			amt = mod->m_amount;
-			if(amt<0)
-				SetNegative();
-			else 
-				SetPositive();
+			p_target->m_modblockabsorbvalue += (uint32)mod->m_amount;
 		}
-		else 
-			amt = -mod->m_amount;
-
-		static_cast<Player*>(m_target)->SetBlockFromSpell(static_cast<Player*>(m_target)->GetBlockFromSpell() + amt );
-		static_cast<Player*>(m_target)->UpdateChances();
+		else
+		{
+			p_target->m_modblockabsorbvalue -= (uint32)mod->m_amount;
+		}
 	}
 }
 
@@ -6695,16 +6728,21 @@
 
 void Aura::SpellAuraModBlockValue(bool apply)
 {
-	if(p_target)
+	if (p_target)
 	{
+		int32 amt;
 		if(apply)
 		{
-			p_target->m_modblockvalue += (uint32)mod->m_amount;
+			amt = mod->m_amount;
+			if(amt<0)
+				SetNegative();
+			else 
+				SetPositive();
 		}
-		else
-		{
-			p_target->m_modblockvalue -= (uint32)mod->m_amount;
-		}
+		else 
+			amt = -mod->m_amount;
+
+		p_target->m_modblockvaluefromspells += amt;
 	}
 }
 
Index: trunk/src/game/SpellAuras.h
===================================================================
--- trunk/src/game/SpellAuras.h	(revision 2035)
+++ trunk/src/game/SpellAuras.h	(working copy)
@@ -306,6 +306,7 @@
     uint32 LastTrigger;
 	uint32 ProcType; //0=talents/spells 1=weapon 2=armor  TODO: implement.
     bool deleted;
+	bool from_weapon;
 };
 
 struct SpellCharge
Index: trunk/src/game/SpellEffects.cpp
===================================================================
--- trunk/src/game/SpellEffects.cpp	(revision 2035)
+++ trunk/src/game/SpellEffects.cpp	(working copy)
@@ -517,6 +517,7 @@
 
 		uint32 damage = m_spellInfo->EffectBasePoints[i]+1;
 		uint32 man = (damage *(100+playerTarget->m_lifetapbonus))/100;
+		if (p_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= damage) return;
 		p_caster->DealDamage(playerTarget,damage,0,0,spellId);
 		playerTarget->ModUInt32Value(UNIT_FIELD_POWER1,man);
 		if(playerTarget->GetUInt32Value(UNIT_FIELD_POWER1) > playerTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1))
@@ -1085,6 +1086,7 @@
 			ILotP.procChance = 100;
 			ILotP.procFlags = PROC_ON_CRIT_ATTACK | PROC_TAGRGET_SELF;
 			ILotP.deleted = false;
+			ILotP.from_weapon = false;
 			ILotP.caster = u_caster->GetGUID();
 			ILotP.LastTrigger = 0;
 			u_caster->m_procSpells.push_back(ILotP);
@@ -1965,8 +1967,7 @@
 				{
 					if(gameObjTarget->loot.items.size() == 0)
 					{
-						lootmgr.FillProfessionLoot(&lootmgr.GOLoot,&gameObjTarget->loot,
-							gameObjTarget->GetEntry());
+						lootmgr.FillGOLoot(&gameObjTarget->loot,gameObjTarget->GetEntry(), gameObjTarget->GetMapMgr() ? (gameObjTarget->GetMapMgr()->iInstanceMode ? true : false) : false);
 					}
 					else
 						bAlreadyUsed = true;
@@ -3507,7 +3508,26 @@
 		pTotem->EnableAI();
 		pTotem->GetAIInterface()->Init(pTotem, AITYPE_TOTEM, MOVEMENTTYPE_NONE, p_caster);
 		pTotem->GetAIInterface()->totemspell = TotemSpell;
-		uint32 timer = 2000;	// need a proper resource for this.
+		uint32 timer = 2000;
+ 
+		switch(TotemSpell->Id)
+		{
+			case 8146: //Tremor Totem
+			case 8167: //Poison Cleansing Totem
+			case 8172: //Disease Cleansing Totem
+				timer =  5000;
+			break;
+			case 8349: //Fire Nova Totem 1
+			case 8502: //Fire Nova Totem 2
+			case 8503: //Fire Nova Totem 3
+			case 11306: //Fire Nova Totem 4
+			case 11307: //Fire Nova Totem 5
+			case 25535: //Fire Nova Totem 6
+			case 25537: //Fire Nova Totem 7
+				timer =  4000;
+			break;
+		default:break;
+		}
 
 		pTotem->GetAIInterface()->m_totemspelltimer = timer;
 		pTotem->GetAIInterface()->m_totemspelltime = timer;
@@ -3583,7 +3603,7 @@
 	if( (sk >= lvl*5)||((sk+100) >= lvl*10) )
 	{
 		//Fill loot for Skinning
-		lootmgr.FillProfessionLoot(&lootmgr.SkinningLoot,&((Creature*)unitTarget)->loot,unitTarget->GetEntry());
+		lootmgr.FillSkinningLoot(&((Creature*)unitTarget)->loot,unitTarget->GetEntry());
 		((Player*)m_caster)->SendLoot(unitTarget->GetGUID(),2);
 		
 		//Not skinable again
Index: trunk/src/game/Unit.cpp
===================================================================
--- trunk/src/game/Unit.cpp	(revision 2035)
+++ trunk/src/game/Unit.cpp	(working copy)
@@ -372,6 +372,7 @@
 
 	//Get Highest Level Player, Calc Xp and give it to each group member
 	Player *pHighLvlPlayer = NULL;
+	Player *pHighLvlPlayerNot70 = NULL;
 	Player *pGroupGuy = NULL;
 	  int active_player_count=0;
 	Player *active_player_list[MAX_GROUP_SIZE_RAID];//since group is small we can afford to do this ratehr then recheck again the whole active player set
@@ -413,13 +414,16 @@
 				active_player_list[active_player_count]=pGroupGuy;
 				active_player_count++;
 				total_level += pGroupGuy->getLevel();
-				if(pHighLvlPlayer)
+				if(pHighLvlPlayerNot70)
 				{
-					if(pGroupGuy->getLevel() > pHighLvlPlayer->getLevel())
-						pHighLvlPlayer = pGroupGuy;
+					if(pGroupGuy->getLevel() < 70)
+					{
+						if (pGroupGuy->getLevel() > pHighLvlPlayerNot70->getLevel())
+							pHighLvlPlayerNot70 = pGroupGuy;
+					}
 				}
-				else 
-					pHighLvlPlayer = pGroupGuy;
+				else if(pGroupGuy->getLevel() < 70)
+					pHighLvlPlayerNot70 = pGroupGuy;
 			}
 		}
 	}
@@ -444,12 +448,17 @@
 		}
 		else if(pGroup->GetGroupType() == GROUP_TYPE_RAID)
 			xp_mod=0.5f;
-		if(pHighLvlPlayer == 0) pHighLvlPlayer = pGroup->GetLeader();
+		if(pHighLvlPlayerNot70 == 0 || !pHighLvlPlayerNot70) pHighLvlPlayerNot70 = pGroup->GetLeader();
 
-		xp = CalculateXpToGive(pVictim, pHighLvlPlayer);
+		xp = CalculateXpToGive(pVictim, pHighLvlPlayerNot70);
 		//i'm not sure about this formula is correct or not. Maybe some brackets are wrong placed ?
 		for(int i=0;i<active_player_count;i++)
-			active_player_list[i]->GiveXP( float2int32(((xp*active_player_list[i]->getLevel()) / total_level)*xp_mod), pVictim->GetGUID(), true );
+		{
+			if (active_player_list[i]->getLevel() < 70)
+				active_player_list[i]->GiveXP( float2int32(((xp*active_player_list[i]->getLevel()) / total_level)*xp_mod), pVictim->GetGUID(), true );
+			else
+				active_player_list[i]->GiveXP( 0, pVictim->GetGUID(), true );
+		}
 	}
 		/* old code start before 2007 04 22
 		GroupMembersSet::iterator itr;
@@ -496,7 +505,7 @@
 	bool can_delete = !bProcInUse;
 	bProcInUse = true;
 
-	std::list<uint32> remove;
+	//std::list<uint32> remove;
 	std::list<struct ProcTriggerSpell>::iterator itr,itr2;
 	for( itr = m_procSpells.begin();itr != m_procSpells.end();)  // Proc Trigger Spells for Victim
 	{
@@ -577,6 +586,20 @@
 				//these are player talents. Fuckem they pull the emu speed down 
 				if(IsPlayer())
 				{
+					if (itr2->from_weapon && static_cast<Player*>(this)->IsInFeralForm()) 
+					{
+						switch (static_cast<Player*>(this)->GetShapeShift())
+						{
+							case FORM_CAT:	
+							case FORM_BEAR: 
+							case FORM_DIREBEAR:
+								continue;
+								break;
+							default:
+								break;
+						}
+					}
+
 					uint32 talentlevel=0;
 					switch(origId)
 					{
@@ -882,8 +905,6 @@
 								float dmg = static_cast<Player*>(this)->GetMainMeleeDamage(AP_owerride);
 								SpellEntry *sp_for_the_logs = dbcSpell.LookupEntry(spellId);
 								Strike(victim,MELEE,sp_for_the_logs,dmg,0,0,true);
-								Strike(victim,MELEE,sp_for_the_logs,dmg,0,0,true);
-								//nothing else to be done for this trigger
 								continue;
 							}break;
 						//rogue - Ruthlessness
@@ -1037,6 +1058,11 @@
 					if(!sd) continue; // this shouldnt happen though :P
 					switch(iter2->second.spellId)
 					{
+					case 14751:  // inner focus
+					{
+						if(CastingSpell->Id == iter2->second.spellId)
+							continue; 
+						}break;
 					case 12043:
 						{
 							//Presence of Mind and Nature's Swiftness should only get removed
@@ -1743,7 +1769,7 @@
 					{
 						targetEvent = 2;
 						pVictim->Emote(EMOTE_ONESHOT_PARRYSHIELD);// Animation
-						blocked_damage = uint32((shield->GetProto()->Block + ((Player*)pVictim)->m_modblockvalue)*(1.0+((Player*)pVictim)->GetBlockFromSpell()/100)+pVictim->GetUInt32Value(UNIT_FIELD_STAT0)/20);
+						blocked_damage = uint32( (shield->GetProto()->Block+((Player*)pVictim)->m_modblockvaluefromspells) * (1+(((Player*)pVictim)->m_modblockabsorbvalue*0.01)) + pVictim->GetUInt32Value(UNIT_FIELD_STAT0)/20 );
 
 						if(dmg.full_damage <= (int32)blocked_damage)
 						{
Index: trunk/src/game/World.cpp
===================================================================
--- trunk/src/game/World.cpp	(revision 2035)
+++ trunk/src/game/World.cpp	(working copy)
@@ -835,6 +835,16 @@
 						pr|=PROC_ON_MELEE_ATTACK_VICTIM;
 					if(strstr(desc,"target casts a spell"))
 						pr|=PROC_ON_CAST_SPELL;
+					if(strstr(desc,"your harmful spells land"))
+						pr|=PROC_ON_CAST_SPELL;
+					if(strstr(desc,"on spell critical hit"))
+						pr|=PROC_ON_SPELL_CRIT_HIT;
+					if(strstr(desc,"spell critical strikes"))
+						pr|=PROC_ON_SPELL_CRIT_HIT;
+					if(strstr(desc,"being able to resurrect"))
+						pr|=PROC_ON_DIE;
+					//if(strstr(desc,"successful block"))
+						//pr|=PROC_ON_BLOCK_VICTIM;
 					if(strstr(desc,"any damage caused"))
 						pr|=PROC_ON_ANY_DAMAGE_VICTIM;
 					if(strstr(desc,"the next melee attack against the caster"))
@@ -1596,7 +1606,7 @@
 	sp  = dbcSpell.LookupEntry(12042);
 	if (sp)
 	{
-		sp->EffectSpellGroupRelation[0]=5775504;
+		sp->EffectSpellGroupRelation[0]=552210455;
 		sp->EffectSpellGroupRelation[1]=10518528;
 	}
 	//mage: Fire Power
@@ -2111,7 +2121,19 @@
 		sp->EffectSpellGroupRelation[0] = Sanctity_group;
 		sp->EffectMiscValue[0] = SMT_SPELL_VALUE;
 	}
-
+	sp = dbcSpell.LookupEntry(20608); //Reincarnation
+	if(sp)
+	{
+		for(uint32 i=0;i<8;i++)
+		{
+			if(sp->Reagent[i])
+			{
+				sp->Reagent[i] = 0;
+				sp->ReagentCount[i] = 0;
+			}
+		}
+	}
+	
 ///////////////////////////////
 /*	// druid - Improved Mark of the Wild
 	uint32 imarkofthv_group=0;
@@ -2829,6 +2851,8 @@
 		new MailSystem;
 
 	channelmgr.seperatechannels = Config.MainConfig.GetBoolDefault("Server", "SeperateChatChannels", false);
+	PvpFactionLimitation = Config.MainConfig.GetBoolDefault("Server", "PvpFactionLimitation", true);
+	FriendFactionLimitation = Config.MainConfig.GetBoolDefault("Server", "FriendFactionLimitation", true);
 	sendRevisionOnJoin = Config.MainConfig.GetBoolDefault("Server", "SendBuildOnJoin", false);
 	MapPath = Config.MainConfig.GetStringDefault("Terrain", "MapPath", "maps");
 	UnloadMapFiles = Config.MainConfig.GetBoolDefault("Terrain", "UnloadMapFiles", true);
Index: trunk/src/game/World.h
===================================================================
--- trunk/src/game/World.h	(revision 2035)
+++ trunk/src/game/World.h	(working copy)
@@ -212,6 +212,8 @@
     uint32 lvl_mod_a;
 	uint32 required_quest;
 	uint32 required_item;
+	uint32 heroic_keyid_1;
+	uint32 heroic_keyid_2;
 
 	bool HasFlag(uint32 flag)
 	{
@@ -459,6 +461,8 @@
 
 	string MapPath;
 	bool UnloadMapFiles;
+	bool PvpFactionLimitation;
+	bool FriendFactionLimitation;
 	bool BreathingEnabled;
 	bool SpeedhackProtection;
 	void EventDeleteBattleground(Battleground * BG);
