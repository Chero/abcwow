Index: ascent-world/Object.cpp
===================================================================
--- ascent-world/Object.cpp	(revision 3944)
+++ ascent-world/Object.cpp	(working copy)
@@ -2215,72 +2273,81 @@
 		{
 			//------------------------------critical strike chance--------------------------------------	
 			// lol ranged spells were using spell crit chance
-			float CritChance;
-			if( spellInfo->is_ranged_spell )
+			if ( spellInfo && (spellInfo->Flags3 & FLAGS3_CANNOT_CRIT) )
 			{
+				// do we need to do something extra ?
+			}
+			else
+			{
+				float CritChance;
+				if( spellInfo->is_ranged_spell )
+				{
 
-				if( IsPlayer() )
-				{
-					CritChance = GetFloatValue( PLAYER_RANGED_CRIT_PERCENTAGE );
-					CritChance += static_cast< Player* >( pVictim )->res_R_crit_get();
-					CritChance += float( pVictim->AttackerCritChanceMod[spellInfo->School] );
+					if( IsPlayer() )
+					{
+						CritChance = GetFloatValue( PLAYER_RANGED_CRIT_PERCENTAGE );
+					}
+					else
+					{
+						CritChance = 5.0f; // static value for mobs.. not blizzlike, but an unfinished formula is not fatal :)
+					}
+					if( pVictim->IsPlayer() )
+					{
+						CritChance += static_cast< Player* >( pVictim )->res_R_crit_get();
+						CritChance += float( pVictim->AttackerCritChanceMod[spellInfo->School] );
+						CritChance -= static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_RANGED_CRIT_RESILIENCE );
+					}
 				}
 				else
 				{
-					CritChance = 5.0f; // static value for mobs.. not blizzlike, but an unfinished formula is not fatal :)
-				}
-				if( pVictim->IsPlayer() )
-				CritChance -= static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_RANGED_CRIT_RESILIENCE );
-			}
-			else
-			{
-				CritChance = caster->spellcritperc + caster->SpellCritChanceSchool[school] + pVictim->AttackerCritChanceMod[school];
-				if( caster->IsPlayer() && ( pVictim->m_rooted - pVictim->m_stunned ) )	
-					CritChance += static_cast< Player* >( caster )->m_RootedCritChanceBonus;
+					CritChance = caster->spellcritperc + caster->SpellCritChanceSchool[school] + pVictim->AttackerCritChanceMod[school];
+					if( caster->IsPlayer() && ( pVictim->m_rooted - pVictim->m_stunned ) )	
+						CritChance += static_cast< Player* >( caster )->m_RootedCritChanceBonus;
 
-				if( spellInfo->SpellGroupType )
-				{
-					SM_FFValue(caster->SM_CriticalChance, &CritChance, spellInfo->SpellGroupType);
+					if( spellInfo->SpellGroupType )
+					{
+						SM_FFValue(caster->SM_CriticalChance, &CritChance, spellInfo->SpellGroupType);
 	#ifdef COLLECTION_OF_UNTESTED_STUFF_AND_TESTERS
-					float spell_flat_modifers=0;
-					SM_FFValue(caster->SM_CriticalChance,&spell_flat_modifers,spellInfo->SpellGroupType);
-					if(spell_flat_modifers!=0)
-						printf("!!!!spell critchance mod flat %f ,spell group %u\n",spell_flat_modifers,spellInfo->SpellGroupType);
+						float spell_flat_modifers=0;
+						SM_FFValue(caster->SM_CriticalChance,&spell_flat_modifers,spellInfo->SpellGroupType);
+						if(spell_flat_modifers!=0)
+							printf("!!!!spell critchance mod flat %f ,spell group %u\n",spell_flat_modifers,spellInfo->SpellGroupType);
 	#endif
+					}
+					if( pVictim->IsPlayer() )
+					CritChance -= static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_SPELL_CRIT_RESILIENCE );
 				}
-				if( pVictim->IsPlayer() )
-				CritChance -= static_cast< Player* >(pVictim)->CalcRating( PLAYER_RATING_MODIFIER_SPELL_CRIT_RESILIENCE );
-			}
-			if( CritChance < 0 ) CritChance = 0;
-			if( CritChance > 95 ) CritChance = 95;
-			critical = Rand(CritChance);
-			//sLog.outString( "SpellNonMeleeDamageLog: Crit Chance %f%%, WasCrit = %s" , CritChance , critical ? "Yes" : "No" );
+				if( CritChance < 0 ) CritChance = 0;
+				if( CritChance > 95 ) CritChance = 95;
+				critical = Rand(CritChance);
+				//sLog.outString( "SpellNonMeleeDamageLog: Crit Chance %f%%, WasCrit = %s" , CritChance , critical ? "Yes" : "No" );
Index: ascent-world/Spell.cpp
===================================================================
--- ascent-world/Spell.cpp	(revision 3944)
+++ ascent-world/Spell.cpp	(working copy)
@@ -123,7 +123,7 @@
 		    i_caster = NULL;
 		    u_caster = static_cast< Unit* >( Caster );
 		    p_caster = static_cast< Player* >( Caster );
-		    if( p_caster->DuelingWith != NULL )
+		    if( p_caster->GetDuelState() == DUEL_STATE_STARTED )
 			    duelSpell = true;
         }break;
 
@@ -133,7 +133,7 @@
 		    i_caster = NULL;
 		    p_caster = NULL;
 		    u_caster = static_cast< Unit* >( Caster );
-		    if( u_caster->IsPet() && static_cast< Pet* >( u_caster)->GetPetOwner() != NULL && static_cast< Pet* >( u_caster )->GetPetOwner()->DuelingWith != NULL )
+		    if( u_caster->IsPet() && static_cast< Pet* >( u_caster)->GetPetOwner() != NULL && static_cast< Pet* >( u_caster )->GetPetOwner()->GetDuelState() == DUEL_STATE_STARTED )
 			    duelSpell = true;
         }break;
 
@@ -271,9 +271,10 @@
                 {
 					did_hit_result = DidHit(i, static_cast< Unit* >( *itr ) );
 					if( did_hit_result != SPELL_DID_HIT_SUCCESS )
-						ModeratedTargets.push_back(SpellTargetMod((*itr)->GetGUID(), did_hit_result));
+						SafeAddModeratedTarget((*itr)->GetGUID(), did_hit_result);
 					else
-						tmpMap->push_back((*itr)->GetGUID());
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
+						//tmpMap->push_back((*itr)->GetGUID());
                 }
 
             }
@@ -283,10 +284,12 @@
                 {
                     //trap, check not to attack owner and friendly
                     if(isAttackable(g_caster->m_summoner,(Unit*)(*itr),!(m_spellInfo->c_is_flags & SPELL_FLAG_IS_TARGETINGSTEALTHED)))
-                        tmpMap->push_back((*itr)->GetGUID());
+                        //tmpMap->push_back((*itr)->GetGUID());
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
                 }
                 else
-                    tmpMap->push_back((*itr)->GetGUID());
+					SafeAddTarget(tmpMap,(*itr)->GetGUID());
+                    //tmpMap->push_back((*itr)->GetGUID());
             }
             if( m_spellInfo->MaxTargets)
             {
@@ -333,9 +336,10 @@
 				{
 					did_hit_result = DidHit(i, static_cast< Unit* >( *itr ) );
 					if( did_hit_result == SPELL_DID_HIT_SUCCESS )
-						tmpMap->push_back( (*itr)->GetGUID() );
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
+						//tmpMap->push_back( (*itr)->GetGUID() );
 					else
-						ModeratedTargets.push_back( SpellTargetMod( (*itr)->GetGUID(), did_hit_result ) );
+						SafeAddModeratedTarget((*itr)->GetGUID(), did_hit_result );
 				}
 			}
 			else //cast from GO
@@ -344,10 +348,12 @@
 				{
 					//trap, check not to attack owner and friendly
 					if( isAttackable( g_caster->m_summoner, static_cast< Unit* >( *itr ), !(m_spellInfo->c_is_flags & SPELL_FLAG_IS_TARGETINGSTEALTHED) ) )
-						tmpMap->push_back( (*itr)->GetGUID() );
+						//tmpMap->push_back( (*itr)->GetGUID() );
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
 				}
 				else
-					tmpMap->push_back( (*itr)->GetGUID() );
+					//tmpMap->push_back( (*itr)->GetGUID() );
+					SafeAddTarget(tmpMap,(*itr)->GetGUID());
 			}			
 			if( m_spellInfo->MaxTargets )
 				if( m_spellInfo->MaxTargets == tmpMap->size() )
@@ -384,9 +390,10 @@
 				{
 					did_hit_result = DidHit(i, static_cast< Unit* >( *itr ) );
 					if( did_hit_result == SPELL_DID_HIT_SUCCESS )
-						tmpMap->push_back( (*itr)->GetGUID() );
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
+						//tmpMap->push_back( (*itr)->GetGUID() );
 					else
-						ModeratedTargets.push_back( SpellTargetMod( (*itr)->GetGUID(), did_hit_result ) );
+						SafeAddModeratedTarget((*itr)->GetGUID(), did_hit_result );
 				}
 			}
 			else //cast from GO
@@ -395,10 +402,12 @@
 				{
 					//trap, check not to attack owner and friendly
 					if( isFriendly( g_caster->m_summoner, static_cast< Unit* >( *itr ) ) )
-						tmpMap->push_back( (*itr)->GetGUID() );
+						SafeAddTarget(tmpMap,(*itr)->GetGUID());
+						//tmpMap->push_back( (*itr)->GetGUID() );
 				}
 				else
-					tmpMap->push_back( (*itr)->GetGUID() );
+					SafeAddTarget(tmpMap,(*itr)->GetGUID());
+					//tmpMap->push_back( (*itr)->GetGUID() );
 			}			
 			if( m_spellInfo->MaxTargets )
 				if( m_spellInfo->MaxTargets == tmpMap->size() )
@@ -517,12 +526,29 @@
 	if( u_victim == NULL )
 		return SPELL_DID_HIT_MISS;
 	
+	//multiple effects from same same spell cannot be resisted separately
+	for(SpellTargetsList::iterator itr = ModeratedTargets.begin(); itr != ModeratedTargets.end(); ++itr)
+	{
+		if( (*itr).TargetGuid == u_victim->GetGUID() )
+			return (*itr).TargetModType;
+	}
+
+	/*
+	for(std::vector< uint64 >::iterator trg = m_targetUnits[effindex].begin(); trg != m_targetUnits[effindex].end(); trg++)
+	{
+		if( (*trg) == u_victim->GetGUID() )
+			return SPELL_DID_HIT_SUCCESS;
+			//m_targetUnits[effindex].erase( m_targetUnits[effindex].begin() + k );
+	}
+	*/
+
 	/************************************************************************/
-	/* Elite mobs always hit                                                */
+	/* Elite mobs always hit - mooo?                                        */
 	/************************************************************************/
+	/*
 	if( u_caster != NULL && u_caster->GetTypeId() == TYPEID_UNIT && static_cast< Creature* >( u_caster )->GetCreatureName() && static_cast< Creature* >( u_caster )->GetCreatureName()->Rank >= 3 )
 		return SPELL_DID_HIT_SUCCESS;
-
+	*/
 	/************************************************************************/
 	/* Can't resist non-unit                                                */
 	/************************************************************************/
@@ -557,42 +583,47 @@
 	
 	/**** HACK FIX: AoE Snare/Root spells (i.e. Frost Nova) ****/
 	/* If you find any other AoE effects that also apply something that SHOULD be a mechanic, add it here. */
-	if( u_victim->MechanicsDispels[MECHANIC_ROOTED] ||
-		u_victim->MechanicsDispels[MECHANIC_ENSNARED]
-		)
+	if( u_victim->MechanicsDispels[MECHANIC_ROOTED] || u_victim->MechanicsDispels[MECHANIC_ENSNARED] )
 	{
-	for( int i = 1 ; i <= 3 ; i ++ )
+		for( int i = 1 ; i <= 3 ; i ++ )
 		{
 			if( u_victim->MechanicsDispels[MECHANIC_ROOTED] && m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT )
 				return SPELL_DID_HIT_IMMUNE;
 			if( u_victim->MechanicsDispels[MECHANIC_ENSNARED] && m_spellInfo->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED )
 				return SPELL_DID_HIT_IMMUNE;
 		}
-
 	}
 
 	/************************************************************************/
-	/* Check if the target has a % resistance to this mechanic              */
-	/************************************************************************/
-		/* Never mind, it's already done below. Lucky I didn't go through with this, or players would get double resistance. */
-
-	/************************************************************************/
 	/* Check if the spell is a melee attack and if it was missed/parried    */
 	/************************************************************************/
-	uint32 melee_test_result;
-	if( m_spellInfo->is_melee_spell)
+	if( m_spellInfo->is_melee_spell || m_spellInfo->is_ranged_spell )
 	{
-		melee_test_result = u_caster->GetSpellDidHitResult( u_victim, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo );
-		if(melee_test_result != SPELL_DID_HIT_SUCCESS)
-			return (uint8)melee_test_result;
+		uint32 _type = MELEE;
+		if( GetType() == SPELL_DMG_TYPE_RANGED )
+			_type = RANGED;
+		else
+		{
+			if (m_spellInfo->Flags4 & 0x1000000)
+				_type = OFFHAND;
+			else
+				_type = MELEE;
+		}
+
+		return uint8( u_caster->GetSpellDidHitResult( u_victim, _type, m_spellInfo ) );
 	}
 
+	/* this is wrong, if we got here with spell which is SCHOOL_NORMAL most chances it is stun
+	if( m_spellInfo->School == SCHOOL_NORMAL )
+		return SPELL_DID_HIT_SUCCESS;
+	*/
+
+	if( m_spellInfo->MechanicsType == MECHANIC_DISORIENTED ) // hope its right
+		return SPELL_DID_HIT_SUCCESS;
+	
 	/************************************************************************/
 	/* Check if the spell is resisted.                                      */
 	/************************************************************************/
-	if( m_spellInfo->School==0)
-		return SPELL_DID_HIT_SUCCESS;
-
 	bool pvp =(p_caster && p_victim);
 
 	if(pvp)
@@ -617,23 +648,24 @@
 				resistchance = baseresist[2] + (((float)lvldiff-2.0f)*11.0f);
 		}
 	}
+
 	//check mechanical resistance
-	//i have no idea what is the best pace for this code
-	if( m_spellInfo->MechanicsType<27)
+	if( m_spellInfo->MechanicsType && m_spellInfo->MechanicsType < 27 )
 	{
 		if(p_victim)
 			resistchance += p_victim->MechanicsResistancesPCT[m_spellInfo->MechanicsType];
 		else 
 			resistchance += u_victim->MechanicsResistancesPCT[m_spellInfo->MechanicsType];
 	}
+
 	//rating bonus
-	if( p_caster != NULL )
+	if( p_caster != NULL && m_spellInfo->School != SCHOOL_NORMAL )
 	{
 		resistchance -= p_caster->CalcRating( PLAYER_RATING_MODIFIER_SPELL_HIT );
 		resistchance -= p_caster->GetHitFromSpell();
 	}
 
-	if(p_victim)
+	if( p_victim && m_spellInfo->School != SCHOOL_NORMAL )
 		resistchance += p_victim->m_resist_hit[2];
 
 	if( this->m_spellInfo->Effect[effindex] == SPELL_EFFECT_DISPEL && m_spellInfo->SpellGroupType && u_caster)
@@ -663,22 +695,24 @@
 #endif
 	}
 
+	uint32 res;
+
 	if(resistchance >= 100.0f)
-		return SPELL_DID_HIT_RESIST;
+		res = SPELL_DID_HIT_RESIST;
 	else
 	{
-		uint32 res;
 		if(resistchance<=1.0)//resist chance >=1
-			res =  (Rand(1.0f) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
+			res =  ( Rand(1.0f) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
 		else
-			res =  (Rand(resistchance) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
+			res =  ( Rand(resistchance) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
+	}
+	
+	if (res == SPELL_DID_HIT_SUCCESS)
+	{
+		target->HandleProc(PROC_ON_SPELL_LAND_VICTIM,this->u_caster,this->m_spellInfo);
+	}
 
-		if (res == SPELL_DID_HIT_SUCCESS) // proc handling. mb should be moved outside this function
-			target->HandleProc(PROC_ON_SPELL_LAND_VICTIM,this->u_caster,this->m_spellInfo);
-
-		return res;
-	}
- 
+	return res;
 }
 //generate possible target list for a spell. Use as last resort since it is not acurate
 //this function makes a rough estimation for possible target !
@@ -944,7 +978,11 @@
 		m_castTime = 0;
 	else
 	{
-		m_castTime = GetCastTime( dbcSpellCastTime.LookupEntry( m_spellInfo->CastingTimeIndex ) );
+		SpellCastTime *time = dbcSpellCastTime.LookupEntry( m_spellInfo->CastingTimeIndex );
+		if ( time == NULL )
+			m_castTime = 0;
+		else
+			m_castTime = GetCastTime( time );
 
 		if( m_castTime && m_spellInfo->SpellGroupType && u_caster != NULL )
 		{
@@ -1280,18 +1318,19 @@
 				p_caster->setAttackTimer( 0, true );
 				p_caster->setAttackTimer( 0, false );
 			}
-			if( p_caster->IsStealth() && !(m_spellInfo->AttributesEx & ATTRIBUTESEX_DELAY_SOME_TRIGGERS ) )
+			else if( m_spellInfo->NameHash == SPELL_HASH_VICTORY_RUSH )
 			{
+				p_caster->RemoveFlag(UNIT_FIELD_AURASTATE,AURASTATE_FLAG_LASTKILLWITHHONOR);
+			}
+
+			if( p_caster->IsStealth() && !(m_spellInfo->AttributesEx & ATTRIBUTESEX_NOT_BREAK_STEALTH) )
+			{
 				/* talents procing - don't remove stealth either */
-				if( m_spellInfo->Attributes & 64 || ( pSpellId && dbcSpell.LookupEntry(pSpellId)->Attributes & 64 ) )
+				if (!(m_spellInfo->Attributes & ATTRIBUTES_PASSIVE) && 
+					!( pSpellId && dbcSpell.LookupEntry(pSpellId)->Attributes & ATTRIBUTES_PASSIVE ) )
 				{
-
-				}
-				else
-				{
-					uint32 stealthid = p_caster->m_stealth;
+					p_caster->RemoveAura(p_caster->m_stealth);
 					p_caster->m_stealth = 0;
-					p_caster->RemoveAura(stealthid);
 				}
 			}
 		}
@@ -1890,8 +1929,6 @@
 
 void Spell::SendSpellGo()
 {
-    
-
 	// Fill UniqueTargets
 	TargetsList::iterator i, j;
 	for( uint32 x = 0; x < 3; x++ )
@@ -2235,6 +2272,13 @@
 		cost +=float2int32(cost*u_caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+m_spellInfo->School));
 	}
 
+	if (p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_SHIV && p_caster->GetItemInterface()) //hackfix for shiv's energy cost
+	{
+		Item *it = p_caster->GetItemInterface()->GetInventoryItem( EQUIPMENT_SLOT_OFFHAND );
+		if( it != NULL )
+			cost += (uint32)(10* (it->GetProto()->Delay / 1000.0f));
+	}
+
 	//apply modifiers
 	if( m_spellInfo->SpellGroupType && u_caster)
 	{
@@ -2333,6 +2377,13 @@
 		cost +=float2int32(cost*u_caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+m_spellInfo->School));
 	}
 
+	if (p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_SHIV && p_caster->GetItemInterface()) //hackfix for shiv's energy cost
+	{
+		Item *it = p_caster->GetItemInterface()->GetInventoryItem( EQUIPMENT_SLOT_OFFHAND );
+		if( it != NULL )
+			cost += (uint32)(10* (it->GetProto()->Delay / 1000.0f));
+	}
+
 	//apply modifiers
 	if( m_spellInfo->SpellGroupType && u_caster)
 	{
@@ -2511,7 +2562,7 @@
 				Aura* aur = NULL;
 				for( int i = 0;i < itr->second->GetSpellProto()->procCharges - 1; i++ )
 				{
-					aur = new Aura( itr->second->GetSpellProto(), itr->second->GetDuration(), itr->second->GetCaster(), itr->second->GetTarget() );
+					aur = new Aura( itr->second->GetSpellProto(), itr->second->GetDuration(), itr->second->GetCaster(), itr->second->GetTarget(), i_caster  );
 					Target->AddAura( aur );
 					aur = NULL;
 				}
@@ -2645,6 +2696,7 @@
 			}
 		}
 
+		/*
 		// check for duel areas
 		if( m_spellInfo->Id == 7266)
 		{
@@ -2652,7 +2704,7 @@
 			if( at->AreaFlags & AREA_CITY_AREA )
 				return SPELL_FAILED_NO_DUELING;
 		}
-
+		*/
 		// check if spell is allowed while player is on a taxi
 		if( p_caster->m_onTaxi )
 		{
@@ -2907,10 +2959,6 @@
 			case SPELL_EFFECT_ENCHANT_ITEM:
 			case SPELL_EFFECT_ENCHANT_ITEM_TEMPORARY:
 			{
-				// check for enchants that can only be done on your own items, make sure they are soulbound
-				if( m_spellInfo->Flags3 & FLAGS3_ENCHANT_OWN_ONLY && !(i_target->IsSoulbound()))
-					return SPELL_FAILED_BAD_TARGETS;
-
 				// check if we have the correct class, subclass, and inventory type of target item
 				if( m_spellInfo->EquippedItemClass != proto->Class)
 					return SPELL_FAILED_BAD_TARGETS;
@@ -2986,6 +3034,10 @@
 		}
 	}
 
+	//are we in an arena and the spell cooldown is longer then 15mins?
+	if ( p_caster != NULL && p_caster->m_bg != NULL && ( p_caster->m_bg->GetType() >= BATTLEGROUND_ARENA_2V2 && p_caster->m_bg->GetType() <= BATTLEGROUND_ARENA_5V5 ) && ( m_spellInfo->RecoveryTime >= 900000 || m_spellInfo->CategoryRecoveryTime >= 900000 ) )
+		return SPELL_FAILED_SPELL_UNAVAILABLE;
+
 	// backstab/ambush
 	if( p_caster != NULL && ( m_spellInfo->NameHash == SPELL_HASH_BACKSTAB || m_spellInfo->NameHash == SPELL_HASH_AMBUSH ) )
 	{
@@ -3390,7 +3442,7 @@
 						break;
 
 						{
-							if( u_caster->m_special_state & ( UNIT_STATE_FEAR | UNIT_STATE_CHARM | UNIT_STATE_SLEEP | UNIT_STATE_ROOT | UNIT_STATE_STUN | UNIT_STATE_CONFUSE | UNIT_STATE_SNARE ) )
+							if( u_caster->m_special_state & ( UNIT_STATE_FEAR | UNIT_STATE_CHARM | UNIT_STATE_SLEEP | UNIT_STATE_ROOT | UNIT_STATE_STUN | UNIT_STATE_CONFUSE | UNIT_STATE_SNARE | UNIT_STATE_SILENCE ) )
 								break;
 						}
 							break;
@@ -3408,8 +3460,19 @@
 		}
 
 		if( u_caster->m_silenced && m_spellInfo->School != NORMAL_DAMAGE )// can only silence non-physical
-			return SPELL_FAILED_SILENCED;
+		{
+			// HACK FIX
+			switch( m_spellInfo->NameHash )
+			{
+				case SPELL_HASH_ICE_BLOCK: //Ice Block
+				case 0x9840A1A6: //Divine Shield
+						break;
 
+				default:
+					return SPELL_FAILED_SILENCED;
+			}
+		}
+
 		if( target != NULL ) /* -Supalosa- Shouldn't this be handled on Spell Apply? */
 		{
 			for( int i = 0; i < 3; i++ ) // if is going to cast a spell that breaks stun remove stun auras, looks a bit hacky but is the best way i can find
@@ -3439,6 +3502,8 @@
 			{
 				case SPELL_HASH_ICE_BLOCK: //Ice Block
 				case 0x9840A1A6: //Divine Shield
+						break;
+
 				case 0x3DFA70E5: //Will of the Forsaken
 				{
 					if( u_caster->m_special_state & (UNIT_STATE_FEAR | UNIT_STATE_CHARM | UNIT_STATE_SLEEP))
@@ -4017,32 +4082,39 @@
 	float healdoneaffectperc = 0;
 	if( u_caster != NULL )
 	{
-		SpellCastTime *sd = dbcSpellCastTime.LookupEntry(m_spellInfo->CastingTimeIndex);
-
-		// affect the plus damage by duration
-		float castaff = float(GetCastTime(sd));
-		if(castaff > 3500) 
-            castaff = 3500;
-		else if(castaff < 1500) 
-            castaff = 1500;
-
-		healdoneaffectperc = castaff / 3500.0f;
+		if(!m_spellInfo->dmg_bonus)
+		{
+			SpellCastTime *sd = dbcSpellCastTime.LookupEntry(m_spellInfo->CastingTimeIndex);
+			// affect the plus damage by duration
+			float castaff = float(GetCastTime(sd));
+			if(castaff > 3500) 
+				castaff = 3500;
+			else if(castaff < 1500) 
+				castaff = 1500;
+ 
+			healdoneaffectperc = castaff / 3500.0f;
+		}
+		else
+		{
+			healdoneaffectperc = m_spellInfo->dmg_bonus/100.0f;
+		}
 		
 		//Downranking
-		/*if( m_spellInfo->baseLevel > 0 && m_spellInfo->maxLevel > 0 && p_caster)
+		if( u_caster->IsPlayer() && m_spellInfo->baseLevel > 0 && m_spellInfo->maxLevel > 0 )
 		{
 			float downrank1 = 1.0f;
-			if (m_spellInfo->baseLevel < 20)
-				downrank1 = 1.0f - (20.0f - float (m_spellInfo->baseLevel) ) * 0.0375f;
+			if( m_spellInfo->baseLevel < 20 )
+				downrank1 = 1.0f - ( 20.0f - float( m_spellInfo->baseLevel ) ) * 0.0375f;
+
 			float downrank2 = ( float(m_spellInfo->maxLevel + 5.0f) / float(p_caster->getLevel()) );
-			if (downrank2 >= 1 || downrank2 < 0)
+			if( downrank2 >= 1 || downrank2 < 0 )
 				downrank2 = 1.0f;
-			healdoneaffectperc *= downrank1 * downrank2;
-		}*/
 
-		//caster sided bonus
-		bonus += u_caster->HealDoneMod[m_spellInfo->School] + (amount*u_caster->HealDonePctMod[m_spellInfo->School])/100;
+			healdoneaffectperc *= downrank1*downrank2;
+		}
 
+		bonus += u_caster->HealDoneMod[m_spellInfo->School];
+
 		if(m_spellInfo->SpellGroupType)
 		{
 			int penalty_pct = 0;
@@ -4060,12 +4132,16 @@
 				printf("!!!!!HEAL : spell dmg bonus(p=24) mod flat %d , spell dmg bonus(p=24) pct %d , spell dmg bonus %d, spell group %u\n",spell_flat_modifers,spell_pct_modifers,bonus,m_spellInfo->SpellGroupType);
 #endif
 		}
-//		amount += float2int32(u_caster->HealDoneMod[m_spellInfo->School] * healdoneaffectperc);
-//		amount += (amount*u_caster->HealDonePctMod[m_spellInfo->School])/100;
-		bonus += unitTarget->HealTakenMod[m_spellInfo->School];//amt of health that u RECIVE, not heal
-		bonus += float2int32(unitTarget->HealTakenPctMod[m_spellInfo->School]*amount);
 
+		bonus += unitTarget->HealTakenMod[m_spellInfo->School];
 
+		if (p_caster)
+		{
+			for(uint32 a = 0; a < 6; a++)
+				bonus += float2int32(p_caster->SpellHealDoneByAttribute[a][m_spellInfo->School] * p_caster->GetUInt32Value(UNIT_FIELD_STAT0 + a));
+		}
+ 
+		amount += float2int32( float( bonus ) * healdoneaffectperc );
 
 		float spellCrit = u_caster->spellcritperc + u_caster->SpellCritChanceSchool[m_spellInfo->School];
         SM_FFValue(u_caster->SM_CriticalChance, &spellCrit, m_spellInfo->SpellGroupType);
@@ -4082,10 +4158,6 @@
 			if( m_spellInfo->SpellGroupType )
 				SM_PIValue( static_cast< Unit* >( u_caster )->SM_PCriticalDamage, &critbonus, m_spellInfo->SpellGroupType );
 			amount += critbonus;
-			//Shady: does it correct> caster casts heal and proc ..._VICTIM ? 
-			// Or mb i'm completely wrong? So if true  - just replace with old string. 
-			//u_caster->HandleProc(PROC_ON_SPELL_CRIT_HIT_VICTIM, unitTarget, m_spellInfo, amount);
-			//Replaced with following one:
 			
 			unitTarget->HandleProc( PROC_ON_SPELL_CRIT_HIT_VICTIM, u_caster, m_spellInfo, amount );
 			u_caster->HandleProc( PROC_ON_SPELL_CRIT_HIT, unitTarget, m_spellInfo, amount );
@@ -4093,14 +4165,8 @@
 		
 	}
 
-	if( p_caster != NULL )  
-	{
-		bonus += float2int32( p_caster->SpellHealDoneByInt[m_spellInfo->School] * p_caster->GetUInt32Value( UNIT_FIELD_STAT3 ) );
-		bonus += float2int32( p_caster->SpellHealDoneBySpr[m_spellInfo->School] * p_caster->GetUInt32Value( UNIT_FIELD_STAT4 ) );
-	}
+	amount += float2int32(( u_caster->HealDonePctMod[m_spellInfo->School]/100.0f + unitTarget->HealTakenPctMod[m_spellInfo->School])*amount);
 
-	amount += float2int32( float( bonus ) * healdoneaffectperc ); //apply downranking on final value ?
-
 	if( amount < 0 ) 
 		amount = 0;
 
@@ -4225,20 +4291,6 @@
 	tgt->push_back(guid);
 }
 
-void Spell::SafeAddMissedTarget(uint64 guid)
-{
-    for(SpellTargetsList::iterator i=ModeratedTargets.begin();i!=ModeratedTargets.end();i++)
-        if((*i).TargetGuid==guid)
-        {
-            //sLog.outDebug("[SPELL] Something goes wrong in spell target system");
-			// this isnt actually wrong, since we only have one missed target map,
-			// whereas hit targets have multiple maps per effect.
-            return;
-        }
-
-    ModeratedTargets.push_back(SpellTargetMod(guid,2));
-}
-
 void Spell::SafeAddModeratedTarget(uint64 guid, uint16 type)
 {
 	for(SpellTargetsList::iterator i=ModeratedTargets.begin();i!=ModeratedTargets.end();i++)
@@ -4383,63 +4435,51 @@
 	{
 	case SPELL_HASH_SAP:					// Sap
 	case SPELL_HASH_GOUGE:					// Gouge
+	case SPELL_HASH_REPENTANCE:			// Repentance
+	case SPELL_HASH_MAIM:
 		{
 			grp = 0;
 		}break;
 
+	case SPELL_HASH_POUNCE:
 	case SPELL_HASH_CHEAP_SHOT:				// Cheap Shot
+	case SPELL_HASH_KIDNEY_SHOT:			// Kidney Shot
+	case SPELL_HASH_HAMMER_OF_JUSTICE:		// Hammer of Justice
+	case SPELL_HASH_CHARGE:					// Charge
+	case SPELL_HASH_INTERCEPT :				// Intercept
+	case SPELL_HASH_CONCUSSION_BLOW:		// Concussion Blow
+	case SPELL_HASH_CELESTIAL_FOCUS:		// Celestial Focus
+	case SPELL_HASH_IMPACT:					// Impact
+	case SPELL_HASH_BLACKOUT:				// Blackout
+	case SPELL_HASH_SHADOWFURY:				// Shadowfury
 		{
 			grp = 1;
 			pve = true;
 		}break;
 
-	case SPELL_HASH_KIDNEY_SHOT:			// Kidney Shot
-		{
-			grp = 2;
-			pve = true;
-		}break;
-
+	case SPELL_HASH_STUN:					// Stuns (all of them)
 	case SPELL_HASH_BASH:					// Bash
 		{
-			grp = 3;
+			grp = 1;
 		}break;
 
+	case SPELL_HASH_FROST_NOVA:				// Frost Nova
+	case SPELL_HASH_FROSTBITE:				// Frostbite
 	case SPELL_HASH_ENTANGLING_ROOTS:		// Entangling Roots
 		{
 			grp = 4;
 		}break;
 
-	case SPELL_HASH_HAMMER_OF_JUSTICE:		// Hammer of Justice
-		{
-			grp = 5;
-			pve = true;
-		}break;
-
-	case SPELL_HASH_STUN:					// Stuns (all of them)
-		{
-			grp = 6;
-		}break;
-
-	case SPELL_HASH_CHARGE:					// Charge
-	case SPELL_HASH_INTERCEPT :				// Intercept
-	case SPELL_HASH_CONCUSSION_BLOW:		// Concussion Blow
-		{
-			grp = 7;
-			pve = true;
-		}break;
-
+	case SPELL_HASH_SEDUCTION:				// Seduction
 	case SPELL_HASH_FEAR:					// Fear
-	case SPELL_HASH_SEDUCTION:				// Seduction
 	case SPELL_HASH_HOWL_OF_TERROR:			// Howl of Terror
+	case SPELL_HASH_DEATH_COIL:			// Death Coil
+	case SPELL_HASH_PSYCHIC_SCREAM:			// Psychic Scream
+	case SPELL_HASH_SCARE_BEAST:			// Scare Beast
 		{
 			grp = 8;
 		}break;
 
-	case SPELL_HASH_FROST_NOVA:				// Frost Nova
-		{
-			grp = 9;
-		}break;
-
 	case SPELL_HASH_POLYMORPH:				// Polymorph
 	case SPELL_HASH_POLYMORPH__CHICKEN:		// Chicken
 	case SPELL_HASH_POLYMORPH__PIG:			// Pig
@@ -4447,24 +4487,20 @@
 	case SPELL_HASH_POLYMORPH__SHEEP:		// Good ol' sheep
 		{
 			grp = 10;
-			pve = true;   
 		}break;
 
-	case SPELL_HASH_PSYCHIC_SCREAM:			// Psychic Scream
+	case SPELL_HASH_BLIND:		// Blind
 		{
 			grp = 11;
+			pve = true;   
 		}break;
 
+	case SPELL_HASH_ENSLAVE_DEMON:			// Enslave Demon
 	case SPELL_HASH_MIND_CONTROL:			// Mind Control
 		{
 			grp = 12;
 		}break;
 
-	//With Patch 2.3, Frost Shock no longer suffers from diminishing returns. Prior to that it suffered from Diminishing Returns, which rendered each application of the snare weaker and weaker until the third use, at which point the target was immune for 15 seconds.
-	//case SPELL_HASH_FROST_SHOCK:			// Frost Shock
-	//	grp = 13;
-	//	break;
-
 	case SPELL_HASH_HIBERNATE:				// Hibernate
 		{
 			grp = 14;
@@ -4476,24 +4512,6 @@
 			pve = true;
 		}break;
 
-	case SPELL_HASH_CELESTIAL_FOCUS:		// Celestial Focus
-		{
-			grp = 16;
-			pve = true;
-		}break;
-
-	case SPELL_HASH_IMPACT:					// Impact
-		{
-			grp = 17;
-			pve = true;
-		}break;
-
-	case SPELL_HASH_BLACKOUT:				// Blackout
-		{
-			grp = 18;
-			pve = true;
-		}break;
-
 	case SPELL_HASH_BANISH:					// Banish
 		{
 			grp = 19;
@@ -4504,16 +4522,6 @@
 			grp = 20;
 		}break;
 
-	case SPELL_HASH_SCARE_BEAST:			// Scare Beast
-		{
-			grp = 21;
-		}break;
-
-	case SPELL_HASH_ENSLAVE_DEMON:			// Enslave Demon
-		{
-			grp = 22;
-		}break;
-
 	}
 	uint32 ret;
 	if( pve )
Index: ascent-world/SpellAuras.cpp
===================================================================
--- ascent-world/SpellAuras.cpp	(revision 3944)
+++ ascent-world/SpellAuras.cpp	(working copy)
@@ -194,8 +194,8 @@
 		&Aura::SpellAuraIncreasePartySpeed,//missing = 171
 		&Aura::SpellAuraIncreaseMovementAndMountedSpeed,//missing = 172 //used //Apply Aura: Increase Movement and Mounted Speed (Non-Stacking) //http://www.thottbot.com/?sp=26022 2e effect
 		&Aura::SpellAuraNULL,//missing = 173 // Apply Aura: Allow Champion Spells
-		&Aura::SpellAuraIncreaseSpellDamageBySpr,//missing = 174 //used //Apply Aura: Increase Spell Damage by % Spirit (Spells) //http://www.thottbot.com/?sp=15031
-		&Aura::SpellAuraIncreaseHealingBySpr,//missing = 175 //used //Apply Aura: Increase Spell Healing by % Spirit //http://www.thottbot.com/?sp=15031
+		&Aura::SpellAuraIncreaseSpellDamageByAttribute,//missing = 174 //used //Apply Aura: Increase Spell Damage by % Spirit (Spells) //http://www.thottbot.com/?sp=15031
+		&Aura::SpellAuraIncreaseHealingByAttribute,//missing = 175 //used //Apply Aura: Increase Spell Healing by % Spirit //http://www.thottbot.com/?sp=15031
 		&Aura::SpellAuraSpiritOfRedemption,//missing = 176 //used // Apply Aura: Spirit of Redemption
 		&Aura::SpellAuraNULL,//missing = 177 //used //Apply Aura: Area Charm // http://www.thottbot.com/?sp=26740
 		&Aura::SpellAuraNULL,//missing = 178 //Apply Aura: Increase Debuff Resistance 
@@ -214,8 +214,8 @@
 		&Aura::SpellAuraLimitSpeed,//missing = 191 //used // noname //http://www.thottbot.com/?sp=29894
 		&Aura::SpellAuraNULL,//192 Apply Aura: Melee Slow %
 		&Aura::SpellAuraIncreaseTimeBetweenAttacksPCT,//193 Apply Aura: Increase Time Between Attacks (Melee, Ranged and Spell) by %
-		&Aura::SpellAuraIncreaseSpellDamageByInt,//194 Apply Aura: Increase Spell Damage by % of Intellect (All)
-		&Aura::SpellAuraIncreaseHealingByInt,//195 Apply Aura: Increase Healing by % of Intellect
+		&Aura::SpellAuraNULL,//194 //&Aura::SpellAuraIncreaseSpellDamageByInt,//194 Apply Aura: Increase Spell Damage by % of Intellect (All)
+		&Aura::SpellAuraNULL,//195 //&Aura::SpellAuraIncreaseHealingByInt,//195 Apply Aura: Increase Healing by % of Intellect
 		&Aura::SpellAuraNULL,//196 Apply Aura: Mod All Weapon Skills (6)
 		&Aura::SpellAuraModAttackerCritChance,//197 Apply Aura: Reduce Attacker Critical Hit Chance by %
 		&Aura::SpellAuraIncreaseAllWeaponSkill,//198
@@ -257,10 +257,10 @@
         &Aura::SpellAuraNULL,//234 Apply Aura: Reduces Silence or Interrupt effects, Item spell magic http://www.thottbot.com/s42184
 		&Aura::SpellAuraNULL,//235 33206 Instantly reduces a friendly target's threat by $44416s1%, reduces all damage taken by $s1% and increases resistance to Dispel mechanics by $s2% for $d.
 		&Aura::SpellAuraNULL,//236
-		&Aura::SpellAuraNULL,//237
-		&Aura::SpellAuraNULL,//238
+		&Aura::SpellAuraHealingByAttackPowerPct,//237 Mental Quickness http://www.wowhead.com/?spell=30813 increases your spell damage by an amount equal to XX% of your attack power.
+		&Aura::SpellAuraDamageByAttackPowerPct,//238 Mental Quickness http://www.wowhead.com/?spell=30813 increases your healing by an amount equal to XX% of your attack power.
 		&Aura::SpellAuraNULL,//239
-		&Aura::SpellAuraAxeSkillModifier,//240 Increase Axe Skill http://www.wowhead.com/?spell=20574
+		&Aura::SpellAuraModExpertise,//240 Increase Expertise
 };
 /*
 ASCENT_INLINE void ApplyFloatSM(float ** m,float v,uint32 mask, float def)
@@ -311,9 +311,9 @@
 
 Unit* Aura::GetUnitCaster()
 {
-	if( m_casterGuid == m_target->GetGUID() )
+	if( m_target != NULL && m_casterGuid == m_target->GetGUID() )
 		return m_target;
-	if( m_target->GetMapMgr() )
+	if( m_target != NULL && m_target->GetMapMgr() )
 		return m_target->GetMapMgr()->GetUnit( m_casterGuid );
 	else
 		return NULL;
@@ -329,7 +329,7 @@
 		return NULL;
 }
 
-Aura::Aura( SpellEntry* proto, int32 duration, Object* caster, Unit* target )
+Aura::Aura( SpellEntry* proto, int32 duration, Object* caster, Unit* target, Item* i_caster )
 {
 	m_castInDuel = false;
 	m_spellProto = proto;
@@ -337,6 +337,11 @@
 	m_positive = 0; //we suppose spell will have positive impact on target
 	m_deleted = false;
 
+	if ( i_caster != NULL && i_caster->GetProto() )
+		m_castedItemId = i_caster->GetProto()->ItemId;
+	else
+		m_castedItemId = 0;
+
 	m_casterGuid = caster->GetGUID();
 	m_target = target;
 
@@ -361,13 +366,10 @@
 
 	if( caster->IsUnit() )
 	{
-		if( m_spellProto->buffIndexType > 0 && caster->IsPlayer() )
+		if( (m_spellProto->FlagsTargets & 0x0020) && caster->IsPlayer() )
 		{
-			if( m_spellProto->buffIndexType != SPELL_TYPE_INDEX_JUDGEMENT )
-			{
-				static_cast< Player* >( caster )->RemoveSpellTargets( m_spellProto->buffIndexType );
-				static_cast< Player* >( caster )->SetSpellTargetType( m_spellProto->buffIndexType, target );
-			}
+			static_cast< Player* >( caster )->RemoveSpellTargets( m_spellProto->MechanicsType, target );
+			static_cast< Player* >( caster )->SetSpellTargetType( m_spellProto->MechanicsType, target );
 		}
 
 		if( isAttackable( ( Unit* )caster, target ) )
@@ -393,7 +395,6 @@
 		timeleft = ( uint32 )UNIXTIME;
 	}
 
-	m_castedItemId = 0;
 	m_visualSlot = 0xFF;
 	pSpellId = 0;
 	periodic_target = 0;
@@ -424,13 +425,22 @@
 	// reset diminishing return timer if needed
 	::UnapplyDiminishingReturnTimer( m_target, m_spellProto );
 	
+	//remove triggered spells by this spell
 	for( uint32 x = 0; x < 3; x++ )
 	{
 		if( !m_spellProto->Effect[x] )
-			break;
+			continue;
 
 		if( m_spellProto->Effect[x] == SPELL_EFFECT_TRIGGER_SPELL )
 		{
+			SpellEntry* sp = dbcSpell.LookupEntryForced( GetSpellProto()->EffectTriggerSpell[x] );
+			if ( sp != NULL  )
+			{
+				SpellDuration *dur = dbcSpellDuration.LookupEntry( sp->DurationIndex );
+				if ( dur == NULL || dur->Duration1 > 0 )
+					continue;
+			}
+
 			//if(GetSpellProto()->EffectTriggerSpell[x]!=GetSpellId())
 			m_target->RemoveAura( GetSpellProto()->EffectTriggerSpell[x] );
 		}
@@ -460,6 +470,48 @@
 		}
 	}
 
+		// trigger spells on aura removal
+	uint32 triggerSpell = 0;
+	Unit *newTarget = GetUnitCaster();
+	Unit *newCaster = newTarget;
+
+	if ( m_spellProto != NULL )
+	{
+		switch (m_spellProto->Id)
+		{
+		case 19386: //Wyvern Sting r1
+			triggerSpell = 24131;
+			newTarget = m_target;
+		break;
+		case 24132: //Wyvern Sting r2
+			triggerSpell = 24134;
+			newTarget = m_target;
+		break;
+		case 24133: //Wyvern Sting r3
+			triggerSpell = 24135;
+			newTarget = m_target;
+		break;
+		case 27068: //Wyvern Sting r4
+			triggerSpell = 27069;
+			newTarget = m_target;
+		break;
+		case 66: //Invisibility
+			triggerSpell = 32612;
+		break;
+		}
+	}
+
+	if ( triggerSpell && newTarget != NULL && newCaster != NULL )
+	{
+		SpellEntry* sp = dbcSpell.LookupEntryForced( triggerSpell );
+		if ( sp != NULL  )
+		{
+			Spell* spe = new Spell( newCaster, sp, true, NULL );
+			SpellCastTargets tgt( newTarget->GetGUID() );
+			spe->prepare(&tgt);
+		}
+	}
+
 	m_target->m_auras[m_auraSlot] = NULL;
 
 	if( GetSpellProto()->SpellGroupType && m_target->IsPlayer() )
@@ -483,12 +535,9 @@
 			m_target->CombatStatus.RemoveAttacker( caster, caster->GetGUID() );
 		}
 
-		if( m_spellProto->buffIndexType != 0 && m_target->IsPlayer() )
+		if( (m_spellProto->FlagsTargets & 0x0020) && m_target->IsPlayer() )
 		{
-			if( m_spellProto->buffIndexType != SPELL_TYPE_INDEX_JUDGEMENT )
-			{
-				static_cast< Player* >( m_target )->RemoveSpellIndexReferences( m_spellProto->buffIndexType );
-			}
+			static_cast< Player* >( m_target )->RemoveSpellIndexReferences( m_spellProto->MechanicsType );
 		}
 	}
 	else
@@ -509,7 +558,8 @@
 		caster->SendMessageToSet( &data, true );
 	}
 
-	delete this;
+	if ( this != NULL ) // no idea how it can happen, it still does
+		delete this;
 }
 
 void Aura::AddMod( uint32 t, int32 a, uint32 miscValue, uint32 i )
@@ -569,7 +619,7 @@
 		else
 			sLog.outError("Unknown Aura id %d", (uint32)mod->m_type);
 	}
-	
+	/*
 	if(GetSpellProto()->procFlags)
 	{
 		for( uint32 x = 0; x < 3; x++ )
@@ -598,6 +648,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.ProcType = 0;
 			m_target->m_procSpells.push_front(pts);
 		}
 		else
@@ -612,6 +663,7 @@
 			}
 		}
 	}
+	*/
 }
 
 void Aura::AddAuraVisual()
@@ -650,43 +702,6 @@
 	}
 	m_visualSlot = m_target->AddAuraVisual(m_spellProto->Id, 1, IsPositive());
 
-	/*m_target->SetUInt32Value(UNIT_FIELD_AURA + slot, m_spellProto->Id);
-
-	uint8 flagslot = slot >> 3;
-
-	uint32 value = m_target->GetUInt32Value((uint16)(UNIT_FIELD_AURAFLAGS + flagslot));
-
-	uint8 aurapos = (slot & 7) << 2;
-	uint32 value1 = (uint32)AFLAG_SET << aurapos;
-	value |= value1;
-
-	m_target->SetUInt32Value((uint16)(UNIT_FIELD_AURAFLAGS + flagslot), value);
-	
-	uint32 index = (slot / 8);
-	uint32 byte  = (slot % 8);
-
-	uint32 x = 0, y = 0;
-	uint32 val = m_target->GetUInt32Value(UNIT_FIELD_AURALEVELS + index);
-	if(x != 0)
-	{
-		val |= (x << (byte * 8));
-		m_target->SetUInt32Value(UNIT_FIELD_AURALEVELS + index, val);
-	}
-
-	val = m_target->GetUInt32Value(UNIT_FIELD_AURAAPPLICATIONS + index);
-	if(y != 0)
-	{
-		val |= (y << (byte * 8));
-		m_target->SetUInt32Value(UNIT_FIELD_AURAAPPLICATIONS + index, val);
-	}
-	sLog.outDebug("Adding Aura Visual - target: %d , slot: %d , flagslot: %d , flagsvalue: 0x%.4X",m_target->GetGUID(),slot,flagslot,value);*/
-   
-	//  0000 0000 original
-	//  0000 1001 AFLAG_SET
-	//  1111 1111 0xFF
-
-	//uint8 appslot = slot >> 1;
-
 	if( m_target->IsPlayer())
 	{
 		WorldPacket data(SMSG_UPDATE_AURA_DURATION, 5);
@@ -694,7 +709,7 @@
 		static_cast< Player* >( m_target )->GetSession()->SendPacket(&data);
 	}
 		
-	WorldPacket data(SMSG_PET_LEARNT_SPELL, 21);
+	WorldPacket data(SMSG_SET_AURA_SINGLE, 21);
 	data << m_target->GetNewGUID() << m_visualSlot << uint32(m_spellProto->Id) << uint32(m_duration) << uint32(m_duration);
 	m_target->SendMessageToSet(&data,false);
 
@@ -1002,7 +1017,7 @@
 
 	if( apply )
 	{
-		if( caster != NULL && caster->IsInWorld() && caster->IsPlayer() ) 
+		if( caster != NULL && caster->IsInWorld() && caster->IsPlayer() && (caster->getLevel() + 4) >= m_target->getLevel() ) 
 			static_cast< Player* >(caster)->Possess( m_target );
 	}
 	else
@@ -1181,11 +1196,12 @@
 			{
 				if( GetSpellProto() && GetSpellProto()->NameHash == SPELL_HASH_IGNITE )  //static damage for Ignite. Need to be reworked when "static DoTs" will be implemented
 					bonus_damage=0;
-				else bonus_damage = (float)c->GetSpellDmgBonus(m_target,m_spellProto,amount);
+				else bonus_damage = (float)c->GetSpellDmgBonus(m_target,m_spellProto,amount,1);
 				float ticks= float((amp) ? GetDuration()/amp : 0);
 				float fbonus = float(bonus);
 				fbonus += (ticks) ? bonus_damage/ticks : 0;
-				fbonus *= float(GetDuration()) / 15000.0f;
+				if(!m_spellProto->ChannelInterruptFlags)
+					fbonus *= float(GetDuration()) / 15000.0f;
 				bonus = float2int32(fbonus);
 			}
 			else bonus = 0;
@@ -1223,7 +1239,6 @@
 			abs_dmg += ms_abs_dmg;
 		}
 
-		
 		if(ress < 0) ress = 0;
 		res=(float)ress;
 		dealdamage dmg;
@@ -1250,19 +1265,13 @@
 		{
 			if(m_target->VampEmbCaster.find(m_casterGuid) != m_target->VampEmbCaster.end())
 			{
-				if(GetUnitCaster() && GetUnitCaster()->isAlive())
-				{
-					if(c)
-						c->VampiricEmbrace(float2int32(res), m_target);
-				}
+				if( c != NULL && c->isAlive() )
+					c->VampiricEmbrace(float2int32(res), m_target);
 			}
 			if(m_target->VampTchCaster.find(m_casterGuid) != m_target->VampTchCaster.end())
 			{
-				if(GetUnitCaster() && GetUnitCaster()->isAlive())
-				{
-					if(c)
-						c->VampiricTouch(float2int32(res), m_target);
-				}
+				if( c != NULL && c->isAlive() )
+					c->VampiricTouch(float2int32(res), m_target);
 			}
 		}
 	}
@@ -1328,6 +1337,313 @@
 
 	switch(GetSpellId())
 	{
+	case 32052: //custom
+		{
+			if (apply)
+			{
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "MUHAHAHA ...");
+
+				uint8 race, race_old, class_,gender,powertype/*,skin,face,hairStyle,hairColor,facialHair*/;
+				uint32 team = _ptarget->GetTeam();
+
+				race_old = race = _ptarget->getRace();
+				class_ = _ptarget->getClass();
+				gender = _ptarget->getGender();
+				powertype = _ptarget->GetPowerType();
+				
+				switch(class_)
+				{
+				case WARRIOR:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_ORC; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_TAUREN; break;
+							}
+						}else{
+							switch(RandomUInt(4))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_GNOME; break;
+								case 4: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case PALADIN:
+					{
+						if(!team) //a
+						{
+							race = RACE_BLOODELF;
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case HUNTER:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_ORC; break;
+								case 1: race = RACE_TAUREN; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_DWARF; break;
+								case 1: race = RACE_NIGHTELF; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case ROGUE:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_ORC; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_GNOME; break;
+							}
+						}
+					}break;
+				case PRIEST:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_TROLL; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case SHAMAN:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_ORC; break;
+								case 1: race = RACE_TAUREN; break;
+								case 2: race = RACE_TROLL; break;
+							}
+						}else race = RACE_DRAENEI;
+					}break;
+				case MAGE:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_TROLL; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_GNOME; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case WARLOCK:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_ORC ; break;
+								case 1: race = RACE_UNDEAD; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_GNOME; break;
+							}
+						}
+					}break;
+				case DRUID:
+					{
+						switch(race)
+						{
+						case RACE_TAUREN: race = RACE_NIGHTELF; break;
+						case RACE_NIGHTELF: race = RACE_TAUREN; break;
+						}
+					}break;
+				}
+
+				_ptarget->SetTeam( team ? 0 : 1 );
+				PlayerCreateInfo *info = objmgr.GetPlayerCreateInfo(race, class_);
+				if (!info)
+					break;
+
+				_ptarget->SetFloatValue(OBJECT_FIELD_SCALE_X, ((race==RACE_TAUREN)?1.3f:1.0f));
+				_ptarget->SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, info->factiontemplate );	
+				_ptarget->SetUInt32Value(UNIT_FIELD_BYTES_0, ( ( race ) | ( class_ << 8 ) | ( gender << 16 ) | ( powertype << 24 ) ) );
+				if(race != RACE_BLOODELF)
+				{
+					_ptarget->SetUInt32Value(UNIT_FIELD_DISPLAYID, info->displayId + gender );
+					_ptarget->SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, info->displayId + gender );
+				}
+				else
+				{
+					_ptarget->SetUInt32Value(UNIT_FIELD_DISPLAYID, info->displayId - gender );
+					_ptarget->SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, info->displayId - gender );
+				}
+				// Different races have different number of visuals
+				_ptarget->SetUInt32Value(PLAYER_BYTES, ((RandomUInt(5))|(RandomUInt(5)<<8)|(RandomUInt(5)<<16)|(RandomUInt(5)<<24)));
+				_ptarget->SetUInt32Value(PLAYER_BYTES_2, (( !gender ? 0 : RandomUInt(3) ) | (0x02 << 24)));
+				//_ptarget->SetUInt32Value(PLAYER_BYTES, ((skin) | (face << 8) | (hairStyle << 16) | (hairColor << 24)));
+				//_ptarget->SetUInt32Value(PLAYER_BYTES_2, (facialHair | (0x02 << 24)));
+				
+				_ptarget->SetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, 0xEEEEEEEE);
+				//dump reputation data
+				ReputationMap m_tempRepMap;
+				//store neutral
+				for(uint32 i = 0; i < dbcFaction.GetNumRows(); ++i)
+				{
+					FactionDBC * f = dbcFaction.LookupRow(i);
+					if(f == 0) continue;
+					// dont store side related factions
+					if( _ptarget->GetStanding(f->ID) &&
+						f->parentFaction != 67 && f->parentFaction != 469 &&
+						f->parentFaction != 892 && f->parentFaction != 891 && 
+						f->ID != 947 && f->ID != 946 && //HH/thrallmar
+						f->ID != 892 && f->ID != 891 && //h/a Forces
+						f->ID != 941 && f->ID != 978 && //Mag'har / Kurenai
+						f->ID != 922 //Tranquillien
+						)
+					{
+						FactionReputation * rep = new FactionReputation;
+						rep->flag = 0;
+						rep->standing = _ptarget->GetStanding(f->ID);
+						rep->baseStanding = _ptarget->GetBaseStanding(f->ID);
+
+						m_tempRepMap[f->ID] = rep;
+					}
+				}
+				//add all starting fresh flashing
+				_ptarget->_InitialReputation();
+				//add/mod all stored
+				for(ReputationMap::iterator itr = m_tempRepMap.begin(); itr != m_tempRepMap.end(); ++itr)
+				{
+					_ptarget->SetStanding(itr->first, itr->second->standing );
+					//delete itr->second;
+				}
+
+				_ptarget->_RemoveLanguages();
+				
+				//remove racial spells along with all starting spells then add them for new race
+				PlayerCreateInfo * old_info = objmgr.GetPlayerCreateInfo(race_old, class_);
+				if (!old_info) break;
+
+				for(std::set<uint32>::iterator sp = old_info->spell_list.begin(); sp!=old_info->spell_list.end(); sp++)
+					if (_ptarget->HasSpell(*sp)) _ptarget->removeSpell((*sp), false, false, 0);
+
+				for(std::set<uint32>::iterator sp = info->spell_list.begin(); sp!=info->spell_list.end(); sp++)
+					_ptarget->addSpell(*sp);
+
+				//quit guild
+				if (_ptarget->GetGuildId())
+				{
+					Guild *pGuild = objmgr.GetGuild( _ptarget->GetGuildId() );
+
+					if(pGuild && pGuild->GetGuildLeader() != _ptarget->GetGUID() )
+					{
+						_ptarget->SetGuildId(0);
+						_ptarget->SetGuildRank(0);
+						pGuild->RemoveGuildMember(_ptarget->m_playerInfo, NULL);
+
+						WorldPacket data(100);
+						data.Initialize(SMSG_GUILD_EVENT);
+						data << uint8(GUILD_EVENT_LEFT);
+						data << uint8(1);
+						data << _ptarget->GetName();
+						pGuild->SendPacket(&data);
+					}
+				}
+
+				//arena team remove
+				for(uint32 i = 0; i < 3 ; i++)
+				{
+					ArenaTeam * team;
+					if( (team = _ptarget->m_arenaTeams[i]) != NULL )
+						team->RemoveMember(_ptarget->m_playerInfo);
+				}
+
+				_ptarget->SaveToDB(false);
+			}
+			else
+			{
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "Signed in blood. There is no going back now ...");
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "Relog ...");
+				//force relog
+				_ptarget->Kick(5000);
+			}
+		}break;
+	//improved sprint effect
+	case 30918:
+		{
+			for( uint32 x = MAX_POSITIVE_AURAS; x < MAX_AURAS; x++ )
+			{
+				if( m_target->m_auras[x] != NULL )
+				{
+					if( m_target->m_auras[x]->GetSpellProto()->MechanicsType == 7 || m_target->m_auras[x]->GetSpellProto()->MechanicsType == 11 ) // Remove roots and slow spells
+					{
+						m_target->m_auras[x]->Remove();
+					}
+					else
+					{
+						for( int i = 0; i < 3; i++ )
+						{
+							if( m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED || m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT )
+							{
+								m_target->m_auras[x]->Remove();
+								break;
+							}
+						}
+					}
+			   }
+			}
+
+		}break;
 	//paladin - Blessing of Light.
 	case 19977:
 	case 19978:
@@ -1363,6 +1679,8 @@
 		{
 	      if( apply )
 			 m_target->m_extrastriketargets++;
+		  else
+			 m_target->m_extrastriketargets--;
 		}break;
 	//taming rod spells
 	case 19548:	triggerSpId=19597;
@@ -1413,6 +1731,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.ProcType = 0;
 			m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1467,7 +1786,7 @@
 	case 12678:
 		{
 			if( apply )
-				_ptarget->m_retainedrage += mod->m_amount*10; //don't really know if value is all value or needs to be multiplyed with 10
+				_ptarget->m_retainedrage += mod->m_amount*10;
 			else
 				_ptarget->m_retainedrage -= mod->m_amount*10;
 		}break;
@@ -1498,12 +1817,13 @@
 			if( apply )
 			{
 				SetNegative();
-				Unit * caster =this->GetUnitCaster();
-				if(caster) m_target->VampEmbCaster.insert(caster->GetGUID());
+				Unit * caster = this->GetUnitCaster();
+				if( caster && m_target->VampEmbCaster.find( caster->GetGUID() ) == m_target->VampEmbCaster.end() )
+					m_target->VampEmbCaster.insert(caster->GetGUID());
 			}
 			else
 			{
-				Unit * caster =this->GetUnitCaster();
+				Unit * caster = this->GetUnitCaster();
 				if(caster)
 				{
 					std::set<uint64>::iterator itr = m_target->VampEmbCaster.find(caster->GetGUID());
@@ -1520,11 +1840,12 @@
 			{
 				SetNegative();
 				Unit * caster = this->GetUnitCaster();
-				if(caster) m_target->VampTchCaster.insert(caster->GetGUID());
+				if( caster && m_target->VampTchCaster.find( caster->GetGUID() ) == m_target->VampTchCaster.end() )
+					m_target->VampTchCaster.insert( caster->GetGUID() );
 			}
 			else
 			{
-				Unit * caster =this->GetUnitCaster();
+				Unit * caster = this->GetUnitCaster();
 				if(caster)
 				{
 					std::set<uint64>::iterator itr = m_target->VampTchCaster.find(caster->GetGUID());
@@ -1660,11 +1981,9 @@
 				return;
 
 			Player* pCaster = static_cast< Player* >( Caster );
-			Unit* target_pet;
+			Unit* target_pet = pCaster->GetSummon();
 
-			if( pCaster->GetSummon() ) 
-				target_pet = pCaster->GetSummon();
-			else
+			if( target_pet == NULL ) 
 				return;
 
 			if( apply )
@@ -1691,7 +2010,9 @@
 			}
 			else
 			{
-				Unit* pTarget = pCaster->m_CurrentCharm; 
+				Unit* pTarget = pCaster->m_CurrentCharm;
+				if ( pTarget == NULL )
+					return;
 				pCaster->m_CurrentCharm = 0;
 
 				pTarget->EnableAI();
@@ -1803,6 +2124,7 @@
 				pts.procCharges = GetSpellProto()->procCharges;
 				pts.LastTrigger = 0;
 				pts.deleted = false;
+				pts.ProcType = 0;
 				m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1862,9 +2184,19 @@
 
 	case 33763:		// lifebloom
 		{
-			if( apply || m_target == NULL )
+			if( apply || m_target == NULL || m_target->isDead() )
 				return;
 
+			uint32 count = 0;
+			for(uint32 x = 0; x < MAX_POSITIVE_AURAS; ++x)
+			{
+				if(m_target->m_auras[x] && m_target->m_auras[x]->GetSpellProto()->NameHash == SPELL_HASH_LIFEBLOOM)
+					count++;
+			}
+
+			if (count > 1)
+				return;
+
 			Unit* pCaster = GetUnitCaster();
 			if( pCaster == NULL )
 				pCaster = m_target;
@@ -1888,7 +2220,8 @@
 			if(pCreature==NULL || pTarget->m_bg==NULL)
 				return;
 
-			pTarget->m_bg->RemovePlayerFromResurrect(pTarget,pCreature);
+			if(pTarget->isDead())
+				pTarget->m_bg->RemovePlayerFromResurrect(pTarget,pCreature);
 		}break;
 
 	}
@@ -2037,7 +2370,7 @@
 	if( m_target->GetTypeId() == TYPEID_UNIT && static_cast<Creature*>(m_target)->IsTotem() )
 		return;
 
-	if( apply )
+	if(apply)
 	{
 		if( u_caster == NULL ) return;
 
@@ -2048,7 +2381,7 @@
 
 		m_target->setAItoUse(true);
 		m_target->GetAIInterface()->HandleEvent(EVENT_FEAR, u_caster, 0);
-
+		m_target->m_fearmodifiers++;
 		if(p_target)
 		{
 			// this is a hackfix to stop player from moving -> see AIInterface::_UpdateMovement() Fear AI for more info
@@ -2060,26 +2393,31 @@
 	}
 	else
 	{
-		m_target->m_special_state &= ~UNIT_STATE_FEAR;
-		m_target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
+		m_target->m_fearmodifiers--;
 
-		m_target->GetAIInterface()->HandleEvent( EVENT_UNFEAR, NULL, 0 );
-
-		if(p_target)
+		if(m_target->m_fearmodifiers <= 0)
 		{
-			// re-enable movement
-			WorldPacket data1(9);
-			data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
-			data1 << m_target->GetNewGUID() << uint8(0x01);
-			p_target->GetSession()->SendPacket(&data1);
+			m_target->m_special_state &= ~UNIT_STATE_FEAR;
+			m_target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
 
-			m_target->setAItoUse(false);
+			m_target->GetAIInterface()->HandleEvent( EVENT_UNFEAR, NULL, 0 );
 
-			if( u_caster != NULL )
-				sHookInterface.OnEnterCombat( p_target, u_caster );
+			if(p_target)
+			{
+				// re-enable movement
+				WorldPacket data1(9);
+				data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
+				data1 << m_target->GetNewGUID() << uint8(0x01);
+				p_target->GetSession()->SendPacket(&data1);
+
+				m_target->setAItoUse(false);
+
+				if( u_caster != NULL )
+					sHookInterface.OnEnterCombat( p_target, u_caster );
+			}
+			else
+				m_target->GetAIInterface()->AttackReaction(u_caster, 1, 0);
 		}
-		else
-			m_target->GetAIInterface()->AttackReaction(u_caster, 1, 0);
 	}
 }
 
@@ -2116,17 +2454,15 @@
 
 	if( c != NULL && c->IsPlayer() )
 	{
-		bonus += float2int32( static_cast< Player* >( c )->SpellHealDoneByInt[m_spellProto->School] * static_cast< Player* >( c )->GetUInt32Value( UNIT_FIELD_STAT3 ) );
-		bonus += float2int32( static_cast< Player* >( c )->SpellHealDoneBySpr[m_spellProto->School] * static_cast< Player* >( c )->GetUInt32Value( UNIT_FIELD_STAT4 ) );
+		for(uint32 a = 0; a < 6; a++)
+			bonus += float2int32( static_cast< Player* >( c )->SpellHealDoneByAttribute[a][m_spellProto->School] * static_cast< Player* >( c )->GetUInt32Value( UNIT_FIELD_STAT0 + a) );
+
 		bonus += c->HealDoneMod[GetSpellProto()->School];
-		//Druid Tree of Life form. it should work not like this, but it's better then nothing. 
-		if( static_cast< Player* >( c )->IsInFeralForm() && static_cast< Player* >( c )->GetShapeShift() == FORM_TREE)
-			bonus += float2int32( 0.25f * static_cast< Player* >( c )->GetUInt32Value( UNIT_FIELD_STAT4 ) );
 	}
 
 	if( c != NULL )
 	{
-		bonus += m_target->HealTakenMod[m_spellProto->School] + (amount * c->HealDonePctMod[m_spellProto->School]) / 100;
+		bonus += m_target->HealTakenMod[m_spellProto->School];
 	}
 
 	if( c != NULL && m_spellProto->SpellGroupType )
@@ -2148,14 +2484,21 @@
 	}
 
 	int amp = m_spellProto->EffectAmplitude[mod->i];
-	if( amp > 0 ) 
+	if( !amp ) 
 		amp = static_cast< EventableObject* >( this )->event_GetEventPeriod( EVENT_AURA_PERIODIC_HEAL );
 
 	if( GetDuration() )
 	{
 		int ticks = ( amp > 0 ) ? GetDuration() / amp : 0;
-		bonus = ( ticks > 0 ) ? bonus / ticks : 0;
-		bonus = float2int32( float( bonus * GetDuration() / 15000.0f ) );
+		if (!m_spellProto->dmg_bonus)
+		{
+			bonus = (ticks > 0) ? bonus/ticks : 0;
+			bonus = float2int32(float(bonus * GetDuration() / 15000.0f));
+		}
+		else
+		{
+			bonus = (ticks > 0) ? float2int32(float( (bonus*m_spellProto->dmg_bonus/100)/ticks )) : 0;
+		}
 	}
 	else
 		bonus = 0;
@@ -2567,30 +2910,40 @@
 
 void Aura::SpellAuraModStealth(bool apply)
 {
-	if( apply )
+	if(apply)
 	{
 		SetPositive();
 		m_target->SetStealth(GetSpellId());
 		m_target->SetFlag(UNIT_FIELD_BYTES_1,0x02000000);//sneak anim
 		m_target->RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_STEALTH);
 		m_target->m_stealthLevel += mod->m_amount;
-	}
-	else 
-	{
-		m_target->SetStealth(0);
-		m_target->m_stealthLevel -= mod->m_amount;
-		m_target->RemoveFlag(UNIT_FIELD_BYTES_1,0x02000000);
-		if( m_target->IsPlayer() )
-		{
-			WorldPacket data(12);
-			data.SetOpcode(SMSG_COOLDOWN_EVENT);
-			data << (uint32)GetSpellProto()->Id << m_target->GetGUID();
-			static_cast< Player* >( m_target )->GetSession()->SendPacket (&data);
-		}
 
 		// hack fix for vanish stuff
-		if( m_spellProto->NameHash == SPELL_HASH_VANISH && m_target->IsPlayer() )	 // Vanish
+		if( m_spellProto->NameHash == SPELL_HASH_VANISH && m_target->GetTypeId() == TYPEID_PLAYER )	 // Vanish
 		{
+
+			for( uint32 x = MAX_POSITIVE_AURAS; x < MAX_AURAS; x++ )
+			{
+				if( m_target->m_auras[x] != NULL )
+				{
+					if( m_target->m_auras[x]->GetSpellProto()->MechanicsType == 7 || m_target->m_auras[x]->GetSpellProto()->MechanicsType == 11 ) // Remove roots and slow spells
+					{
+						m_target->m_auras[x]->Remove();
+					}
+					else // if got immunity for slow, remove some that are not in the mechanics
+					{
+						for( int i = 0; i < 3; i++ )
+						{
+							if( m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED || m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT )
+							{
+								m_target->m_auras[x]->Remove();
+								break;
+							}
+						}
+					}
+			   }
+			}
+
 			// check for stealh spells
 			Player* p_caster = static_cast< Player* >( m_target );
 			uint32 stealth_id = 0;
@@ -2608,7 +2961,24 @@
 				p_caster->CastSpell(p_caster, dbcSpell.LookupEntry(stealth_id), true);
 		}
 	}
+	else 
+	{
+		m_target->m_stealthLevel -= mod->m_amount;
 
+		if( m_spellProto->NameHash != SPELL_HASH_VANISH )	 //when vanish aure fades do not remove stealth
+		{
+			m_target->SetStealth(0);
+			m_target->RemoveFlag(UNIT_FIELD_BYTES_1,0x02000000);
+			if( m_target->GetTypeId() == TYPEID_PLAYER )
+			{
+				WorldPacket data(12);
+				data.SetOpcode(SMSG_COOLDOWN_EVENT);
+				data << (uint32)GetSpellProto()->Id << m_target->GetGUID();
+				static_cast< Player* >( m_target )->GetSession()->SendPacket (&data);
+			}
+		}
+	}
+
 	m_target->UpdateVisibility();
 }
 
@@ -2772,14 +3142,17 @@
 	if(m_spellProto->EffectTriggerSpell[mod->i] == 0)
 		return;
 
+	//SELECT * FROM dbc_spell where (EffectApplyAuraName_0 = 23 or  EffectApplyAuraName_1 = 23 or EffectApplyAuraName_2 = 23) and (Attributes & 64)
+	/*
 	if(IsPassive() && m_spellProto->dummy != 2010  && m_spellProto->dummy != 2020 && m_spellProto->dummy != 2255) //this spells are passive and are not done on the attack...
 	{
+		printf("Aura::SpellAuraPeriodicTriggerSpell 0001\n");
 		Unit * target = (m_target != 0) ? m_target : GetUnitCaster();
 		if(target == 0 || !target->IsPlayer())
 			return; //what about creatures ?
 
 		SpellEntry *proto = dbcSpell.LookupEntry( m_spellProto->EffectTriggerSpell[mod->i] );
-
+		printf("Aura::SpellAuraPeriodicTriggerSpell 1\n");
 		if( apply )
 			static_cast< Player* >( target )->AddOnStrikeSpell( proto, m_spellProto->EffectAmplitude[mod->i] );
 		else
@@ -2787,7 +3160,7 @@
 
 		return;
 	}
-	
+	*/
 	if( apply )
 	{
 		//FIXME: positive or negative?
@@ -2869,6 +3242,24 @@
 		if(m_casterGuid == pTarget->GetGUID())
 			return;
 
+	// set up our max Range
+	float maxRange = GetMaxRange( dbcSpellRange.LookupEntry( spellInfo->rangeIndex ) );
+
+	if( spellInfo->SpellGroupType )
+	{
+		SM_FFValue( m_caster->SM_FRange, &maxRange, spellInfo->SpellGroupType );
+		SM_PFValue( m_caster->SM_PRange, &maxRange, spellInfo->SpellGroupType );
+	}
+
+	if( m_caster->IsStunned() || m_caster->IsFeared() || m_caster->GetDistance2dSq( pTarget ) > ( maxRange*maxRange ) )
+	{
+		// no longer valid
+		SendInterrupted(SPELL_FAILED_INTERRUPTED, m_caster);
+		SendChannelUpdate(0, m_caster);
+		this->Remove();
+		return;
+	}
+
 	Spell *spell = new Spell(m_caster, spellInfo, true, this);
 	SpellCastTargets targets;
 	targets.m_unitTarget = pTarget->GetGUID();
@@ -3551,8 +3942,8 @@
 	if( apply )
 	{
 		if( m_target->getClass() == WARRIOR && m_target->GetUInt32Value( UNIT_FIELD_POWER2 ) > static_cast< Player* >( m_target )->m_retainedrage )
-			m_target->SetUInt32Value(UNIT_FIELD_POWER2, static_cast< Player* >( m_target )->m_retainedrage );
-
+			m_target->SetUInt32Value( UNIT_FIELD_POWER2, static_cast< Player* >( m_target )->m_retainedrage);
+	
 		if( m_target->getClass() == DRUID )
 		{
 			if( Rand( static_cast< Player* >( m_target )->m_furorChance ) )
@@ -3653,15 +4044,18 @@
 	if( m_spellProto->Id == 24937 )
 		SetPositive();
 
-	if( m_spellProto->Id == 23333 || m_spellProto->Id == 23335 )
+	if( m_spellProto->Id == 23333 || m_spellProto->Id == 23335 || m_spellProto->Id == 34976 )
 	{
 		if( !apply )
 		{
             Player* plr = static_cast< Player* >( GetUnitCaster() );
-			if( plr == NULL || plr->GetTypeId() != TYPEID_PLAYER || plr->m_bg == NULL|| plr->m_bg->GetType() != BATTLEGROUND_WARSUNG_GULCH )
+			if( plr == NULL || plr->GetTypeId() != TYPEID_PLAYER || plr->m_bg == NULL)
 				return;
 
-			((WarsongGulch*)plr->m_bg)->DropFlag(plr);
+			if( plr->m_bg->GetType() == BATTLEGROUND_WARSUNG_GULCH )
+				((WarsongGulch*)plr->m_bg)->DropFlag(plr);
+			else if( plr->m_bg->GetType() == BATTLEGROUND_EYE_OF_THE_STORM )
+				((EyeOfTheStorm*)plr->m_bg)->DropFlag(plr);
 		}
 	}
 }
@@ -3693,6 +4087,22 @@
 				m_target->RemoveAurasOfSchool(i, false, true);
 			}
 		}
+
+		//hack for ice block
+		if(m_spellProto->NameHash == SPELL_HASH_ICE_BLOCK)
+		{
+			if( m_target == NULL || !m_target->isAlive() )
+				return;
+
+			Aura * pAura;
+			for(uint32 i = MAX_POSITIVE_AURAS; i < MAX_AURAS; ++i)
+			{
+				pAura = m_target->m_auras[i];
+				if( pAura != NULL && !pAura->IsPassive() && !pAura->IsPositive() && pAura->GetSpellProto()->can_be_dispelled )
+					pAura->Remove();
+			}
+		}
+
 	}
 	else
 	{
@@ -3733,11 +4143,19 @@
 {
 	if( apply )
 	{
+		uint32 trigger_spell_id = GetSpellProto()->EffectTriggerSpell[mod->i];
+		for(std::list<struct ProcTriggerSpell>::iterator itr = m_target->m_procSpells.begin();itr != m_target->m_procSpells.end();itr++)
+			if(itr->origId == GetSpellId() && itr->caster == m_casterGuid && itr->spellId == trigger_spell_id)
+			{
+				sLog.outDebug("Warning,tried to multiply register same spell trigger %u",GetSpellProto()->Id);
+				return;
+			}
+
 		ProcTriggerSpell pts;
 		pts.origId = GetSpellProto()->Id;
 		pts.caster = m_casterGuid;
-		if(GetSpellProto()->EffectTriggerSpell[mod->i])
-			pts.spellId=GetSpellProto()->EffectTriggerSpell[mod->i];
+		if( trigger_spell_id )
+			pts.spellId = trigger_spell_id;
 		else
 		{
 			sLog.outDebug("Warning,trigger spell is null for spell %u",GetSpellProto()->Id);
@@ -3748,6 +4166,7 @@
 		pts.procCharges = GetSpellProto()->procCharges;
 		pts.LastTrigger = 0;
 		pts.deleted = false;
+		pts.ProcType = 0;
 
 		if( m_spellProto->NameHash == SPELL_HASH_THE_TWIN_BLADES_OF_AZZINOTH )
 		{
@@ -3806,8 +4225,10 @@
 
 void Aura::SpellAuraProcTriggerDamage(bool apply)
 {
+	printf("We got it to the function\n");
 	if( apply )
 	{
+		printf("and to the apply\n");
 		DamageProc ds;
 		ds.m_damage = mod->m_amount;
 		ds.m_spellId = GetSpellProto()->Id;
@@ -3815,7 +4236,7 @@
 		ds.m_flags = m_spellProto->procFlags;
 		ds.owner = (void*)this;
 		m_target->m_damageShields.push_back(ds);
-		sLog.outDebug("registering dmg proc %u, school %u, flags %u, charges %u \n",ds.m_spellId,ds.m_school,ds.m_flags,m_spellProto->procCharges);
+		printf("registering dmg proc %u, school %u, flags %u, charges %u \n",ds.m_spellId,ds.m_school,ds.m_flags,m_spellProto->procCharges);
 	}
 	else
 	{
@@ -3986,9 +4407,72 @@
 		if(m_target->SchoolImmunityList[GetSpellProto()->School])
 			return;
 
-		//zack: latest new is that this spell uses spell damage bonus only and not healing bonus
-		amount += m_caster->GetSpellDmgBonus(m_target,GetSpellProto(),amount)*50/100;
-	
+		float bonus_damage;
+		int amp = m_spellProto->EffectAmplitude[mod->i];
+		if( !amp ) 
+			amp = static_cast< EventableObject* >( this )->event_GetEventPeriod( EVENT_AURA_PERIODIC_LEECH );
+
+		if(GetDuration())
+		{
+			bonus_damage = (float)m_caster->GetSpellDmgBonus(m_target,m_spellProto,amount,1);
+			float ticks= float((amp) ? GetDuration()/amp : 0);
+			bonus_damage = (ticks) ? bonus_damage/ticks : 0;
+			if(!m_spellProto->ChannelInterruptFlags)
+				bonus_damage *= GetDuration() / 15000.0f;
+		}
+		else bonus_damage = 0;
+
+		amount += float2int32(bonus_damage);
+
+		if(amount < 0)
+			amount = 0;
+		else
+		{
+			float summaryPCTmod = 1.0f;
+			if( m_target->IsPlayer() )//resilience
+			{
+				float dmg_reduction_pct = static_cast<Player*>(m_target)->CalcRating( PLAYER_RATING_MODIFIER_MELEE_CRIT_RESILIENCE ) / 100.0f;
+				if( dmg_reduction_pct > 1.0f )
+					dmg_reduction_pct = 1.0f;
+				summaryPCTmod -= dmg_reduction_pct;
+			}
+			amount = (uint32)(amount*summaryPCTmod);
+			if( amount < 0 ) 
+				amount = 0;
+		}
+
+		uint32 ress=(uint32)amount;
+		uint32 abs_dmg = m_target->AbsorbDamage(m_spellProto->School, &ress);
+		uint32 ms_abs_dmg= m_target->ManaShieldAbsorb(ress);
+		if (ms_abs_dmg)
+		{
+			if(ms_abs_dmg > ress)
+				ress = 0;
+			else
+				ress-=ms_abs_dmg;
+
+			abs_dmg += ms_abs_dmg;
+		}
+
+		if(ress < 0) ress = 0;
+		amount = ress;
+		dealdamage dmg;
+		dmg.school_type = m_spellProto->School;
+		dmg.full_damage = ress;
+		dmg.resisted_damage = 0;
+		
+		if(amount <= 0) 
+			dmg.resisted_damage = dmg.full_damage;
+
+		if(amount > 0)
+		{
+			m_caster->CalculateResistanceReduction(m_target,&dmg);
+			if((int32)dmg.resisted_damage > dmg.full_damage)
+				amount = 0;
+			else
+                amount = dmg.full_damage - dmg.resisted_damage;
+		}
+
 		uint32 Amount = (uint32)min( amount, m_target->GetUInt32Value( UNIT_FIELD_HEALTH ) );
 		uint32 newHealth = m_caster->GetUInt32Value(UNIT_FIELD_HEALTH) + Amount ;
 		
@@ -4008,27 +4492,9 @@
 		data << uint32(Amount);
 		m_target->SendMessageToSet(&data,true);
 
-		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, Amount, 0, 0, FLAG_PERIODIC_LEECH);
+		SendPeriodicAuraLog(m_target, m_caster, m_spellProto->Id, m_spellProto->School, Amount, abs_dmg, dmg.resisted_damage, FLAG_PERIODIC_LEECH);
 
-		//deal damage before we add healing bonus to damage
 		m_target->DealDamage(m_target, Amount, 0, 0, GetSpellProto()->Id,true);
-
-		//add here bonus to healing taken. Maybe not all spells should receive it ?
-		/*
-		//zack : have no idea if we should use downranking here so i'm removing it until confirmed
-		float healdoneaffectperc = 1500 / 3500;
-		//Downranking
-		if(GetSpellProto()->baseLevel > 0 && GetSpellProto()->maxLevel > 0)
-		{
-			float downrank1 = 1.0f;
-			if (GetSpellProto()->baseLevel < 20)
-			downrank1 = 1.0f - (20.0f - float (GetSpellProto()->baseLevel) ) * 0.0375f;
-			float downrank2 = ( float(GetSpellProto()->maxLevel + 5.0f) / float(m_caster->getLevel()) );
-			if (downrank2 >= 1 || downrank2 < 0)
-			downrank2 = 1.0f;
-			healdoneaffectperc *= downrank1 * downrank2;
-		}
-		*/
 	}	
 }
 
@@ -4106,7 +4572,7 @@
 				m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, 11549 );
 			else
 				m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, m_target->GetUInt32Value( UNIT_FIELD_NATIVEDISPLAYID ) );
-		}
+		}break;
 
 		case 41301: // Time-Lost Figurine
 		{
@@ -4114,7 +4580,7 @@
 				m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, 18628 );
 			else
 				m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, m_target->GetUInt32Value( UNIT_FIELD_NATIVEDISPLAYID ) );
-		}
+		}break;
 
 		case 16739: // Orb of Deception
 		{
@@ -4752,41 +5218,14 @@
 
 void Aura::SpellAuraMechanicImmunity(bool apply)
 {
-//sLog.outString( "Aura::SpellAuraMechanicImmunity begun." );
 	if( apply )
 	{
-		//sLog.outString( "mod->m_miscValue = %u" , (uint32) mod->m_miscValue );
-		//sLog.outString( "Incrementing MechanicsDispels (current value: %u, new val: %u)" , m_target->MechanicsDispels[mod->m_miscValue] , m_target->MechanicsDispels[mod->m_miscValue] + 1 );
 		assert(mod->m_miscValue < 27);
 		m_target->MechanicsDispels[mod->m_miscValue]++;
 
+
 		if( mod->m_miscValue != 16 && mod->m_miscValue != 25 && mod->m_miscValue != 19 ) // dont remove bandages, Power Word and protection effect
 		{
-			/*
-			sLog.outString( "Removing values because we're not a bandage, PW:S or forbearance" );
-			for(uint32 x=MAX_POSITIVE_AURAS;x<MAX_AURAS;x++)
-				if(m_target->m_auras[x])
-				{
-					sLog.outString( "Found aura in %u" , x );
-					if(m_target->m_auras[x]->GetSpellProto()->MechanicsType == (uint32)mod->m_miscValue)
-					{
-						sLog.outString( "Removing aura: %u, ID %u" , x , m_target->m_auras[x]->GetSpellId() );
-						m_target->m_auras[x]->Remove();
-					}
-					else if(mod->m_miscValue == 11) // if got immunity for slow, remove some that are not in the mechanics
-					{
-						sLog.outString( "Removing roots" );
-						for( int i = 0; i <3 ; i++ )
-							if( m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED )
-							{
-								sLog.outString( "Removed snare aura in slot %u, spellid %u" , x , m_target->m_auras[x]->GetSpellId() );
-								m_target->m_auras[x]->Remove();
-								break;
-							}
-					}
-				}
-			*/
-			/* Supa's test run of Unit::RemoveAllAurasByMechanic */
 			if( m_target != NULL ) // just to be sure?
 			{
 				m_target->RemoveAllAurasByMechanic( (uint32)mod->m_miscValue , -1 , false );
@@ -4936,12 +5375,10 @@
 	}
 	else 
 	{
-		uint32 school_selector = 1;
 		for( uint32 x = 0; x < 7; x++ )
 		{
-			if( school_selector & mod->m_miscValue )
+			if(mod->m_miscValue & (((uint32)1)<<x) )
 				m_target->DamageDoneModPCT[x] += val;
-			school_selector = school_selector << 1;
 
 		}
 	}
@@ -5700,32 +6137,47 @@
 
 void Aura::SpellAuraAddTargetTrigger(bool apply)
 {
-//	uint32 spellid = GetSpellId();
-//	int32 val = mod->m_amount;
+	SpellEntry *spellInfo = GetSpellProto();
+	if ( spellInfo == NULL || m_casterGuid == NULL )
+		return;
 
-	/*
-	spellid: 11071
-	amount: 5
-	type = 109
-	misc valye 0
+	if( apply )
+	{
+		uint32 trigger_spell_id = spellInfo->EffectTriggerSpell[mod->i];
+		for(std::list<struct ProcTriggerSpell>::iterator itr = m_target->m_procSpells.begin();itr != m_target->m_procSpells.end();itr++)
+			if(itr->origId == spellInfo->Id && itr->caster == m_casterGuid && itr->spellId == trigger_spell_id)
+				return;
 
-	spellid = 11095
-	amount 33
-	type 109
-	misc = 0
+		ProcTriggerSpell pts;
+		pts.origId = spellInfo->Id;
+		pts.caster = m_casterGuid;
+		if( trigger_spell_id ) 
+			pts.spellId = trigger_spell_id;
+		else 
+			return;
+		pts.procChance = spellInfo->EffectBasePoints[mod->i] + 1;
+		if ( spellInfo->procFlags == 0 ) 
+			pts.procFlags = PROC_ON_CAST_SPELL;
+		else
+			pts.procFlags = spellInfo->procFlags;
+		pts.procCharges = spellInfo->procCharges;
+		pts.LastTrigger = 0;
+		pts.deleted = false;
+		pts.ProcType = 0;
 
-	spellid = 12499
-	amount 15
-	type 109
-	misc = 0
-
-	spellid = 14179
-	amount 0
-	type 109
-	misc = 0
-
-	*/
-
+		m_target->m_procSpells.push_front(pts);
+	}
+	else
+	{
+		for(std::list<struct ProcTriggerSpell>::iterator itr = m_target->m_procSpells.begin();itr != m_target->m_procSpells.end();itr++)
+		{
+			if(itr->origId == spellInfo->Id && itr->caster == m_casterGuid && !itr->deleted)
+			{
+				itr->deleted = true;
+				break;
+			}
+		}
+	}
 }
 
 void Aura::SpellAuraModPowerRegPerc(bool apply)
@@ -5873,6 +6325,13 @@
 void Aura::SpellAuraModHealing(bool apply)
 {
 	int32 val;
+
+	 //Tree of Life - do not use namehash here
+	if ( m_spellProto->Id == 34123 && GetCaster() != NULL && GetCaster()->IsPlayer() )
+	{
+		mod->m_amount =  float2int32( 0.25f * GetCaster()->GetUInt32Value(UNIT_FIELD_STAT4) );
+	}
+
 	if( apply )
 	{
 		 val = mod->m_amount;
@@ -5906,24 +6365,22 @@
 
 void Aura::SpellAuraModMechanicResistance(bool apply)
 {
-	//silence=26 ?
-	//mecanics=9 ?
+	assert(mod->m_miscValue < 27);
+
 	if( apply )
 	{
-		assert(mod->m_miscValue < 27);
 		m_target->MechanicsResistancesPCT[mod->m_miscValue]+=mod->m_amount;
 
 		if(mod->m_miscValue != 16 && mod->m_miscValue != 25 && mod->m_miscValue != 19) // dont remove bandages, Power Word and protection effect
-		{
 			SetPositive();
-		}
 		else
-		{
 			SetNegative();
-		}
 	}
 	else
+	{
 		m_target->MechanicsResistancesPCT[mod->m_miscValue]-=mod->m_amount;
+
+	}
 }
 
 void Aura::SpellAuraModHealingPCT(bool apply)
@@ -6596,14 +7053,15 @@
 	}
 }
 
-void Aura::SpellAuraIncreaseSpellDamageBySpr(bool apply)
+void Aura::SpellAuraIncreaseSpellDamageByAttribute(bool apply)
 {
 	Unit * pCaster = GetUnitCaster();
-	if(!pCaster)
+	if( pCaster == NULL || !m_target->IsPlayer() )
 		return;
 
 	int32 val;
 	val = mod->m_amount;
+
 	SM_FIValue(pCaster->SM_FEffectBonus,&val,m_spellProto->SpellGroupType);
 
 	if( apply )
@@ -6616,29 +7074,39 @@
 	else
 		val =- val;
 
-	if( m_target->IsPlayer() )
-	{	
-		for(uint32 x=0;x<7;x++)
+	uint32 stat = 3;
+	for(uint32 i=0; i < 3; i++)
+	{ //bit hacky but it will work with all currently available spells
+		if (m_spellProto->EffectApplyAuraName[i] == SPELL_AURA_INCREASE_SPELL_HEALING_PCT)
 		{
-			if (mod->m_miscValue & (((uint32)1)<<x) )
-			{
-				m_target->SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x, m_target->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x) + val);
-				static_cast< Player* >( m_target )->SpellDmgDoneBySpr[x]+=((float)(val))/100;
-			}
+			if (m_spellProto->EffectMiscValue[i] < 5)
+				stat = m_spellProto->EffectMiscValue[i];
+			else
+				return;
 		}
-		if( m_target->IsPlayer() )
-			static_cast< Player* >( m_target )->UpdateChanceFields();
 	}
+
+	for(uint32 x=0;x<7;x++)
+	{
+		if (mod->m_miscValue & (((uint32)1)<<x) )
+		{
+			m_target->SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x, m_target->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x) + float2int32(((float)val/100)*m_target->GetUInt32Value(UNIT_FIELD_STAT0 + stat)));
+			static_cast< Player* >( m_target )->SpellDmgDoneByAttribute[stat][x] += ((float)(val))/100;
+		}
+	}
+
+	static_cast< Player* >( m_target )->UpdateChanceFields();
 }
 
-void Aura::SpellAuraIncreaseHealingBySpr(bool apply)
+void Aura::SpellAuraIncreaseHealingByAttribute(bool apply)
 {
 	Unit * pCaster = GetUnitCaster();
-	if(!pCaster)
+	if( pCaster == NULL || !m_target->IsPlayer() )
 		return;
 
 	int32 val;
 	val = mod->m_amount;
+
 	SM_FIValue(pCaster->SM_FEffectBonus,&val,m_spellProto->SpellGroupType);
 
 	if( apply )
@@ -6651,21 +7119,22 @@
 	else
 		val =- val;
 
-	if( m_target->IsPlayer() )
-	{	
-		for(uint32 x=1;x<7;x++)
-		{
-		   // if (mod->m_miscValue & (((uint32)1)<<x) )
-			{
-				static_cast< Player* >( m_target )->SpellHealDoneBySpr[x]+=((float)(val))/100;
-			}
-		}
-		if( m_target->IsPlayer() )
-		{
-			static_cast< Player* >( m_target )->UpdateChanceFields();
-			m_target->SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, m_target->GetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS) + val);
-		}
+	uint32 stat;
+	if (mod->m_miscValue < 5)
+		stat = mod->m_miscValue;
+	else
+	{
+		sLog.outError(
+			"Aura::SpellAuraIncreaseHealingByAttribute::Unknown spell attribute type %u in spell %u.\n",
+			mod->m_miscValue,GetSpellId());
+		return;
 	}
+
+	for(uint32 x=1;x<7;x++)
+		static_cast< Player* >( m_target )->SpellHealDoneByAttribute[stat][x] += ((float)(val))/100;
+
+	m_target->SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, m_target->GetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS) + float2int32(((float)val/100)*m_target->GetUInt32Value(UNIT_FIELD_STAT0 + stat)));
+	static_cast< Player* >( m_target )->UpdateChanceFields();
 }
 
 void Aura::SpellAuraAddFlatModifier(bool apply)
@@ -6967,11 +7436,55 @@
 
 void Aura::SpellAuraIncreaseTimeBetweenAttacksPCT(bool apply)
 {
-	int32 val =  (apply) ? mod->m_amount : -mod->m_amount;
-	float pct_value = -val/100.0f;
-	m_target->ModFloatValue(UNIT_MOD_CAST_SPEED,pct_value);
+	if( mod->m_amount < 0 )
+		SetNegative();
+	else 
+		SetPositive();
+
+	float pct_value = mod->m_amount/100.0f;
+	
+	if( m_target->IsPlayer() )
+	{
+		if( apply )
+		{
+			static_cast< Player* >( m_target )->m_meleeattackspeedmod += mod->m_amount;
+			m_target->ModFloatValue(UNIT_MOD_CAST_SPEED, -pct_value);
+		}
+		else
+		{
+			static_cast< Player* >( m_target )->m_meleeattackspeedmod -= mod->m_amount;
+			m_target->ModFloatValue(UNIT_MOD_CAST_SPEED, pct_value);
+		}
+		static_cast< Player* >(m_target)->UpdateAttackSpeed();
+	}
+	else
+	{
+		if( apply )
+		{
+			mod->fixed_amount[0] = m_target->GetModPUInt32Value( UNIT_FIELD_BASEATTACKTIME, mod->m_amount );
+			mod->fixed_amount[1] = m_target->GetModPUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, mod->m_amount );
+
+			if( (int32)m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME ) <= mod->fixed_amount[0] )
+				mod->fixed_amount[0] = m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME );
+			if( (int32)m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME_01 ) <= mod->fixed_amount[1] )
+				mod->fixed_amount[1] = m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME_01 );
+
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME, -mod->fixed_amount[0] );
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, -mod->fixed_amount[1] );
+
+			m_target->ModFloatValue(UNIT_MOD_CAST_SPEED, -pct_value);
+		}
+		else
+		{
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME, mod->fixed_amount[0] );
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, mod->fixed_amount[1] );
+			m_target->ModFloatValue( UNIT_MOD_CAST_SPEED, pct_value);
+		}
+	}
+
 }
 
+/*
 void Aura::SpellAuraIncreaseSpellDamageByInt(bool apply)
 {
 	 float val;
@@ -7023,6 +7536,7 @@
 		}
 	}
 }
+*/
 void Aura::SpellAuraModAttackerCritChance(bool apply)
 {
 	int32 val  = (apply) ? mod->m_amount : -mod->m_amount;
@@ -7518,20 +8032,58 @@
 	}
 }
 
-void Aura::SpellAuraAxeSkillModifier(bool apply)
+void Aura::SpellAuraHealingByAttackPowerPct(bool apply)
 {
+	Unit * pCaster = GetUnitCaster();
+	if( pCaster == NULL || !m_target->IsPlayer() )
+		return;
+
+	int32 val = mod->m_amount;
+
+	if( apply )
+		SetPositive();
+	else
+		val =- val;
+
+	int32 bonus = float2int32(((float)val/100)*(m_target->GetUInt32Value(UNIT_FIELD_ATTACK_POWER)+ m_target->GetUInt32Value(UNIT_FIELD_ATTACK_POWER_MODS)));
+	m_target->SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, m_target->GetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS) + bonus);
+
+	for( uint32 x=1; x<7; x++ )
+		m_target->HealDoneMod[x] += bonus;
+}
+
+void Aura::SpellAuraDamageByAttackPowerPct(bool apply)
+{
+	Unit * pCaster = GetUnitCaster();
+	if( pCaster == NULL || !m_target->IsPlayer() )
+		return;
+
+	int32 val = mod->m_amount;
+
+	if( apply )
+		SetPositive();
+	else
+		val =- val;
+
+	int32 bonus = float2int32(((float)val/100)*(m_target->GetUInt32Value(UNIT_FIELD_ATTACK_POWER)+ m_target->GetUInt32Value(UNIT_FIELD_ATTACK_POWER_MODS)));
+	for( uint32 x=1; x<7; x++ )
+		m_target->SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x, m_target->GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + x) + bonus);
+}
+
+void Aura::SpellAuraModExpertise(bool apply)
+{
 	if( p_target != NULL )
 	{
 		SetPositive();
 		if( apply )
 		{
-			p_target->_ModifySkillBonus( SKILL_AXES, mod->m_amount );
-			p_target->_ModifySkillBonus( SKILL_2H_AXES, mod->m_amount );
+			p_target->ModUInt32Value( PLAYER_RATING_MODIFIER_EXPERTISE, mod->m_amount );
+			p_target->ModUInt32Value( PLAYER_EXPERTISE, mod->m_amount );
 		}
 		else
 		{
-			p_target->_ModifySkillBonus( SKILL_AXES, -mod->m_amount );
-			p_target->_ModifySkillBonus( SKILL_2H_AXES, -mod->m_amount );
+			p_target->ModUInt32Value( PLAYER_RATING_MODIFIER_EXPERTISE, -mod->m_amount );
+			p_target->ModUInt32Value( PLAYER_EXPERTISE, -mod->m_amount );
 		}
 		p_target->UpdateStats();
 	}
Index: ascent-world/SpellEffects.cpp
===================================================================
--- ascent-world/SpellEffects.cpp	(revision 3944)
+++ ascent-world/SpellEffects.cpp	(working copy)
@@ -241,37 +241,31 @@
 			return;
 		}break;
 	case 18788: //Demonic Sacrifice (508745)
-		uint32 spellid1 = 0;
-		switch(unitTarget->GetEntry())
 		{
-			case 416: //Imp
-			{   
-				spellid1 = 18789;
-		
-			}break;
-			case 417: //Felhunter
+			uint32 spellid1 = 0;
+			switch(unitTarget->GetEntry())
 			{
-				spellid1 = 18792;
-		
-			}break;
-			case 1860: //VoidWalker
-			{
-				spellid1 = 18790;
-			}break;
-			case 1863: //Succubus
-			{
-				spellid1 = 18791;
-			}break;
-			case 17252: //felguard
-			{
-				spellid1 = 35701;
-			}break;
-		}
-		//now caster gains this buff
-		if( spellid1 > 0 )
-		{
-			u_caster->CastSpell( u_caster, dbcSpell.LookupEntry( spellid1 ), true );
-		}
+				case 416: //Imp  
+					spellid1 = 18789;
+				break;
+				case 417: //Felhunter
+					spellid1 = 18792;
+				break;
+				case 1860: //VoidWalker
+					spellid1 = 18790;
+				break;
+				case 1863: //Succubus
+					spellid1 = 18791;
+				break;
+				case 17252: //felguard
+					spellid1 = 35701;
+				break;
+			}
+			//now caster gains this buff
+			if( spellid1 != 0 )
+				u_caster->CastSpell( u_caster, dbcSpell.LookupEntry( spellid1 ), true );
+
+		}break;
 	}
 
 	//instant kill effects don't have a log
@@ -395,7 +389,20 @@
 		else 
 		{
 			if( u_caster != NULL )
-				u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, 0, 0, dmg, pSpellId == 0, true );
+			{
+				uint32 _type;
+				if( GetType() == SPELL_DMG_TYPE_RANGED )
+					_type = RANGED;
+				else
+				{
+					if (m_spellInfo->Flags4 & 0x1000000)
+						_type =  OFFHAND;
+					else
+						_type = MELEE;
+				}
+				u_caster->Strike( unitTarget, _type, m_spellInfo, 0, 0, dmg, pSpellId == 0, true );
+
+			}
 		}
 	}   
 }
@@ -410,6 +417,119 @@
 
 	switch( spellId )
 	{
+
+	case 5420: //Tree of Life
+		{
+			if( unitTarget == NULL )
+				return;
+
+			SpellEntry *spellInfo = dbcSpell.LookupEntry( 34123 );
+
+			Spell *sp = new Spell( unitTarget, spellInfo, true, NULL );
+			SpellCastTargets tgt;
+			tgt.m_unitTarget = unitTarget->GetGUID();
+			sp->prepare(&tgt);
+
+		} break;
+	case 5938: //shiv
+		{
+			if( p_caster == NULL || unitTarget == NULL )
+				return;
+
+			p_caster->Strike( unitTarget, OFFHAND, m_spellInfo, 0, 0, 0, false, true );
+			p_caster->AddComboPoints( unitTarget->GetGUID(), 1 );
+
+			if( p_caster->GetItemInterface() )
+			{
+				Item *it = p_caster->GetItemInterface()->GetInventoryItem( EQUIPMENT_SLOT_OFFHAND );
+				if( it == NULL )
+					return;
+		
+				EnchantmentInstance * ench = it->GetEnchantment( 1 ); // temp enchantment slot
+				if(ench)
+				{
+					EnchantEntry* Entry = ench->Enchantment;
+					for( uint32 c = 0; c < 3; c++ )
+					{
+						if( Entry->type[c] && Entry->spell[c] )
+						{
+							SpellEntry *sp = dbcSpell.LookupEntry( Entry->spell[c] );
+							if( sp == NULL )
+								return;
+
+							if( sp->c_is_flags & SPELL_FLAG_IS_POISON )
+							{
+								SpellCastTargets targets( unitTarget->GetGUID() );
+								Spell *spell = new Spell( p_caster, sp, true, 0 );
+								spell->prepare( &targets );
+							}
+						}
+					}
+				}
+			}
+
+		} break;
+	case 30427: // Extract Gas
+		{
+			bool check = false;
+			uint32 cloudtype;
+			Creature *creature;
+
+			if(!p_caster)
+				return;
+
+			for(Object::InRangeSet::iterator i = p_caster->GetInRangeSetBegin(); i != p_caster->GetInRangeSetEnd(); ++i)
+			{
+				if((*i)->GetTypeId() == TYPEID_UNIT)
+				{
+					creature=static_cast<Creature *>((*i));
+					cloudtype=creature->GetEntry();
+					if(cloudtype == 24222 || cloudtype == 17408 || cloudtype == 17407 || cloudtype == 17378)
+					{
+						if(p_caster->GetDistance2dSq((*i)) < 400)
+						{
+							p_caster->SetSelection(creature->GetGUID());
+							check = true;
+							break;
+						}
+					}
+				}
+			}
+			
+			if(check)
+			{
+				uint32 item,count = 3+(rand()%3);
+			
+				if (cloudtype==24222) item=22572;//-air
+				if (cloudtype==17408) item=22576;//-mana
+				if (cloudtype==17407) item=22577;//-shadow
+				if (cloudtype==17378) item=22578;//-water
+
+				Item *add = p_caster->GetItemInterface()->FindItemLessMax(item, count, false);
+				if (!add)
+				{
+					ItemPrototype* proto = ItemPrototypeStorage.LookupEntry(item);
+					SlotResult slotresult;
+
+					slotresult = p_caster->GetItemInterface()->FindFreeInventorySlot(proto);
+					if(!slotresult.Result)
+					{
+						p_caster->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+						return;
+					}
+					Item * it=objmgr.CreateItem(item,p_caster);  
+					it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
+					p_caster->GetItemInterface()->SafeAddItem(it,slotresult.ContainerSlot, slotresult.Slot);
+					creature->Despawn(3500,creature->proto->RespawnTime);
+				}
+				else
+				{
+					add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + count);
+					add->m_isDirty = true;
+					creature->Despawn(3500,creature->proto->RespawnTime);
+				}
+			}
+		}break; 
 /*	case 35029: //hunter: Focused Fire
 	case 35030:
 		{
@@ -547,6 +667,9 @@
 			if( !unitTarget || !p_caster) 
 				return;
 
+			if(!unitTarget->isAlive() || unitTarget->getClass()==WARRIOR || unitTarget->getClass() == ROGUE)
+				return;
+
 			uint32 count = 0;
 			for(uint32 x = 0; x < MAX_AURAS; ++x)
 			{
@@ -558,13 +681,16 @@
 			}
 
 			uint32 gain = (uint32)(count * (2.17*p_caster->getLevel()+9.136));
-			uint32 max = unitTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1);
-			if( unitTarget->GetUInt32Value( UNIT_FIELD_POWER1 ) + gain > max )
-				unitTarget->SetUInt32Value( UNIT_FIELD_POWER1, max );
-			else
-				unitTarget->SetUInt32Value( UNIT_FIELD_POWER1, unitTarget->GetUInt32Value( UNIT_FIELD_POWER1 ) + gain );
-			SendHealManaSpellOnPlayer( p_caster, static_cast< Player* >( unitTarget ), gain, 0 );
+			p_caster->Energize(unitTarget,28730,gain,POWER_TYPE_MANA);
 		}break;
+	case 39610://Mana Tide
+		{
+			if(unitTarget == NULL || unitTarget->isDead() || unitTarget->getClass()==WARRIOR || unitTarget->getClass() == ROGUE)
+				return;
+
+			uint32 gain = (uint32) (unitTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1)*0.06);
+			unitTarget->Energize(unitTarget,16191,gain,POWER_TYPE_MANA);
+		}break;
 	case 4141:// Summon Myzrael
 		{
 			//2755
@@ -1109,6 +1235,7 @@
 			ILotP.procFlags = PROC_ON_CRIT_ATTACK | PROC_TARGET_SELF;
 			ILotP.deleted = false;
 			ILotP.caster = u_caster->GetGUID();
+			ILotP.ProcType = 0;
 			ILotP.LastTrigger = 0;
 			u_caster->m_procSpells.push_back(ILotP);
 		}
@@ -1162,8 +1289,7 @@
 		{
 			/* try to get a selection */
  			unitTarget = m_caster->GetMapMgr()->GetUnit(p_caster->GetSelection());
-//			if( (unitTarget == NULL ) || !isHostile(p_caster, unitTarget) || (unitTarget->CalcDistance(p_caster) > 25.0f)) //removed by Zack : no idea why hostile is used. Isattackable should give a wider solution range
-			if( (unitTarget == NULL ) || !isAttackable(p_caster, unitTarget, !(m_spellInfo->c_is_flags & SPELL_FLAG_IS_TARGETINGSTEALTHED) ) || (unitTarget->CalcDistance(p_caster) > 25.0f))
+			if(unitTarget == NULL || (unitTarget->CalcDistance(p_caster) > 33.0f))
 				return;
 		}
 
@@ -1190,12 +1316,12 @@
 		}
 
 		// avoid teleporting into the model on scaled models
-		const static float shadowstep_distance = 1.6f * unitTarget->GetFloatValue(OBJECT_FIELD_SCALE_X);
+		const static float shadowstep_distance = 1.35f * max(unitTarget->GetFloatValue(OBJECT_FIELD_SCALE_X), 1.0f);
 		float new_x = unitTarget->GetPositionX() - (shadowstep_distance * cosf(ang));
 		float new_y = unitTarget->GetPositionY() - (shadowstep_distance * sinf(ang));
 		
 		/* Send a movement packet to "charge" at this target. Similar to warrior charge. */
-		p_caster->SafeTeleport(p_caster->GetMapId(), p_caster->GetInstanceID(), LocationVector(new_x, new_y, (unitTarget->GetPositionZ() + 0.1f), unitTarget->GetOrientation()));
+		p_caster->SafeTeleport(p_caster->GetMapId(), p_caster->GetInstanceID(), LocationVector(new_x, new_y, (unitTarget->GetPositionZ() + 0.2f), unitTarget->GetOrientation()));
 		
 		return;
 	}
@@ -1212,28 +1338,124 @@
 		return;
 
 	// can't apply stuns/fear/polymorph/root etc on boss
-	if( !unitTarget->IsPlayer() )
-	{
-		Creature* c = static_cast< Creature* >( unitTarget );
-		if( c != NULL && c->GetCreatureName() && c->GetCreatureName()->Rank == ELITE_WORLDBOSS )
-		{
-			switch( m_spellInfo->EffectApplyAuraName[i] )
-			{
-			case 5:  // confuse
-			case 6:  // charm
-			case 7:  // fear
-			case 12: // stun
-			case 25: // pacify
-			case 26: // root
-			case 27: // silence
-			case 31: // increase speed
-			case 33: // decrease speed
-				SendCastResult( SPELL_FAILED_IMMUNE );
-				return;
-			}
-		}
-	}
+	if (!unitTarget->IsPlayer())
+ 	{
+		if (u_caster && (u_caster != unitTarget))
+ 		{
+			Creature * c = (Creature*)( unitTarget );
+			if (c)
+ 			{
 
+				/*
+				Charm (Mind Control, enslave demon): 1
+				Confuse (Blind etc): 2
+				Fear: 4
+				Root: 8
+				Silence : 16
+				Stun: 32
+				Sheep: 64
+				Banish: 128
+				Taunt (applyaura): 256
+				Decrease Speed (Hamstring) (applyaura): 512
+				Spell Haste (Curse of Tongues) (applyaura): 1024
+				Interupt Cast: 2048
+				Mod Healing % (Mortal Strike) (applyaura):4096
+				*/
+
+				//Spells with Mechanic also add other ugly auras, but if the main aura is the effect --> immune to whole spell
+				if (c->proto && c->proto->modImmunities)
+				{
+					bool immune = false;
+					if (m_spellInfo->MechanicsType)
+					{
+						switch(m_spellInfo->MechanicsType)
+						{
+						case MECHANIC_CHARMED:
+							if (c->proto->modImmunities & 1)
+								immune = true;
+							break;
+						case MECHANIC_DISORIENTED:
+							if (c->proto->modImmunities & 2)
+								immune = true;
+							break;
+						case MECHANIC_FLEEING:
+							if (c->proto->modImmunities & 4)
+								immune = true;
+							break;
+						case MECHANIC_ROOTED:
+							if (c->proto->modImmunities & 8)
+								immune = true;
+							break;
+						case MECHANIC_SILENCED:
+							if ( c->proto->modImmunities & 16)
+								immune = true;
+							break;
+						case MECHANIC_STUNNED:
+							if (c->proto->modImmunities & 32)
+								immune = true;
+							break;
+						case MECHANIC_POLYMORPHED:
+							if (c->proto->modImmunities & 64)
+								immune = true;
+							break;
+						case MECHANIC_BANISHED:
+							if (c->proto->modImmunities & 128)
+								immune = true;
+							break;
+						}
+					}
+					else
+					{
+						// Spells wich do more than just one thing (damage and the effect) dont have a mechanic and we should only cancel the aura to be placed
+						switch (m_spellInfo->EffectApplyAuraName[i])
+						{
+						case SPELL_AURA_MOD_CONFUSE:
+							if (c->proto->modImmunities & 2)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_FEAR:
+							if (c->proto->modImmunities & 4)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_TAUNT:
+							if (c->proto->modImmunities & 256)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_STUN: // no idea if its needed, just to be sure
+							if (c->proto->modImmunities & 32)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_SILENCE:
+							if ((c->proto->modImmunities & 2048) || (c->proto->modImmunities & 16))
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_DECREASE_SPEED:
+							if (c->proto->modImmunities & 512)
+								immune = true;
+							break;
+						case SPELL_AURA_INCREASE_CASTING_TIME_PCT:
+							if (c->proto->modImmunities & 1024)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_LANGUAGE: //hacky way to prefer that the COT icon is set to mob
+							if (c->proto->modImmunities & 1024)
+								immune = true;
+							break;
+						case SPELL_AURA_MOD_HEALING_DONE_PERCENT:
+							if (c->proto->modImmunities & 4096)
+								immune = true;
+							break;
+						}
+					}
+					if (immune)
+					{
+						return;
+					}
+				}
+ 			}
+ 		}
+ 	}
+
 	// avoid map corruption.
 	if( unitTarget->GetInstanceID() != m_caster->GetInstanceID() )
 		return;
@@ -1260,7 +1482,7 @@
 		if( g_caster != NULL && g_caster->GetUInt32Value( OBJECT_FIELD_CREATED_BY ) && g_caster->m_summoner != NULL )
 			pAura = new Aura( m_spellInfo, Duration, g_caster->m_summoner, unitTarget);
 		else
-			pAura = new Aura( m_spellInfo, Duration, m_caster, unitTarget );
+			pAura = new Aura( m_spellInfo, Duration, m_caster, unitTarget, i_caster );
 
 		pAura->pSpellId = pSpellId; //this is required for triggered spells
 		
@@ -1281,7 +1503,11 @@
 
 	uint32 powerField = UNIT_FIELD_POWER1+m_spellInfo->EffectMiscValue[i];
 	uint32 curPower = unitTarget->GetUInt32Value(powerField);
-	uint32 amt=damage+((u_caster->GetDamageDoneMod(m_spellInfo->School)*80)/100);
+	uint32 amt;
+	if (m_spellInfo->NameHash == SPELL_HASH_DARK_PACT)
+		amt=damage+((u_caster->GetDamageDoneMod(m_spellInfo->School)*96)/100);
+	else
+		amt=damage;
 	if(amt>curPower)
 	{
 		amt=curPower;
@@ -1504,7 +1730,20 @@
 				m_spellInfo, (uint32)damage, EVENT_SPELL_DAMAGE_HIT, float2int32(time), 1, EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
 	}
 	else
-		u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, damage, 0, 0, false, true );
+	{
+
+		uint32 _type;
+		if( GetType() == SPELL_DMG_TYPE_RANGED )
+			_type = RANGED;
+		else
+		{
+			if (m_spellInfo->Flags4 & 0x1000000)
+				_type =  OFFHAND;
+			else
+				_type = MELEE;
+		}
+		u_caster->Strike( unitTarget, _type, m_spellInfo, damage, 0, 0, false, true );
+	}
 }
 
 void Spell::SpellEffectAddExtraAttacks(uint32 i) // Add Extra Attacks
@@ -1590,24 +1829,85 @@
 
 		if (skill && skill->skilline == SKILL_ALCHEMY)
 		{
+			// potions learned by discovery variables
+			uint32 cast_chance = 5;
+			uint32 learn_spell = 0;
+
 			//Potion Master
 			if (strstr(m_itemProto->Name1, "Potion"))
 			{
 				if(p_caster->HasSpell(28675)) 
 					while (Rand(20) && item_count<10) item_count++;
+
+				// Super Rejuvenation Potion
+				cast_chance = 2;
+				learn_spell = 28586;
 			}
-			//Elixir Master
+			//Elixirs
 			if (strstr(m_itemProto->Name1, "Elixir") || strstr(m_itemProto->Name1, "Flask"))
 			{
-				if(p_caster->HasSpell(28677)) 
+				if(p_caster->HasSpell(28677)) //Elixir Master
 					while (Rand(20) && item_count<10) item_count++;
+
+				uint32 spList[] = {28590,28587,28588,28591,28589};
+				cast_chance = 2;
+				learn_spell = spList[RandomUInt(4)];
 			}
-			//Transmutation Master
+			 //Transmutation
 			if (m_spellInfo->Category == 310)
 			{
-				if(p_caster->HasSpell(28672)) 
+				if(p_caster->HasSpell(28672))  //Transmutation Master
 					while (Rand(20) && item_count<10) item_count++;
+
+				uint32 spList[] = {28581,28585,28585,28584,28582,28580};
+				cast_chance = 5;
+				learn_spell = spList[RandomUInt(5)];
 			}
+
+			//random discovery by crafter item id
+			switch ( m_itemProto->ItemId )
+			{
+			case 22845: //Major Arcane Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41458;
+				}break;
+			case 22841: //Major Fire Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41500;
+				}break;
+			case 22842: //Major Frost Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41501;
+				}break;
+			case 22847: //Major Holy Protection Potion
+				{
+					// there is none
+				}break;
+			case 22844: //Major Nature Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41502;
+				}break;
+			case 22846: //Major Shadow Protection Potion
+				{
+					cast_chance = 20;
+					learn_spell = 41503;
+				}break;
+			}
+
+			if ( learn_spell && p_caster->getLevel() > 60 && !p_caster->HasSpell( learn_spell ) && Rand( cast_chance ) )
+			{
+				SpellEntry* _spellproto = dbcSpell.LookupEntry( learn_spell );
+				if( _spellproto != NULL )
+				{
+					p_caster->BroadcastMessage( "%sDISCOVERY! You discovered the %s !|r", MSG_COLOR_YELLOW, _spellproto->Name );
+					p_caster->addSpell( learn_spell );
+				}
+			}
+
 		}
 
 		// item count cannot be more than allowed in a single stack
@@ -1950,8 +2250,22 @@
 	       pCreature->SetUInt32Value(UNIT_FIELD_LEVEL, p_caster->getLevel());
 	       pCreature->SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, p_caster->GetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE));
 	       pCreature->_setFaction();
+		   pCreature->SetUInt64Value(UNIT_FIELD_SUMMONEDBY, p_caster->GetGUID());
+		   pCreature->SetUInt64Value(UNIT_FIELD_CREATEDBY, p_caster->GetGUID());
 	       p_caster->SetUInt64Value(UNIT_FIELD_SUMMON, pCreature->GetGUID());
+		  
 	       p_caster->m_tempSummon = pCreature;
+
+		   if ( m_spellInfo->EffectMiscValue[i] == 19668 ) //shadowfiend
+			{
+				float parent_bonus = (float)(p_caster->GetDamageDoneMod(SCHOOL_SHADOW)*0.065f);
+				pCreature->SetFloatValue(UNIT_FIELD_MINDAMAGE, pCreature->GetFloatValue(UNIT_FIELD_MINDAMAGE) + parent_bonus);
+				pCreature->SetFloatValue(UNIT_FIELD_MAXDAMAGE, pCreature->GetFloatValue(UNIT_FIELD_MAXDAMAGE) + parent_bonus);
+				pCreature->BaseDamage[0] += parent_bonus;
+				pCreature->BaseDamage[1] += parent_bonus;
+				//TODO add avoidance chance 75%
+			}
+
 	       pCreature->PushToWorld(p_caster->GetMapMgr());
 
 	       /*if(p_caster->isInCombat())
@@ -1962,7 +2276,7 @@
 	       }*/
 	       
 	       /* not sure on this */
-	       sEventMgr.AddEvent(pCreature, &Creature::SafeDelete, EVENT_CREATURE_REMOVE_CORPSE, /*GetDuration()*/45000, 1, 0);
+	       sEventMgr.AddEvent(pCreature, &Creature::SafeDelete, EVENT_CREATURE_REMOVE_CORPSE, GetDuration()+2000 /*45000*/, 1, 0);
 	}
 }
 
@@ -2132,7 +2446,19 @@
 		u_caster->SpellNonMeleeDamageLog(unitTarget, m_spellInfo->Id, dmg, false, false, false);
 	}
 	else
-		u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, add_damage, damage, 0, false, true );
+	{
+		uint32 _type;
+		if( GetType() == SPELL_DMG_TYPE_RANGED )
+			_type = RANGED;
+		else
+		{
+			if (m_spellInfo->Flags4 & 0x1000000)
+				_type =  OFFHAND;
+			else
+				_type = MELEE;
+		}
+		u_caster->Strike( unitTarget, _type, m_spellInfo, add_damage, damage, 0, false, true );
+	}
 }
 
 void Spell::SpellEffectTriggerMissile(uint32 i) // Trigger Missile
@@ -2228,9 +2554,9 @@
 		}
 		case LOCKTYPE_HERBALISM:
 		{
-			if(!gameObjTarget ) return;	  
+			if( !gameObjTarget ) return;	  
 			
-			uint32 v=GetGOReqSkill(gameObjTarget);
+			uint32 v = gameObjTarget->GetGOReqSkill();
 			bool bAlreadyUsed = false;
 		 
 			if(Rand(100.0f)) // 3% chance to fail//why?
@@ -2274,7 +2600,7 @@
 		{
 			if(!gameObjTarget ) return;
 
-			uint32 v = GetGOReqSkill(gameObjTarget);
+			uint32 v = gameObjTarget->GetGOReqSkill();
 			bool bAlreadyUsed = false;
 
 			if( Rand( 100.0f ) ) // 3% chance to fail//why?
@@ -2499,7 +2825,7 @@
 	std::map< uint32, Aura* >::iterator itr = unitTarget->tmpAura.find( m_spellInfo->Id );
 	if( itr == unitTarget->tmpAura.end() )
 	{
-		pAura = new Aura( m_spellInfo, GetDuration(), m_caster, unitTarget );
+		pAura = new Aura( m_spellInfo, GetDuration(), m_caster, unitTarget, i_caster  );
 
 		//unitTarget->tmpAura[m_spellInfo->Id] = pAura;
 		unitTarget->tmpAura.insert( make_pair( m_spellInfo->Id, pAura ) );
@@ -2649,7 +2975,7 @@
 		pPet->AddSpell( dbcSpell.LookupEntry( m_spellInfo->EffectTriggerSpell[i] ), true );
 
 		// Send Packet
-		WorldPacket data(SMSG_PET_LEARNT_SPELL, 21);
+		WorldPacket data(SMSG_SET_AURA_SINGLE, 21);
 		data << pPet->GetGUID() << uint8(0) << uint32(m_spellInfo->EffectTriggerSpell[i]) << uint32(-1) << uint32(0);
 		p_caster->GetSession()->SendPacket(&data);
 	}
@@ -3019,7 +3345,6 @@
 	}
 	else
 	{
-		//portal, lightwell
 		posx = px;
 		posy = py;		
 		GameObjectInfo* goI = GameObjectNameStorage.LookupEntry(entry);
@@ -3071,10 +3396,17 @@
 			go->m_ritualtarget = pTarget->GetGUIDLow();
 			go->m_ritualspell = m_spellInfo->Id;	 
 		}
-		else//Lightwell,if there is some other type -- add it
+		else if( entry == 186811 || entry == 181622) // Portal for Ritual of Refreshment/Souls
 		{
-			go->charges=5;//Max 5 charges
+			go->m_ritualmembers[0] = p_caster->GetGUIDLow();
+			go->m_ritualcaster = p_caster->GetGUIDLow();
+			go->m_ritualspell = m_spellInfo->Id;	 
 		}
+		else
+		{
+			go->charges = goI->sound1;
+		}
+		
 		p_caster->SetSummonedObject(go);		
 	}
 }
@@ -3159,72 +3491,69 @@
 
 void Spell::SpellEffectSummonPet(uint32 i) //summon - pet
 {
-	uint32 entry = m_spellInfo->EffectMiscValue[i];
-	CreatureInfo *ci = CreatureNameStorage.LookupEntry(entry);
-	CreatureProto *cp = CreatureProtoStorage.LookupEntry(entry);
-	if (ci == NULL || cp == NULL)
-		return;
+    uint32 entry = m_spellInfo->EffectMiscValue[i];
+    CreatureInfo *ci = CreatureNameStorage.LookupEntry(entry);
+    switch(m_spellInfo->Id)
+     {
+        case 883:// "Call Pet"
+        {        
+            if(!p_caster || p_caster->getClass() != HUNTER)
+                break;
+            if(p_caster->GetSummon() != 0)
+            {
+                p_caster->GetSession()->SendNotification("You already have a pet summoned.");
+                break;
+            }
+            uint32 petno = p_caster->GetUnstabledPetNumber();
+            if(petno)
+            {
+                p_caster->SpawnPet(petno);
+            }
+            else
+            {
+                WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 50);
+                data << uint32(0) << "You do not have any pets to call." << uint8(0);
+                p_caster->GetSession()->SendPacket(&data);
+            }
+        }break;
+        case 688:// "Summon Imp"
+        case 697:// "Summon Voidwalker"
+        case 712:// "Summon Succubus"
+        case 691:// "Summon Felhunter"
+        case 30146:// "Summon Felguard"
+         {
+           //VoidWalker:torment, sacrifice, suffering, consume shadows
+            //Succubus:lash of pain, soothing kiss, seduce , lesser invisibility
+            //felhunter:     Devour Magic,Paranoia,Spell Lock,    Tainted Blood
+            if(!p_caster || p_caster->getClass() != WARLOCK)
+                break;
 
-	switch(m_spellInfo->Id)
-	{
-	case 883:// "Call Pet"
-		{		
-			if(!p_caster)
-				return; 
-			if(p_caster->GetSummon() != 0)
-			{
-				p_caster->GetSession()->SendNotification("You already have a pet summoned.");
-				return;
-			}
-			uint32 petno = p_caster->GetUnstabledPetNumber();
-			if(petno)
-				p_caster->SpawnPet(petno);
-			else
-			{
-				WorldPacket data(SMSG_AREA_TRIGGER_MESSAGE, 50);
-				data << uint32(0) << "You do not have any pets to call." << uint8(0);
-				p_caster->GetSession()->SendPacket(&data);
-			}
-		}break;
-	case 688:// "Summon Imp"
-	case 697:// "Summon Voidwalker"
-	case 712:// "Summon Succubus"
-	case 691:// "Summon Felhunter"
-	case 30146:// "Summon Felguard"
-		{
-			//VoidWalker:torment, sacrifice, suffering, consume shadows
-			//Succubus:lash of pain, soothing kiss, seduce , lesser invisibility
-			//felhunter:	 Devour Magic,Paranoia,Spell Lock,	Tainted Blood
-			if(!p_caster || !u_caster)
-				return;
-			// remove old pet
-			Pet *old = static_cast<Player*>(m_caster)->GetSummon();
-			if(old)
-				old->Dismiss(false);
+            // remove old pet
+            Pet *old = static_cast<Player*>(m_caster)->GetSummon();
+            if(old)
+                old->Dismiss(false);
 
-			p_caster->RemoveAura(18789);
-			p_caster->RemoveAura(18790);
-			p_caster->RemoveAura(18791);
-			p_caster->RemoveAura(18792);
-			p_caster->RemoveAura(35701);
-
-			Pet *summon = objmgr.CreatePet();
-			summon->SetInstanceID(m_caster->GetInstanceID());
-			summon->CreateAsSummon(m_spellInfo->EffectMiscValue[i], ci, NULL, u_caster, m_spellInfo, 1, 0);
-		}break;
-	default:
-		{
-			if( u_caster == NULL )
-				return;
-			if( u_caster->summonPet )
-			{
-				u_caster->summonPet->RemoveFromWorld(false,true);
-				delete u_caster->summonPet;
-				u_caster->summonPet = NULL;
-			}			
-			u_caster->create_guardian(entry, -1, (float(-(M_PI/2))));
-		}break;
-	}
+            p_caster->RemoveAura(18789);
+            p_caster->RemoveAura(18790);
+            p_caster->RemoveAura(18791);
+            p_caster->RemoveAura(18792);
+            p_caster->RemoveAura(35701);
+            
+            Pet *summon = objmgr.CreatePet();
+            summon->SetInstanceID(m_caster->GetInstanceID());
+            summon->CreateAsSummon(m_spellInfo->EffectMiscValue[i], ci, NULL, u_caster, m_spellInfo, 1, 0);
+        }break;
+        default:
+         {
+            if(u_caster->summonPet)
+            {
+                u_caster->summonPet->RemoveFromWorld(false,true);
+                delete u_caster->summonPet;
+                u_caster->summonPet = NULL;
+            }            
+            u_caster->create_guardian(entry, -1, (float(-(M_PI/2))));
+        }break;
+     }
 }
 
 void Spell::SpellEffectWeapondamage( uint32 i ) // Weapon damage +
@@ -3232,8 +3561,8 @@
 	if( unitTarget == NULL || u_caster == NULL )
 		return;
 
-	//Hackfix for Mangle and Hemorrhage
-	if( (m_spellInfo->NameHash == SPELL_HASH_MANGLE__CAT_ || m_spellInfo->NameHash == SPELL_HASH_HEMORRHAGE) && u_caster->IsPlayer() )
+	//Hackfix for Mangle
+	if( m_spellInfo->NameHash == SPELL_HASH_MANGLE__CAT_ && u_caster->IsPlayer() )
 			static_cast< Player* >( u_caster )->AddComboPoints( unitTarget->GetGUID(), 1 );
 
 	// Hacky fix for druid spells where it would "double attack".
@@ -3242,7 +3571,19 @@
 		add_damage += damage;
 		return;
 	}
-	u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, damage, 0, 0, false, true );
+	
+	uint32 _type;
+	if( GetType() == SPELL_DMG_TYPE_RANGED )
+		_type = RANGED;
+	else
+	{
+		if (m_spellInfo->Flags4 & 0x1000000)
+			_type =  OFFHAND;
+		else
+			_type = MELEE;
+	}
+
+	u_caster->Strike( unitTarget, _type, m_spellInfo, damage, 0, 0, false, true );
 }
 
 void Spell::SpellEffectPowerBurn(uint32 i) // power burn
@@ -3273,7 +3614,7 @@
 	if(!unitTarget)
 		return;
 
-	Spell*sp=new Spell(m_caster,dbcSpell.LookupEntry(m_spellInfo->EffectTriggerSpell[i]),true,NULL);
+	Spell* sp = new Spell(m_caster,dbcSpell.LookupEntry(m_spellInfo->EffectTriggerSpell[i]),true,NULL);
 	SpellCastTargets tgt(unitTarget->GetGUID());
 	sp->prepare(&tgt);
 
@@ -3323,9 +3664,15 @@
 	// can't apply stuns/fear/polymorph/root etc on boss
 	if(unitTarget->GetTypeId()==TYPEID_UNIT)
 	{
-		Creature * c = (Creature*)( unitTarget );
-		if (c&&c->GetCreatureName()&&c->GetCreatureName()->Rank == ELITE_WORLDBOSS)
-			return;
+		if (u_caster && (u_caster != unitTarget))
+		{
+			Creature *c = (Creature*)( unitTarget );
+			if (c && c->proto && c->proto->modImmunities)
+			{
+				if (c->proto->modImmunities & 2048)
+						return;
+			}
+		}
 	}
 	// FIXME:This thing prevent target from spell casting too but cant find.
 	uint32 school=0;
@@ -3374,7 +3721,7 @@
 		return;
 
 	Creature *target = static_cast<Creature*>( unitTarget );
-	if(target->IsPickPocketed() || (target->GetCreatureName() && target->GetCreatureName()->Type != HUMANOID))
+	if(target->IsPickPocketed() || !lootmgr.IsPickpocketable( target->GetEntry() ) )
 	{
 		SendCastResult(SPELL_FAILED_TARGET_NO_POCKETS);
 		return;
@@ -4253,7 +4600,7 @@
 		pTotem->EnableAI();
 		pTotem->GetAIInterface()->Init(pTotem, AITYPE_TOTEM, MOVEMENTTYPE_NONE, p_caster);
 		pTotem->GetAIInterface()->totemspell = TotemSpell;
-		uint32 timer = 2000;	// need a proper resource for this.
+		uint32 timer = 3000;	// need a proper resource for this.
 
 		switch(TotemSpell->Id)
 		{
@@ -4377,7 +4724,7 @@
 		return;
 	if( p_caster == NULL )
 		return;
-    if( p_caster->IsStunned() || p_caster->m_rooted || p_caster->IsPacified() )
+    if (p_caster->IsStunned() || p_caster->m_rooted || p_caster->IsPacified() || p_caster->IsFeared())
         return;
 
 	float x, y, z;
@@ -4401,7 +4748,7 @@
 
 	x = d*cosf(alpha)+m_caster->GetPositionX();
 	y = d*sinf(alpha)+m_caster->GetPositionY();
-	z = unitTarget->GetPositionZ();
+	z = unitTarget->GetPositionZ() + 0.2f;
 
 	uint32 time = uint32( (m_caster->CalcDistance(unitTarget) / ((m_caster->m_runSpeed * 3.5) * 0.001f)) + 0.5);
 
@@ -4523,9 +4870,16 @@
 	float dx,dy;//,dz;
 	float affect = float(damage)/10;
 
-	//Not sure about /100
-	dx = sinf(m_caster->GetOrientation());
-	dy = cosf(m_caster->GetOrientation());
+	if (u_caster == NULL || u_caster != unitTarget)
+	{
+		dx = sinf(m_caster->GetOrientation());
+		dy = cosf(m_caster->GetOrientation());
+	}
+	else
+	{
+		dx = 0.0f;
+		dy = 0.0f;
+	}
 
 	WorldPacket data(SMSG_MOVE_KNOCK_BACK, 50);
 	data << unitTarget->GetNewGUID();
@@ -4542,20 +4896,26 @@
 void Spell::SpellEffectDisenchant(uint32 i)
 {
 	Player* caster = static_cast< Player* >( m_caster );
-	Item* it = caster->GetItemInterface()->SafeRemoveAndRetreiveItemByGuid( m_targets.m_itemTarget, true );
+	Item* it = caster->GetItemInterface()->GetItemByGUID(m_targets.m_itemTarget);
 	if( it == NULL )
 		return;
    
 	//Check for skill first, we can increase it upto 75 
 	uint32 skill=caster->_GetSkillLineCurrent( SKILL_ENCHANTING );
 	if(skill < 75)//can up skill
-	if(Rand(float(100-skill*100.0/75.0)))
-		caster->_AdvanceSkillLine(SKILL_ENCHANTING, float2int32( 1.0f * sWorld.getRate(RATE_SKILLRATE)));
-	AddItemFromDisenchant(it->GetProto(),caster);
+		if(Rand(float(100-skill*100.0/75.0)))
+			caster->_AdvanceSkillLine(SKILL_ENCHANTING, float2int32( 1.0f * sWorld.getRate(RATE_SKILLRATE)));
+ 
+	caster->SetLootGUID(it->GetGUID());
+	if(!it->loot)
+	{
+		it->loot = new Loot;
+		lootmgr.FillDisenchantingLoot(it->loot, it->GetEntry());
+	}
+	caster->SendLoot(it->GetGUID(), 2);
 
 	if(it==i_caster)
 		i_caster=NULL;
-	delete it;
 }
 
 void Spell::SpellEffectInebriate(uint32 i) // lets get drunk!
@@ -4698,9 +5058,11 @@
 	if(pPet)
 	{
 		pPet->SetUInt32Value(UNIT_DYNAMIC_FLAGS, 0);
-		pPet->SetUInt32Value(UNIT_FIELD_HEALTH, (uint32)(pPet->GetUInt32Value(UNIT_FIELD_MAXHEALTH) * 0.5));
+		// stored in EffectBasePoints[] but since only one spell uses this effect ...
+		pPet->SetUInt32Value(UNIT_FIELD_HEALTH, (uint32)(pPet->GetUInt32Value(UNIT_FIELD_MAXHEALTH) * 0.15));
 		pPet->setDeathState(ALIVE);
 		pPet->GetAIInterface()->HandleEvent(EVENT_FOLLOWOWNER, pPet, 0);
+		pPet->SendSpellsToOwner();
 		sEventMgr.RemoveEvents(pPet, EVENT_PET_DELAYED_REMOVE);
 	}
 }
@@ -4977,7 +5339,7 @@
 			}
 		}
 		if(!spellInfo)
-			return; //omg how did this happen ?
+			return;
 		//we should also cast sunder armor effect on target with or without dmg
 		Spell *spell = new Spell(u_caster, spellInfo ,true, NULL);
 		spell->ProcedOnSpell = m_spellInfo;
@@ -4985,25 +5347,37 @@
 		SpellCastTargets targets(unitTarget->GetGUID());
 		spell->prepare(&targets);
 		if(!sunder_count)
-			return; //no damage = no joy
-		damage = damage*sunder_count;
+			return;
+		if ( sunder_count > 5 ) sunder_count = 5;
+		damage = (int32)(0.01*damage*(m_spellInfo->EffectBasePoints[0]+1)+(1+ m_spellInfo->EffectBasePoints[1])*sunder_count);
 	}
 
+	//hemorage
+	if( p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_HEMORRHAGE )
+		p_caster->AddComboPoints(p_caster->GetSelection(), 1);
+
 	if( m_spellInfo->Effect[0] == SPELL_EFFECT_WEAPON_PERCENT_DAMAGE || m_spellInfo->Effect[1] == SPELL_EFFECT_WEAPON_PERCENT_DAMAGE)
 	{
 		add_damage = (uint32)(damage * 1.5);
 		return;
 	}
 
-	//hemorage
-	if( p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_HEMORRHAGE )
-		p_caster->AddComboPoints(p_caster->GetSelection(), 1);
-
 	//rogue - mutilate ads dmg if target is poisoned
 	if(	m_spellInfo->NameHash == SPELL_HASH_MUTILATE && unitTarget->IsPoisoned() )
 		damage = damage + float2int32( (float)damage * 0.5f );
 
-	u_caster->Strike( unitTarget, ( GetType() == SPELL_DMG_TYPE_RANGED ? RANGED : MELEE ), m_spellInfo, damage, 0, 0, false, true );
+	uint32 _type;
+	if( GetType() == SPELL_DMG_TYPE_RANGED )
+		_type = RANGED;
+	else
+	{
+		if (m_spellInfo->Flags4 & 0x1000000)
+			_type =  OFFHAND;
+		else
+			_type = MELEE;
+	}
+
+	u_caster->Strike( unitTarget, _type, m_spellInfo, damage, 0, 0, false, true );
 }
 
 void Spell::SpellEffectSpellSteal( uint32 i )
@@ -5036,13 +5410,27 @@
 				data << m_caster->GetNewGUID();
 				data << unitTarget->GetNewGUID();
 				data << (uint32)1;
-				data << aur->GetSpellId();
-				m_caster->SendMessageToSet(&data,true);
-				Aura *aura = new Aura(aur->GetSpellProto(), (aur->GetDuration()>120000) ? 120000 : aur->GetDuration(), u_caster, u_caster);
-				u_caster->AddAura(aura);
-				unitTarget->RemoveAura(aur);
-				if( --spells_to_steal <= 0 )
-					break; //exit loop now
+ 				data << aur->GetSpellId();
+ 				m_caster->SendMessageToSet(&data,true);
+				uint32 dur = aur->GetDuration();
+				if (dur > 120000)
+					dur = 120000;
+ 				u_caster->CastSpell(u_caster, aur->GetSpellProto(), true);
+ 				unitTarget->RemoveAllAuras(aur->GetSpellProto()->Id,aur->GetCasterGUID());
+				Aura *aura = u_caster->FindAura(aur->GetSpellId());
+				if (aura)
+				{
+					aura->SetDuration(dur);
+					sEventMgr.ModifyEventTimeLeft(aura, EVENT_AURA_REMOVE, dur);
+					if(u_caster->IsPlayer())
+					{
+						WorldPacket data(5);
+						data.SetOpcode(SMSG_UPDATE_AURA_DURATION);
+						data << (uint8)(aura)->GetAuraSlot() << dur;
+						p_caster->GetSession()->SendPacket(&data);
+					}
+				}
+				return;
 			}			
 		}
 	}   
@@ -5062,7 +5450,9 @@
 
 	if(p_caster->GetItemInterface()->RemoveItemAmt(entry, 5))
 	{
-		AddItemFromProspecting(entry, p_caster);
+		p_caster->SetLootGUID(p_caster->GetGUID());
+		lootmgr.FillProspectingLoot(&p_caster->loot, entry);
+		p_caster->SendLoot(p_caster->GetGUID(), 2);
 	}
 	else // this should never happen either
 	{
Index: ascent-world/Unit.cpp
===================================================================
--- ascent-world/Unit.cpp	(revision 3944)
+++ ascent-world/Unit.cpp	(working copy)
@@ -3953,21 +4212,32 @@
 //==============================+Spell Damage Bonus Modifications===========================
 //==========================================================================================
 //------------------------------by cast duration--------------------------------------------
-	SpellCastTime *sd = dbcSpellCastTime.LookupEntry(spellInfo->CastingTimeIndex);
-	float castaff = float(GetCastTime(sd));
-	if(castaff < 1500) castaff = 1500;
-	else
-		if(castaff > 7000) castaff = 7000;
+	float dmgdoneaffectperc = 1.0f;
+	// exception for spell with both dot and direct dmg - use bonus only for direct dmg for now
+	if (spellInfo->dmg_bonus && ((isDot && spellInfo->Effect[0] != SPELL_EFFECT_SCHOOL_DAMAGE && 
+		spellInfo->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE && spellInfo->Effect[2] != SPELL_EFFECT_SCHOOL_DAMAGE)
+		|| !isDot))
+	{
+		dmgdoneaffectperc = spellInfo->dmg_bonus/100.0f;
+	}
+	else if (!isDot) // this isnt valid for DoTs
+	{
+		SpellCastTime *sd = dbcSpellCastTime.LookupEntry(spellInfo->CastingTimeIndex);
+		float castaff = float(GetCastTime(sd));
+		if(castaff < 1500) castaff = 1500;
+		else
+			if(castaff > 7000) castaff = 7000;
 
-	float dmgdoneaffectperc = castaff / 3500;
-
+		dmgdoneaffectperc = castaff / 3500.0f;
+	}
+ 	else
+	{
+		//DOT-DD (Moonfire-Immolate-IceLance-Pyroblast)(Hack Fix)
+		float td = float( GetDuration( dbcSpellDuration.LookupEntry( spellInfo->DurationIndex )  ));
+		if( spellInfo->NameHash == SPELL_HASH_MOONFIRE || spellInfo->NameHash == SPELL_HASH_IMMOLATE || spellInfo->NameHash == SPELL_HASH_ICE_LANCE || spellInfo->NameHash == SPELL_HASH_PYROBLAST )
+			dmgdoneaffectperc *= float( 1.0f - ( ( td / 15000.0f ) / ( ( td / 15000.0f ) + dmgdoneaffectperc ) ) );
+	}
 	//------------------------------by downranking----------------------------------------------
-	//DOT-DD (Moonfire-Immolate-IceLance-Pyroblast)(Hack Fix)
-
-	float td = float( GetDuration( dbcSpellDuration.LookupEntry( spellInfo->DurationIndex )  ));
-	if( spellInfo->NameHash == SPELL_HASH_MOONFIRE || spellInfo->NameHash == SPELL_HASH_IMMOLATE || spellInfo->NameHash == SPELL_HASH_ICE_LANCE || spellInfo->NameHash == SPELL_HASH_PYROBLAST )
-		dmgdoneaffectperc *= float( 1.0f - ( ( td / 15000.0f ) / ( ( td / 15000.0f ) + dmgdoneaffectperc ) ) );
-
 	if(spellInfo->baseLevel > 0 && spellInfo->maxLevel > 0)
 	{
 		float downrank1 = 1.0f;
@@ -4276,6 +4546,9 @@
 		}break;
 	case CHAT_MSG_MONSTER_YELL:
 		{
+			if ( m_mapMgr == NULL )
+				return;
+
 			uint32 cell_radius = 2;
 			uint32 cellX = m_mapMgr->GetPosX(GetPositionX());
 			uint32 cellY = m_mapMgr->GetPosY(GetPositionY());
@@ -4314,8 +4587,31 @@
 					}
 				}
 			}
+		}break;
+	case CHAT_MSG_MONSTER_EMOTE:
+		{
+			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
+			{
+				if((*i)->GetTypeId() == TYPEID_PLAYER)
+				{
+					std::stringstream szMessage;
+					szMessage << UnitName << msg;
 
-
+					WorldPacket data(SMSG_MESSAGECHAT, 35 + UnitNameLength + MessageLength);
+					data << type;
+					data << lang;
+					data << GetGUID();
+					data << uint32(0);			// new in 2.1.0
+					data << uint32(UnitNameLength);
+					data << UnitName;
+					data << ((Player*)(*i))->GetGUID();
+					data << uint32(strlen(szMessage.str().c_str())+1);
+					data << szMessage.str().c_str();
+					data << uint8(0x00);
+					WorldSession *session = ((Player*)(*i))->GetSession();
+					session->SendPacket(&data);
+				}
+			}
 		}break;
 	case CHAT_MSG_CHANNEL:
 		{
@@ -4340,6 +4636,31 @@
 				}
 			}
 		}break;
+	case CHAT_MSG_RAID_BOSS_EMOTE:
+		{
+			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
+			{
+				if((*i)->GetTypeId() == TYPEID_PLAYER)
+				{
+					std::stringstream szMessage;
+					szMessage << UnitName << msg;
+
+					WorldPacket data(SMSG_MESSAGECHAT, 35 + UnitNameLength + MessageLength);
+					data << type;
+					data << lang;
+					data << GetGUID();
+					data << uint32(0);			// new in 2.1.0
+					data << uint32(UnitNameLength);
+					data << UnitName;
+					data << ((Player*)(*i))->GetGUID();
+					data << uint32(strlen(szMessage.str().c_str())+1);
+					data << szMessage.str().c_str();
+					data << uint8(0x00);
+					WorldSession *session = ((Player*)(*i))->GetSession();
+					session->SendPacket(&data);
+				}
+			}
+		}break;
 	}
 }
 
