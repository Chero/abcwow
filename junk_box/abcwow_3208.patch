Index: src/game/AreaTrigger.cpp
===================================================================
--- src/game/AreaTrigger.cpp	(revision 3208)
+++ src/game/AreaTrigger.cpp	(working copy)
@@ -115,6 +115,9 @@
 {		
 	sLog.outDebug("AreaTrigger: %u", id);
 
+	if (_player->GetSession()->CanUseCommand('z') && pAreaTrigger)
+		sChatHandler.BlueSystemMessage(this, "[%sSystem%s] |rEntered areatrigger: %s%u (%s).", MSG_COLOR_WHITE, MSG_COLOR_LIGHTBLUE, MSG_COLOR_SUBWHITE, id, pAreaTrigger->Name);
+
 	// Are we REALLY here?
 	if( !_player->IsInWorld() )
 		return;
@@ -136,6 +139,8 @@
 		_player->m_bg->HookOnAreaTrigger(_player, id);
 		return;
 	}
+	// Hook for Scripted Areatriggers
+	_player->GetMapMgr()->HookOnAreaTrigger(_player, id);
 
 	switch(pAreaTrigger->Type)
 	{
Index: src/game/BattlegroundMgr.cpp
===================================================================
--- src/game/BattlegroundMgr.cpp	(revision 3208)
+++ src/game/BattlegroundMgr.cpp	(working copy)
@@ -252,6 +252,7 @@
 						tempPlayerVec[0].pop_front();
 						arena->AddPlayer(plr, team);
 						ErasePlayerFromList(plr->GetGUIDLow(), &m_queuedPlayers[i][j]);
+						team = arena->GetFreeTeam();
 					}
 				}
 				else
@@ -385,15 +386,14 @@
 
 			Arena * ar = ((Arena*)CreateInstance(i,LEVEL_GROUP_70));
 			GroupMembersSet::iterator itx;
-			int32 team;
 			ar->rated_match=true;
 
 			for(itx = group1->GetSubGroup(0)->GetGroupMembersBegin(); itx != group1->GetSubGroup(0)->GetGroupMembersEnd(); ++itx)
 			{
 				if((*itx)->m_loggedInPlayer)
 				{
-					if( (team = ar->GetFreeTeam()) != -1 )
-                        ar->AddPlayer((*itx)->m_loggedInPlayer, team);
+					if( ar->HasFreeSlots(0) )
+                        ar->AddPlayer((*itx)->m_loggedInPlayer, 0);
 				}
 			}
 
@@ -401,8 +401,8 @@
 			{
 				if((*itx)->m_loggedInPlayer)
 				{
-					if( (team = ar->GetFreeTeam()) != -1 )
-						ar->AddPlayer((*itx)->m_loggedInPlayer, team);
+					if( ar->HasFreeSlots(1) )
+						ar->AddPlayer((*itx)->m_loggedInPlayer, 1);
 				}
 			}
 		}
Index: src/game/CharacterHandler.cpp
===================================================================
--- src/game/CharacterHandler.cpp	(revision 3208)
+++ src/game/CharacterHandler.cpp	(working copy)
@@ -331,7 +331,7 @@
 
 	//Same Faction limitation only applies to PVP and RPPVP realms :)
 	uint32 realmType = sLogonCommHandler.GetRealmType();
-	if( !HasGMPermissions() && realmType == REALM_PVP && _side < 0 )
+	if(!HasGMPermissions() && (realmType==REALMTYPE_PVP||realmType==REALMTYPE_RPPVP) && sWorld.PvpFactionLimitation)
 	{
 		if( ((pNewChar->GetTeam()== 0) && (_side == 1)) || ((pNewChar->GetTeam()== 1) && (_side == 0)) )
 		{
Index: src/game/Chat.h
===================================================================
--- src/game/Chat.h	(revision 3208)
+++ src/game/Chat.h	(working copy)
@@ -43,8 +43,7 @@
 	CHAT_MSG_SYSTEM									= 0x0A,
 	CHAT_MSG_MONSTER_SAY							= 0x0B,
 	CHAT_MSG_MONSTER_YELL							= 0x0C,
-    CHAT_MSG_MONSTER_WHISPER                        = 0x0D,
-	//CHAT_MSG_MONSTER_EMOTE							= 0x0E,
+	CHAT_MSG_MONSTER_EMOTE							= 0x0D,
 	CHAT_MSG_CHANNEL								= 0x0E,
 	CHAT_MSG_CHANNEL_JOIN							= 0x10,
 	CHAT_MSG_CHANNEL_LEAVE							= 0x11,
@@ -56,10 +55,12 @@
 	CHAT_MSG_COMBAT_LOG								= 0x17,
 	CHAT_MSG_IGNORED								= 0x18,
 	CHAT_MSG_SKILL									= 0x19,
+	CHAT_MSG_MONSTER_WHISPER						= 0x1A,
 	CHAT_MSG_LOOT									= 0x20,
 	CHAT_MSG_BATTLEGROUND_EVENT						= 0x53,
 	CHAT_MSG_RAIDLEADER								= 0x57,
 	CHAT_MSG_RAIDWARNING							= 0x58,
+	CHAT_MSG_RAID_BOSS_EMOTE						= 0x5A,
     CHAT_MSG_MONEY,                                 // value is guessed...
 };
 
Index: src/game/DayWatcherThread.cpp
===================================================================
--- src/game/DayWatcherThread.cpp	(revision 3208)
+++ src/game/DayWatcherThread.cpp	(working copy)
@@ -197,6 +197,7 @@
 	Player * plr;
 	uint32 guid, arenapoints, orig_arenapoints;
 	ArenaTeam * team;
+	uint32 arenapointsPerTeam[3] = {0};
 	double X, Y;
 	if(result)
 	{
@@ -207,6 +208,9 @@
 			arenapoints = f[1].GetUInt32();
 			orig_arenapoints = arenapoints;
 
+			for(uint32 i = 0; i < 3; ++i)
+				arenapointsPerTeam[i] = 0;
+
 			/* are we in any arena teams? */
 			for(uint32 i = 0; i < 3; ++i)			// 3 arena team types
 			{
@@ -265,10 +269,13 @@
 					}
 					
 					if(Y > 1.0)
-						arenapoints += long2int32(double(ceil(Y)));
+						arenapointsPerTeam[i] += long2int32(double(ceil(Y)));
 				}
 			}
 
+			arenapointsPerTeam[0] = max(arenapointsPerTeam[0],arenapointsPerTeam[1]);
+			arenapoints += max(arenapointsPerTeam[0],arenapointsPerTeam[2]);
+
 			if(orig_arenapoints != arenapoints)
 			{
 				plr = objmgr.GetPlayer(guid);
Index: src/game/LootMgr.cpp
===================================================================
--- src/game/LootMgr.cpp	(revision 3208)
+++ src/game/LootMgr.cpp	(working copy)
@@ -104,6 +104,7 @@
 	LoadLootTables("fishingloot",&FishingLoot);
 	LoadLootTables("itemloot", &ItemLoot);
 	LoadLootTables("prospectingloot", &ProspectingLoot);
+	LoadLootTables("disenchantingloot", &DisenchantingLoot);
 	LoadLootTables("pickpocketingloot", &PickpocketingLoot);
 	is_loading = false;
 }
@@ -213,25 +214,28 @@
 {
   sLog.outString("  Deleting Loot Tables...");
   for(LootStore::iterator iter=CreatureLoot.begin(); iter != CreatureLoot.end(); ++iter)
-  delete [] iter->second.items;
+	delete [] iter->second.items;
 
   for(LootStore::iterator iter=FishingLoot.begin(); iter != FishingLoot.end(); ++iter)
-  delete [] iter->second.items;
+	delete [] iter->second.items;
 
   for(LootStore::iterator iter=SkinningLoot.begin(); iter != SkinningLoot.end(); ++iter)
-  delete [] iter->second.items;
+	delete [] iter->second.items;
 
   for(LootStore::iterator iter=GOLoot.begin(); iter != GOLoot.end(); ++iter)
-  delete [] iter->second.items;
+	delete [] iter->second.items;
 
   for(LootStore::iterator iter=ItemLoot.begin(); iter != ItemLoot.end(); ++iter)
 	  delete [] iter->second.items;
 
   for(LootStore::iterator iter=ProspectingLoot.begin(); iter != ProspectingLoot.end(); ++iter)
-  delete [] iter->second.items;
+	delete [] iter->second.items;
 
- for(LootStore::iterator iter=PickpocketingLoot.begin(); iter != PickpocketingLoot.end(); ++iter)
- delete [] iter->second.items;
+  for(LootStore::iterator iter=DisenchantingLoot.begin(); iter != DisenchantingLoot.end(); ++iter)
+	delete [] iter->second.items;
+
+  for(LootStore::iterator iter=PickpocketingLoot.begin(); iter != PickpocketingLoot.end(); ++iter)
+	delete [] iter->second.items;
 }
 
 void LootMgr::LoadLootTables(const char * szTableName,LootStore * LootTable)
@@ -465,7 +469,7 @@
 
 void LootMgr::FillCreatureLoot(Loot * loot,uint32 loot_id, bool heroic)
 {
-	loot->items.clear ();
+	loot->items.clear();
 	loot->gold =0;
 	
 	LootStore::iterator tab =CreatureLoot.find(loot_id);
Index: src/game/LootMgr.h
===================================================================
--- src/game/LootMgr.h	(revision 3208)
+++ src/game/LootMgr.h	(working copy)
@@ -146,7 +146,8 @@
 	LootStore	GOLoot;
 	LootStore	ItemLoot;
 	LootStore	ProspectingLoot;
-	LootStore PickpocketingLoot;
+	LootStore	DisenchantingLoot;
+	LootStore	PickpocketingLoot;
 	std::map<uint32, std::set<uint32> > quest_loot_go;
 
 	RandomProps * GetRandomProperties(ItemPrototype * proto);
Index: src/game/MapMgr.cpp
===================================================================
--- src/game/MapMgr.cpp	(revision 3208)
+++ src/game/MapMgr.cpp	(working copy)
@@ -1735,3 +1735,24 @@
 	GameObjectSqlIdMap::iterator itr = _sqlids_gameobjects.find(sqlid);
 	return (itr == _sqlids_gameobjects.end()) ? NULL : itr->second;
 }
+
+void MapMgr::HookOnAreaTrigger(Player * plr, uint32 id)
+{
+	switch (id)
+	{
+	case 4591:
+		//Only opens when the first one steps in, if 669 if you find a way, put it in :P (else was used to increase the time the door stays opened when another one steps on it)
+		GameObject *door = GetInterface()->GetGameObjectNearestCoords(803.827f, 6869.38f, -38.5434f, 184212);
+		if (door && (door->GetUInt32Value(GAMEOBJECT_STATE) == 1))
+		{
+			door->SetUInt32Value(GAMEOBJECT_STATE, 0);
+			//sEventMgr.AddEvent(door, &GameObject::SetUInt32Value, GAMEOBJECT_STATE, 1, EVENT_SCRIPT_UPDATE_EVENT, 10000, 1, 0);
+		}
+		//else
+		//{
+			//sEventMgr.RemoveEvents(door);
+			//sEventMgr.AddEvent(door, &GameObject::SetUInt32Value,GAMEOBJECT_STATE, 0, EVENT_SCRIPT_UPDATE_EVENT, 10000, 1, 0);
+		//}
+		break;
+	}
+}
Index: src/game/MapMgr.h
===================================================================
--- src/game/MapMgr.h	(revision 3208)
+++ src/game/MapMgr.h	(working copy)
@@ -276,6 +276,7 @@
 
 	Instance * pInstance;
 	void BeginInstanceExpireCountdown();
+	void HookOnAreaTrigger(Player * plr, uint32 id);
 	
 	// better hope to clear any references to us when calling this :P
 	void InstanceShutdown()
Index: src/game/MovementHandler.cpp
===================================================================
--- src/game/MovementHandler.cpp	(revision 3208)
+++ src/game/MovementHandler.cpp	(working copy)
@@ -600,7 +600,7 @@
 
 				//sLog.outDebug( "3 Speedhacker DD(%g) DX(%g) DY(%g) S(%g) TS(%u)", distance_delta, delta_x, delta_y, speed, time_diff );
 
-				if( distance_delta > 16.0f )
+				if( !HasGMPermissions() && distance_delta > 16.0f )
 				{
 					switch ( _player->m_speedhackChances )
 					{
Index: src/game/Object.cpp
===================================================================
--- src/game/Object.cpp	(revision 3208)
+++ src/game/Object.cpp	(working copy)
@@ -2176,7 +2176,7 @@
 	{
 		Unit* caster = static_cast< Unit* >( this );
 		caster->RemoveAurasByInterruptFlag( AURA_INTERRUPT_ON_START_ATTACK );
-		res += caster->GetSpellDmgBonus( pVictim, spellInfo, ( int )res );
+		res += caster->GetSpellDmgBonus( pVictim, spellInfo, ( int )res ,0);
 //==========================================================================================
 //==============================Post +SpellDamage Bonus Modifications=======================
 //==========================================================================================
@@ -2255,34 +2255,34 @@
 		abs_dmg += ms_abs_dmg;
 	}
 
+	if(ress < 0) ress = 0;
+
 	res=(float)ress;
 	dealdamage dmg;
 	dmg.school_type = school;
 	dmg.full_damage = ress;
 	dmg.resisted_damage = 0;
 	
-	// can't resist if theres no damage.abs_dmg
-	if(res <= 0)
+	if(res <= 0) 
+		dmg.resisted_damage = dmg.full_damage;
+
+	//------------------------------resistance reducing-----------------------------------------	
+	if(res > 0 && this->IsUnit())
 	{
-		dmg.resisted_damage = dmg.full_damage = 1;
-	//------------------------------resistance reducing-----------------------------------------	
-		if(this->IsUnit())
-		{
-			static_cast<Unit*>(this)->CalculateResistanceReduction(pVictim,&dmg);
-			if((int32)dmg.resisted_damage > dmg.full_damage)
-				res = 0;
-			else
-                res = float(dmg.full_damage - dmg.resisted_damage);
-		}
+		static_cast<Unit*>(this)->CalculateResistanceReduction(pVictim,&dmg);
+		if((int32)dmg.resisted_damage > dmg.full_damage)
+			res = 0;
+		else
+            res = float(dmg.full_damage - dmg.resisted_damage);
+	}
 	//------------------------------special states----------------------------------------------
-		if(pVictim->GetTypeId() == TYPEID_PLAYER && static_cast<Player*>(pVictim)->GodModeCheat == true)
-		{
-			res = float(dmg.full_damage);
-			dmg.resisted_damage = dmg.full_damage;
-		}
+	if(pVictim->GetTypeId() == TYPEID_PLAYER && static_cast<Player*>(pVictim)->GodModeCheat == true)
+	{
+		res = float(dmg.full_damage);
+		dmg.resisted_damage = dmg.full_damage;
 	}
 	//DK:FIXME->SplitDamage
-	
+
 //==========================================================================================
 //==============================Data Sending ProcHandling===================================
 //==========================================================================================
Index: src/game/ObjectMgr.cpp
===================================================================
--- src/game/ObjectMgr.cpp	(revision 3208)
+++ src/game/ObjectMgr.cpp	(working copy)
@@ -1846,6 +1846,32 @@
 	} while(result->NextRow());
 	delete result;
 	Log.Notice("ObjectMgr", "%u spell fixes loaded.", fixed_count);
+
+	/*##########################################################################################*/
+
+	// Loads data from spell_data_extra table
+	QueryResult * result1 = WorldDatabase.Query("SELECT * FROM spell_data_extra");
+	if(result1 == 0) return;
+
+	uint32 override_count = 0;
+	do
+	{
+		Field * fields1 = result1->Fetch();
+		uint32 spell_id = fields1[0].GetUInt32();
+		SpellEntry * sp = dbcSpell.LookupEntry(spell_id);
+		if(sp == 0) 
+			continue;
+
+		if(sp->dmg_bonus == 0)
+		{
+			sp->dmg_bonus = fields1[1].GetUInt32();
+			override_count++;
+		}
+
+	} while (result1->NextRow());
+
+	delete result1;
+	Log.Notice("ObjectMgr", "%u spell data extra loaded.", override_count);
 }
 
 void ObjectMgr::LoadSpellOverride()
Index: src/game/ObjectMgr.h
===================================================================
--- src/game/ObjectMgr.h	(revision 3208)
+++ src/game/ObjectMgr.h	(working copy)
@@ -189,11 +189,11 @@
 #define MAX_PREDEFINED_NEXTLEVELXP 70
 static const uint32 NextLevelXp[MAX_PREDEFINED_NEXTLEVELXP]= {
 	400,	900,	1400,	2100,	2800,	3600,	4500,	5400,	6500,	7600,
-	8800,	10100,	11400,	12900,	14400,	16000,	17700,	19400,	21300,	23200,
-	25200,	27300,	29400,	31700,	34000,	36400,	38900,	41400,	44300,	47400,
-	50800,	54500,	58600,	62800,	67100,	71600,	76100,	80800,	85700,	90700,
-	95800,	101000,	106300,	111800,	117500,	123200,	129100,	135100,	141200,	147500,
-	153900,	160400,	167100,	173900,	180800,	187900,	195000,	202300,	209800,	494000,
+	8700,	9800,	11000,	12300,	13600,	15000,	16400,	17800,	19300,	20800,
+	22400,	24000,	25500,	27200,	28900,	30500,	32200,	33900,	36300,	38800,
+	41600,	44600,	48000,	51400,	55000,	58700,	62400,	66200,	70200,	74300,
+	78500,	82800,	87100,	91600,	95300,	101000,	105800,	110700,	115700,	120900,
+	126100,	131500,	137000,	142500,	148200,	154000,	159900,	165800,	172000,	494000,
 	574700,	614400,	650300,	682300,	710200,	734100,	753700,	768900,	779700,	800100};
 
 class SERVER_DECL GossipMenu
Index: src/game/Professions.cpp
===================================================================
--- src/game/Professions.cpp	(revision 3208)
+++ src/game/Professions.cpp	(working copy)
@@ -39,150 +39,80 @@
 	return 0;
 }
 
-void AddItemFromDisenchant(ItemPrototype *proto,Player*owner)
+void AddItemFromDisenchant(uint32 loot_id, Player *owner)
 {
-	uint32 count = 0,item = 0;
-	uint32 l=proto->ItemLevel;
-	if(proto->Quality ==4 && l>=51)
+	LootStore::iterator tab =lootmgr.DisenchantingLoot.find(loot_id);
+	if( lootmgr.DisenchantingLoot.end()==tab)
+		return;
+
+	StoreLootList *list = &(tab->second);
+
+	uint32 count;
+	for( uint32 x = 0; x < list->count; x++ )
 	{
-		count=1;
-		if (l<61) item=20725;
-		else item=22450;
-	}
-	else
-	{
-		if(proto->Quality ==2)//green -> dust for armor, essence for weapon
+		if( list->items[x].item.itemproto )
 		{
-			if(proto->Class==4)//armor->dust
+			float chance = list->items[x].chance;
+			if(chance == 0.0f) continue;
+			
+			ItemPrototype *itemproto = list->items[x].item.itemproto;
+			if(Rand(chance))
 			{
-				if(l<=20)item=10940;
-				else if(l<=30)item=11083;
-				else if(l<=40)item=11137;
-				else if(l<=50)item=11176;
-				else if(l<=60)item=16204;
-				else item=22445;
+				if( list->items[x].mincount == list->items[x].maxcount )
+					count = list->items[x].maxcount;
+				else
+					count = RandomUInt(list->items[x].maxcount - list->items[x].mincount) + list->items[x].mincount;
+
+				Item *add;
+				SlotResult slotresult;
+				add = owner->GetItemInterface()->FindItemLessMax(list->items[x].item.itemproto->ItemId, count, false);
+				if (!add)
+				{
+					slotresult = owner->GetItemInterface()->FindFreeInventorySlot(itemproto);
+					if(!slotresult.Result)
+					{
+						owner->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
+						return;
+					}
+					Item * it=objmgr.CreateItem(list->items[x].item.itemproto->ItemId,owner);  
+					it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
+					owner->GetItemInterface()->SafeAddItem(it,slotresult.ContainerSlot, slotresult.Slot);
+				}
+				else
+				{
+					add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + count);
+					add->m_isDirty = true;
+				}
 			}
-			else
-			{
-				if(l<=10)item=10938;
-				else if(l<=15)item=10939;
-				else if(l<=20)item=10998;
-				else if(l<=25)item=11082;
-				else if(l<=30)item=11134;
-				else if(l<=35)item=11135;
-				else if(l<=40)item=11174;
-				else if(l<=45)item=11175;
-				else if(l<=50)item=16202;
-				else if(l<=60)item=16203;
-				else if(l<=66) item=22447;
-				else item=22446;
-			
-			}
-			count =1+rand()%3; 
 		}
-		else if(proto->Quality >=3)//blue -> shards
-		{
-				if(l<=20)item=10978;
-				else if(l<=25)item=11084;
-				else if(l<=30)item=11138;
-				else if(l<=35)item=11139;
-				else if(l<=40)item=11177;
-				else if(l<=45)item=11178;
-				else if(l<=50)item=14343;
-				else if(l<=60)item=14344;
-				else if(l<=65)item=22448;
-				else item=22449;
-		
-			count = proto->Quality-2+rand()%3;
-		}
 	}
-	Item *add;
-	SlotResult slotresult;
-	add = owner->GetItemInterface()->FindItemLessMax(item, count, false);
-	if (!add)
-	{
-		slotresult = owner->GetItemInterface()->FindFreeInventorySlot(proto);
-		if(!slotresult.Result)
-		{
-			owner->GetItemInterface()->BuildInventoryChangeError(NULL, NULL, INV_ERR_INVENTORY_FULL);
-			return;
-		}
-		Item * it=objmgr.CreateItem(item,owner);  
-		it->SetUInt32Value( ITEM_FIELD_STACK_COUNT, count);
-		owner->GetItemInterface()->SafeAddItem(it,slotresult.ContainerSlot, slotresult.Slot);
-	}
-	else
-	{
-		add->SetCount(add->GetUInt32Value(ITEM_FIELD_STACK_COUNT) + count);
-		add->m_isDirty = true;
-	}
 }
 
-/*
-Dusts usually are extracted from armors, but also occasionally found from weapons. 
 
-Strange Dust - Disenchanted from level 1 to 20 items [10940]
-Soul Dust - Disenchanted from level 21 to 30 items [11083]
-Vision Dust - Disenchanted from level 31 to 40 items [11137]
-Dream Dust - Disenchanted from level 41 to 50 items [11176]
-Illusion Dust - Disenchanted from level 51 to 60 items [16204]
-
-
-Essences usually are extracted from weapons, but also occasionally found from armors. 
-
-Lesser Magic Essence - Disenchanted from level 1 to 10 items [10938]
-Greater Magic Essence - Disenchanted from level 11 to 15 items [10939]
-Lesser Astral Essence - Disenchanted from level 16 to 20 items [10998]
-Greater Astral Essence - Disenchanted from level 21 to 25 items [11082]
-Lesser Mystic Essence - Disenchanted from level 26 to 30 items [11134]
-Greater Mystic Essence - Disenchanted from level 31 to 35 items [11135]
-Lesser Nether Essence - Disenchanted from level 36 to 40 items [11174]
-Greater Nether Essence - Disenchanted from level 41 to 45 items [11175]
-Lesser Eternal Essence - Disenchanted from level 46 to 50 items [16202]
-Greater Eternal Essence - Disenchanted from level 51 to 60 items [16203]
-
-
-Shards are normally disenchanted from blue or better items, but have a small chance of coming from green items. 
-
-Small Glimmering Shard - Disenchanted from level 1 to 20 items [10978]
-Large Glimmering Shard - Disenchanted from level 21 to 25 items [11084]
-Small Glowing Shard - Disenchanted from level 26 to 30 items [11138]
-Large Glowing Shard - Disenchanted from level 31 to 35 items [11139]
-Small Radiant Shard - Disenchanted from level 36 to 40 items [11177]
-Large Radiant Shard - Disenchanted from level 41 to 45 items [11178]
-Small Brilliant Shard - Disenchanted from level 46 to 50 items [14343]
-Large Brilliant Shard - Disenchanted from level 51 to 60 items [14344]
-
-Nexus Crystals are obtained by disenchanting Epic (purple) items, and sometimes come from Rare (blue) items also. 
-
-Nexus Crystal - Disenchanted from level 51-60 items [20725]
-*/
-
-void AddItemFromProspecting(uint32 loot_id,Player*owner)
+void AddItemFromProspecting(uint32 loot_id, Player *owner)
 {
 	LootStore::iterator tab =lootmgr.ProspectingLoot.find(loot_id);
 	if( lootmgr.ProspectingLoot.end()==tab)
 		return;
-	StoreLootList *list=&(tab->second);
 
-	for(uint32 x =0,pass=0; x<list->count; x++,pass++)
+	StoreLootList *list = &(tab->second);
+
+	uint32 count;
+	for( uint32 x = 0; x < list->count; x++ )
 	{
-		if(list->items[x].item.itemproto)// this check is needed until loot DB is fixed
+		if( list->items[x].item.itemproto )
 		{
-			if(Rand(list->items[x].chance)) 
-		    {
-				ItemPrototype *itemproto = list->items[x].item.itemproto;
-				if(!itemproto)
-					return;
-				uint32 count = 1;
-				if(list->count != (x - 1))
-				{
-					for(uint32 z = (x + 1); z < list->count; z++)
-						if(itemproto->MaxCount && (count == itemproto->MaxCount))
-							break;
-						else if(list->items[x].item.itemproto == list->items[z].item.itemproto && Rand(list->items[x].chance))
-							count++;
-				}
+			float chance = list->items[x].chance;
+			if(chance == 0.0f) continue;
+			
+			ItemPrototype *itemproto = list->items[x].item.itemproto;
+			if(Rand(chance))
+			{
+				if( list->items[x].mincount == list->items[x].maxcount )
+					count = list->items[x].maxcount;
+				else
+					count = RandomUInt(list->items[x].maxcount - list->items[x].mincount) + list->items[x].mincount;
+
 				Item *add;
 				SlotResult slotresult;
 				add = owner->GetItemInterface()->FindItemLessMax(list->items[x].item.itemproto->ItemId, count, false);
@@ -205,5 +135,5 @@
 				}
 			}
 		}
- 	}
+	}
 }
Index: src/game/Professions.h
===================================================================
--- src/game/Professions.h	(revision 3208)
+++ src/game/Professions.h	(working copy)
@@ -22,7 +22,7 @@
 
 uint32 GetGOReqSkill(GameObject * gameObjTarget);
 void UseFishing(Player *player);
-void AddItemFromDisenchant(ItemPrototype *proto,Player*owner);
-void AddItemFromProspecting(uint32 loot_id,Player*owner);
+void AddItemFromDisenchant(uint32 loot_id, Player *owner);
+void AddItemFromProspecting(uint32 loot_id, Player *owner);
 
 #endif
Index: src/game/SocialMgr.cpp
===================================================================
--- src/game/SocialMgr.cpp	(revision 3208)
+++ src/game/SocialMgr.cpp	(working copy)
@@ -165,9 +165,9 @@
 		plr->GetSession()->SendPacket( &data );
 		return;
 	}
-	if( friendInfo->team != playerInfo->team )
+	if( friendInfo->team != playerInfo->team && sWorld.FriendFactionLimitation )
 	{
-		sLog.outDebug("SocialMgr: %s tried to add an ennemy to his friendlist", plr->GetName());
+		sLog.outDebug("SocialMgr: %s tried to add an enemy to his friendlist", plr->GetName());
 		data << (uint8)FRIEND_ENEMY << (uint64)friendInfo->guid;
 		plr->GetSession()->SendPacket( &data );
 		return;
@@ -244,7 +244,7 @@
 
 	if( pGuid == iGuid )
 	{
-		sLog.outDebug("SocialMgr: %s tried to add himself to his friendlist", plr->GetName());
+		sLog.outDebug("SocialMgr: %s tried to add himself to his ignorelist", plr->GetName());
 		data << (uint8)FRIEND_IGNORE_SELF << (uint64)iGuid;
 		plr->GetSession()->SendPacket(&data);
 		return;
Index: src/game/Spell.cpp
===================================================================
--- src/game/Spell.cpp	(revision 3208)
+++ src/game/Spell.cpp	(working copy)
@@ -2440,7 +2440,7 @@
 		spellid = 11196;
 	else if( m_spellInfo->MechanicsType == 19 && m_spellInfo->Id != 6788) // Cast spell Weakened Soul
 		spellid = 6788;
-	else if( m_spellInfo->Id == 11958) // Cast spell Hypothermia
+	else if( m_spellInfo->Id == 45438) // Cast spell Hypothermia
 		spellid = 41425;
 	else if( m_spellInfo->Id == 30451) // Cast spell Arcane Blast
 		spellid = 36032;
@@ -2599,6 +2599,7 @@
 			}
 		}
 
+		/*
 		// check for duel areas
 		if(p_caster && m_spellInfo->Id == 7266)
 		{
@@ -2606,7 +2607,7 @@
 			if(at->AreaFlags & AREA_CITY_AREA)
 				return SPELL_FAILED_NO_DUELING;
 		}
-
+		*/
 		// check if spell is allowed while player is on a taxi
 		if(p_caster->m_onTaxi)
 		{
@@ -3239,7 +3240,16 @@
 				}
 			}	*/		
 		}
-	}	
+	}
+	//Checking for Debuffs that dont allow power word:shield, those Pala spells, ice block or use first aid, hacky, is there any was to check if he has "immune mechanic"?
+	if (m_spellInfo->NameHash == SPELL_HASH_POWER_WORD__SHIELD && (target) ? target->HasAura(6788) : u_caster->HasAura(6766)) //Weakened Soul
+		return SPELL_FAILED_DAMAGE_IMMUNE;
+	if (((m_spellInfo->NameHash == SPELL_HASH_DIVINE_SHIELD) || (m_spellInfo->NameHash == SPELL_HASH_DIVINE_PROTECTION) || (m_spellInfo->NameHash == SPELL_HASH_BLESSING_OF_PROTECTION) || (m_spellInfo->NameHash == SPELL_HASH_AVENGING_WRATH)) && (target) ? target->HasAura(25771) : u_caster->HasAura(25771)) //Forbearance
+		return SPELL_FAILED_DAMAGE_IMMUNE;
+	if (m_spellInfo->NameHash == SPELL_HASH_ICE_BLOCK && u_caster->HasAura(41425))
+		return SPELL_FAILED_DAMAGE_IMMUNE;
+	if (m_spellInfo->NameHash == SPELL_HASH_FIRST_AID && (target) ? target->HasAura(11196) : u_caster->HasAura(11196))
+		return SPELL_FAILED_DAMAGE_IMMUNE;
 
 	// Special State Checks (for creatures & players)
 	if( u_caster )
@@ -3874,16 +3884,23 @@
 	float healdoneaffectperc = 0;
 	if( u_caster != NULL )
 	{
-		SpellCastTime *sd = dbcSpellCastTime.LookupEntry(m_spellInfo->CastingTimeIndex);
+		if(!m_spellInfo->dmg_bonus)
+		{
+			SpellCastTime *sd = dbcSpellCastTime.LookupEntry(m_spellInfo->CastingTimeIndex);
 
-		// affect the plus damage by duration
-		float castaff = float(GetCastTime(sd));
-		if(castaff > 3500) 
-            castaff = 3500;
-		else if(castaff < 1500) 
-            castaff = 1500;
+			// affect the plus damage by duration
+			float castaff = float(GetCastTime(sd));
+			if(castaff > 3500) 
+				castaff = 3500;
+			else if(castaff < 1500) 
+				castaff = 1500;
 
-		healdoneaffectperc = castaff / 3500.0f;
+			healdoneaffectperc = castaff / 3500.0f;
+		}
+		else
+		{
+			healdoneaffectperc = m_spellInfo->dmg_bonus/100.0f;
+		}
 		
 		//Downranking
 		/*if( m_spellInfo->baseLevel > 0 && m_spellInfo->maxLevel > 0 && p_caster)
Index: src/game/SpellAuras.cpp
===================================================================
--- src/game/SpellAuras.cpp	(revision 3208)
+++ src/game/SpellAuras.cpp	(working copy)
@@ -1128,11 +1128,12 @@
 			{
 				if( GetSpellProto() && GetSpellProto()->NameHash == SPELL_HASH_IGNITE )  //static damage for Ignite. Need to be reworked when "static DoTs" will be implemented
 					bonus_damage=0;
-				else bonus_damage = (float)c->GetSpellDmgBonus(m_target,m_spellProto,amount);
+				else bonus_damage = (float)c->GetSpellDmgBonus(m_target,m_spellProto,amount,1);
 				float ticks= float((amp) ? GetDuration()/amp : 0);
 				float fbonus = float(bonus);
 				fbonus += (ticks) ? bonus_damage/ticks : 0;
-				fbonus *= float(GetDuration()) / 15000.0f;
+				if(!m_spellProto->ChannelInterruptFlags)
+					fbonus *= float(GetDuration()) / 15000.0f;
 				bonus = float2int32(fbonus);
 			}
 			else bonus = 0;
@@ -1160,29 +1161,36 @@
 		uint32 ress=(uint32)res;
 		uint32 abs_dmg = m_target->AbsorbDamage(school, &ress);
 		uint32 ms_abs_dmg= m_target->ManaShieldAbsorb(ress);
-		dealdamage dmg;
-		dmg.school_type = school;
-		dmg.full_damage = ress;
-		dmg.resisted_damage = 0;
 		if (ms_abs_dmg)
 		{
-			ress-=ms_abs_dmg;
+			if(ms_abs_dmg > ress)
+				ress = 0;
+			else
+				ress-=ms_abs_dmg;
+
 			abs_dmg += ms_abs_dmg;
 		}
 
+		if(ress < 0) ress = 0;
+		res=(float)ress;
+		dealdamage dmg;
+		dmg.school_type = school;
+		dmg.full_damage = ress;
+		dmg.resisted_damage = 0;
 		
-		if(c && m_spellProto->MechanicsType != MECHANIC_BLEEDING)
+		if(res <= 0) 
+			dmg.resisted_damage = dmg.full_damage;
+
+		if(res > 0 && c && m_spellProto->MechanicsType != MECHANIC_BLEEDING)
 		{
 			c->CalculateResistanceReduction(m_target,&dmg);
-			res = float(dmg.full_damage - dmg.resisted_damage);
+			if((int32)dmg.resisted_damage > dmg.full_damage)
+				res = 0;
+			else
+                res = float(dmg.full_damage - dmg.resisted_damage);
 		}
 
-		
-		//DO NOT USE SPELL NOTN MELE >...
-		//it calcs damage in wrong way
-		//it displays wrong log
-		//it may have crit
-		SendPeriodicAuraLog(m_casterGuid, m_target, GetSpellProto()->Id, school, float2int32(res), FLAG_PERIODIC_DAMAGE);
+		SendPeriodicAuraLog(m_casterGuid, m_target, GetSpellProto()->Id, school, float2int32(res), abs_dmg, dmg.resisted_damage, FLAG_PERIODIC_DAMAGE);
 
 		if(school == SHADOW_DAMAGE)
 		{
@@ -1266,12 +1274,297 @@
 
 	switch(GetSpellId())
 	{
+
+		case 32052: //custom
+		{
+			if (apply)
+			{
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "MUHAHAHA ...");
+
+				uint8 race, race_old, class_,gender,powertype/*,skin,face,hairStyle,hairColor,facialHair*/;
+				uint32 team = _ptarget->GetTeam();
+
+				race_old = race = _ptarget->getRace();
+				class_ = _ptarget->getClass();
+				gender = _ptarget->getGender();
+				powertype = _ptarget->GetPowerType();
+				
+				switch(class_)
+				{
+				case WARRIOR:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_ORC; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_TAUREN; break;
+							}
+						}else{
+							switch(RandomUInt(4))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_GNOME; break;
+								case 4: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case PALADIN:
+					{
+						if(!team) //a
+						{
+							race = RACE_BLOODELF;
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case HUNTER:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_ORC; break;
+								case 1: race = RACE_TAUREN; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_DWARF; break;
+								case 1: race = RACE_NIGHTELF; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case ROGUE:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_ORC; break;
+								case 2: race = RACE_TROLL; break;
+								case 3: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_GNOME; break;
+							}
+						}
+					}break;
+				case PRIEST:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_TROLL; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(3))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_DWARF; break;
+								case 2: race = RACE_NIGHTELF; break;
+								case 3: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case SHAMAN:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_ORC; break;
+								case 1: race = RACE_TAUREN; break;
+								case 2: race = RACE_TROLL; break;
+							}
+						}else race = RACE_DRAENEI;
+					}break;
+				case MAGE:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_UNDEAD; break;
+								case 1: race = RACE_TROLL; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_GNOME; break;
+								case 2: race = RACE_DRAENEI; break;
+							}
+						}
+					}break;
+				case WARLOCK:
+					{
+						if(!team) //a
+						{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_ORC ; break;
+								case 1: race = RACE_UNDEAD; break;
+								case 2: race = RACE_BLOODELF; break;
+							}
+						}else{
+							switch(RandomUInt(2))
+							{
+								case 0: race = RACE_HUMAN; break;
+								case 1: race = RACE_GNOME; break;
+							}
+						}
+					}break;
+				case DRUID:
+					{
+						switch(race)
+						{
+						case RACE_TAUREN: race = RACE_NIGHTELF; break;
+						case RACE_NIGHTELF: race = RACE_TAUREN; break;
+						}
+					}break;
+				}
+
+				_ptarget->SetTeam( team ? 0 : 1 );
+				PlayerCreateInfo *info = objmgr.GetPlayerCreateInfo(race, class_);
+				if (!info)
+					break;
+
+				_ptarget->SetFloatValue(OBJECT_FIELD_SCALE_X, ((race==RACE_TAUREN)?1.3f:1.0f));
+				_ptarget->SetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE, info->factiontemplate );	
+				_ptarget->SetUInt32Value(UNIT_FIELD_BYTES_0, ( ( race ) | ( class_ << 8 ) | ( gender << 16 ) | ( powertype << 24 ) ) );
+				if(race != RACE_BLOODELF)
+				{
+					_ptarget->SetUInt32Value(UNIT_FIELD_DISPLAYID, info->displayId + gender );
+					_ptarget->SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, info->displayId + gender );
+				}
+				else
+				{
+					_ptarget->SetUInt32Value(UNIT_FIELD_DISPLAYID, info->displayId - gender );
+					_ptarget->SetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID, info->displayId - gender );
+				}
+				// Different races have different number of visuals
+				_ptarget->SetUInt32Value(PLAYER_BYTES, ((RandomUInt(5))|(RandomUInt(5)<<8)|(RandomUInt(5)<<16)|(RandomUInt(5)<<24)));
+				_ptarget->SetUInt32Value(PLAYER_BYTES_2, (( !gender ? 0 : RandomUInt(3) ) | (0x02 << 24)));
+				//_ptarget->SetUInt32Value(PLAYER_BYTES, ((skin) | (face << 8) | (hairStyle << 16) | (hairColor << 24)));
+				//_ptarget->SetUInt32Value(PLAYER_BYTES_2, (facialHair | (0x02 << 24)));
+				
+				_ptarget->SetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, 0xEEEEEEEE);
+				//dump reputation data
+				ReputationMap m_tempRepMap;
+				//store neutral
+				for(uint32 i = 0; i < dbcFaction.GetNumRows(); ++i)
+				{
+					FactionDBC * f = dbcFaction.LookupRow(i);
+					if(f == 0) continue;
+					// dont store side related factions
+					if( _ptarget->GetStanding(f->ID) &&
+						f->parentFaction != 67 && f->parentFaction != 469 &&
+						f->parentFaction != 892 && f->parentFaction != 891 && 
+						f->ID != 947 && f->ID != 946 && //HH/thrallmar
+						f->ID != 892 && f->ID != 891 && //h/a Forces
+						f->ID != 941 && f->ID != 978 && //Mag'har / Kurenai
+						f->ID != 922 //Tranquillien
+						)
+					{
+						FactionReputation * rep = new FactionReputation;
+						rep->flag = 0;
+						rep->standing = _ptarget->GetStanding(f->ID);
+						rep->baseStanding = _ptarget->GetBaseStanding(f->ID);
+
+						m_tempRepMap[f->ID] = rep;
+					}
+				}
+				//add all starting fresh flashing
+				_ptarget->_InitialReputation();
+				//add/mod all stored
+				for(ReputationMap::iterator itr = m_tempRepMap.begin(); itr != m_tempRepMap.end(); ++itr)
+				{
+					_ptarget->SetStanding(itr->first, itr->second->standing );
+					//delete itr->second;
+				}
+
+				_ptarget->_RemoveLanguages();
+				
+				//remove racial spells along with all starting spells then add them for new race
+				PlayerCreateInfo * old_info = objmgr.GetPlayerCreateInfo(race_old, class_);
+				if (!old_info) break;
+
+				for(std::set<uint32>::iterator sp = old_info->spell_list.begin(); sp!=old_info->spell_list.end(); sp++)
+					if (_ptarget->HasSpell(*sp)) _ptarget->removeSpell((*sp), false, false, 0);
+
+				for(std::set<uint32>::iterator sp = info->spell_list.begin(); sp!=info->spell_list.end(); sp++)
+					_ptarget->addSpell(*sp);
+
+				//quit guild
+				if (_ptarget->GetGuildId())
+				{
+					Guild *pGuild = objmgr.GetGuild( _ptarget->GetGuildId() );
+
+					if(pGuild && pGuild->GetGuildLeader() != _ptarget->GetGUID() )
+					{
+						_ptarget->SetGuildId(0);
+						_ptarget->SetGuildRank(0);
+						pGuild->RemoveGuildMember(_ptarget->m_playerInfo, NULL);
+
+						WorldPacket data(100);
+						data.Initialize(SMSG_GUILD_EVENT);
+						data << uint8(GUILD_EVENT_LEFT);
+						data << uint8(1);
+						data << _ptarget->GetName();
+						pGuild->SendPacket(&data);
+					}
+				}
+
+				//arena team remove
+				for(uint32 i = 0; i < 3 ; i++)
+				{
+					ArenaTeam * team;
+					if( (team = _ptarget->m_arenaTeams[i]) != NULL )
+						team->RemoveMember(_ptarget->m_playerInfo);
+				}
+
+				_ptarget->SaveToDB(false);
+			}
+			else
+			{
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "Signed in blood. There is no going back now ...");
+				sChatHandler.SystemMessage(_ptarget->GetSession(), "Relog ...");
+				//force relog
+				_ptarget->Kick(5000);
+			}
+		}break;
+
 	//paladin - Blessing of Light.
 	case 19977:
 	case 19978:
 	case 19979:
 	case 27144:
 	case 32770:
+	case 27145:
+	case 25890:
 		{
 			if( mod->i == 0 )
 				SMTMod_On_target( apply, false, 0x9B56A8F5, mod->m_amount ); //holy light
@@ -2038,14 +2331,22 @@
 	}
 
 	int amp = m_spellProto->EffectAmplitude[mod->i];
-	if( amp > 0 ) 
+	if( !amp  ) 
 		amp = static_cast< EventableObject* >( this )->event_GetEventPeriod( EVENT_AURA_PERIODIC_HEAL );
 
 	if( GetDuration() )
 	{
-		int ticks = ( amp > 0 ) ? GetDuration() / amp : 0;
-		bonus = ( ticks > 0 ) ? bonus / ticks : 0;
-		bonus = float2int32( float( bonus * GetDuration() / 15000.0f ) );
+		int ticks = (amp > 0) ? GetDuration()/amp : 0;
+
+		if (!m_spellProto->dmg_bonus)
+		{
+			bonus = (ticks > 0) ? bonus/ticks : 0;
+			bonus = float2int32(float(bonus * GetDuration() / 15000.0f));
+		}
+		else
+		{
+			bonus = (ticks > 0) ? float2int32(float( (bonus*m_spellProto->dmg_bonus/100)/ticks )) : 0;
+		}
 	}
 	else
 		bonus = 0;
@@ -2566,7 +2867,7 @@
 	else
 		m_target->SetUInt32Value(UNIT_FIELD_HEALTH, m_target->GetUInt32Value(UNIT_FIELD_MAXHEALTH));
 
-	SendPeriodicAuraLog(m_casterGuid, m_target, m_spellProto->Id, m_spellProto->School, add, FLAG_PERIODIC_HEAL);
+	SendPeriodicAuraLog(m_casterGuid, m_target, m_spellProto->Id, m_spellProto->School, add, 0, 0, FLAG_PERIODIC_HEAL);
 
 	if(GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_ON_STAND_UP)
 	{
@@ -2823,7 +3124,7 @@
 	else
 		m_target->SetUInt32Value(POWER_TYPE,totalEnergy);
 	
-	SendPeriodicAuraLog( m_casterGuid, m_target, m_spellProto->Id, m_spellProto->School, amount, FLAG_PERIODIC_ENERGIZE);
+	SendPeriodicAuraLog( m_casterGuid, m_target, m_spellProto->Id, m_spellProto->School, amount, 0, 0, FLAG_PERIODIC_ENERGIZE);
 
 	if((GetSpellProto()->AuraInterruptFlags & AURA_INTERRUPT_ON_STAND_UP) && type == 0)
 	{
@@ -3846,9 +4147,72 @@
 		if(m_target->SchoolImmunityList[GetSpellProto()->School])
 			return;
 
-		//zack: latest new is that this spell uses spell damage bonus only and not healing bonus
-		amount += m_caster->GetSpellDmgBonus(m_target,GetSpellProto(),amount)*50/100;
-	
+		float bonus_damage;
+		int amp = m_spellProto->EffectAmplitude[mod->i];
+		if( !amp ) 
+			amp = static_cast< EventableObject* >( this )->event_GetEventPeriod( EVENT_AURA_PERIODIC_LEECH );
+
+		if(GetDuration())
+		{
+			bonus_damage = (float)m_caster->GetSpellDmgBonus(m_target,m_spellProto,amount,1);
+			float ticks= float((amp) ? GetDuration()/amp : 0);
+			bonus_damage = (ticks) ? bonus_damage/ticks : 0;
+			if(!m_spellProto->ChannelInterruptFlags)
+				bonus_damage *= GetDuration() / 15000.0f;
+		}
+		else bonus_damage = 0;
+
+		amount += float2int32(bonus_damage);
+
+		if(amount < 0)
+			amount = 0;
+		else
+		{
+			float summaryPCTmod = 1.0f;
+			if( m_target->IsPlayer() )//resilience
+			{
+				float dmg_reduction_pct = static_cast<Player*>(m_target)->CalcRating( PLAYER_RATING_MODIFIER_MELEE_CRIT_RESILIENCE ) / 100.0f;
+				if( dmg_reduction_pct > 1.0f )
+					dmg_reduction_pct = 1.0f;
+				summaryPCTmod -= dmg_reduction_pct;
+			}
+			amount = (uint32)(amount*summaryPCTmod);
+			if( amount < 0 ) 
+				amount = 0;
+		}
+
+		uint32 ress=(uint32)amount;
+		uint32 abs_dmg = m_target->AbsorbDamage(m_spellProto->School, &ress);
+		uint32 ms_abs_dmg= m_target->ManaShieldAbsorb(ress);
+		if (ms_abs_dmg)
+		{
+			if(ms_abs_dmg > ress)
+				ress = 0;
+			else
+				ress-=ms_abs_dmg;
+
+			abs_dmg += ms_abs_dmg;
+		}
+
+		if(ress < 0) ress = 0;
+		amount = ress;
+		dealdamage dmg;
+		dmg.school_type = m_spellProto->School;
+		dmg.full_damage = ress;
+		dmg.resisted_damage = 0;
+		
+		if(amount <= 0) 
+			dmg.resisted_damage = dmg.full_damage;
+
+		if(amount > 0)
+		{
+			m_caster->CalculateResistanceReduction(m_target,&dmg);
+			if((int32)dmg.resisted_damage > dmg.full_damage)
+				amount = 0;
+			else
+                amount = dmg.full_damage - dmg.resisted_damage;
+		}
+
 		uint32 Amount = min( amount, m_target->GetUInt32Value( UNIT_FIELD_HEALTH ) );
 		uint32 newHealth = m_caster->GetUInt32Value(UNIT_FIELD_HEALTH) + Amount ;
 		
@@ -3868,27 +4232,8 @@
 		data << uint32(Amount);
 		m_target->SendMessageToSet(&data,true);
 
-		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, Amount, FLAG_PERIODIC_LEECH);
-
-		//deal damage before we add healing bonus to damage
+		SendPeriodicAuraLog(m_target, m_caster, m_spellProto->Id, m_spellProto->School, Amount, abs_dmg, dmg.resisted_damage, FLAG_PERIODIC_LEECH);
 		m_target->DealDamage(m_target, Amount, 0, 0, GetSpellProto()->Id,true);
-
-		//add here bonus to healing taken. Maybe not all spells should receive it ?
-		/*
-		//zack : have no idea if we should use downranking here so i'm removing it until confirmed
-		float healdoneaffectperc = 1500 / 3500;
-		//Downranking
-		if(GetSpellProto()->baseLevel > 0 && GetSpellProto()->maxLevel > 0)
-		{
-			float downrank1 = 1.0f;
-			if (GetSpellProto()->baseLevel < 20)
-			downrank1 = 1.0f - (20.0f - float (GetSpellProto()->baseLevel) ) * 0.0375f;
-			float downrank2 = ( float(GetSpellProto()->maxLevel + 5.0f) / float(m_caster->getLevel()) );
-			if (downrank2 >= 1 || downrank2 < 0)
-			downrank2 = 1.0f;
-			healdoneaffectperc *= downrank1 * downrank2;
-		}
-		*/
 	}	
 }
 
@@ -4293,7 +4638,7 @@
 		else
 			m_caster->SetUInt32Value(UNIT_FIELD_HEALTH, mh);
 
-		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, 1000, FLAG_PERIODIC_LEECH);
+		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, 1000, 0,0, FLAG_PERIODIC_LEECH);
 	}
 }
 
@@ -4671,6 +5016,7 @@
 							case SPELL_AURA_MOD_STUN:
 							case SPELL_AURA_MOD_CONFUSE:
 							case SPELL_AURA_MOD_ROOT:
+							case SPELL_AURA_MOD_FEAR:
 								m_target->m_auras[x]->Remove();
 								goto out;
 								break;
@@ -6316,7 +6662,7 @@
 		uint32 Amount = min( amount, m_target->GetUInt32Value( field ) );
 		uint32 newHealth = m_target->GetUInt32Value(field) - Amount ;
 				
-		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, newHealth, FLAG_PERIODIC_DAMAGE);
+		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, newHealth, 0, 0, FLAG_PERIODIC_DAMAGE);
 		m_target->DealDamage(m_target, Amount, 0, 0, GetSpellProto()->Id);
 	}  
 }
@@ -7074,9 +7420,6 @@
 
 void Aura::SpellAuraIncreaseRating( bool apply )
 {
-	//value == amt
-	//misc = bitmask for ITEM_STAT_TYPE
-
 	int v = apply ? mod->m_amount : -mod->m_amount;
 
 	if( !m_target->IsPlayer() )
@@ -7087,6 +7430,11 @@
 		if( ( ( ( uint32 )1 ) << x ) & mod->m_miscValue )
 			plr->ModifyBonuses( 11 + x, v );
 
+	//MELEE_CRITICAL_AVOIDANCE_RATING + RANGED_CRITICAL_AVOIDANCE_RATING + SPELL_CRITICAL_AVOIDANCE_RATING
+	//comes only as combination of them  - ModifyBonuses() not adding them individually anyhow
+	if( mod->m_miscValue & (0x0004000|0x0008000|0x0010000) )
+			plr->ModifyBonuses( RESILIENCE_RATING, v );
+
 	if( mod->m_miscValue & 1 )//weapon skill
 	{
 		std::map<uint32, uint32>::iterator i;
Index: src/game/SpellAuras.h
===================================================================
--- src/game/SpellAuras.h	(revision 3208)
+++ src/game/SpellAuras.h	(working copy)
@@ -585,7 +585,7 @@
 		m_target->SendMessageToSet(&data,true);
 	}
 	// log message's
-	ASCENT_INLINE void SendPeriodicAuraLog(Unit * Caster, Unit * Target, uint32 SpellID, uint32 School, uint32 Amount, uint32 Flags)
+	ASCENT_INLINE void SendPeriodicAuraLog(Unit * Caster, Unit * Target, uint32 SpellID, uint32 School, uint32 Amount, uint32 abs_dmg, uint32 resisted_damage, uint32 Flags)
 	{
 		WorldPacket data(SMSG_PERIODICAURALOG, 46);
 		data << Target->GetNewGUID();		   // target guid
@@ -595,12 +595,13 @@
 		data << uint32(Flags | 0x1);			// aura school
 		data << Amount;						 // amount of done to target / heal / damage
 		data << School;
-		data << uint64(0);
+		data << uint32(abs_dmg);
+		data << uint32(resisted_damage);
 
 		Caster->SendMessageToSet(&data, true);
 	}
 
-	void SendPeriodicAuraLog(const uint64& CasterGuid, Unit * Target, uint32 SpellID, uint32 School, uint32 Amount, uint32 Flags)
+	void SendPeriodicAuraLog(const uint64& CasterGuid, Unit * Target, uint32 SpellID, uint32 School, uint32 Amount, uint32 abs_dmg, uint32 resisted_damage, uint32 Flags)
 	{
 		WorldPacket data(SMSG_PERIODICAURALOG, 46);
 		data << Target->GetNewGUID();		   // target guid
@@ -610,7 +611,8 @@
 		data << uint32(Flags | 0x1);			// aura school
 		data << Amount;						 // amount of done to target / heal / damage
 		data << School;
-		data << uint64(0);
+		data << uint32(abs_dmg);
+		data << uint32(resisted_damage);
 
 		Target->SendMessageToSet(&data, true);
 	}
Index: src/game/SpellEffects.cpp
===================================================================
--- src/game/SpellEffects.cpp	(revision 3208)
+++ src/game/SpellEffects.cpp	(working copy)
@@ -530,6 +530,8 @@
 			return;
 
 		uint32 damage = (((m_spellInfo->EffectBasePoints[i]+1)*(100+playerTarget->m_lifetapbonus))/100)+((playerTarget->GetDamageDoneMod(m_spellInfo->School)*80)/100);
+		if (damage >= playerTarget->GetUInt32Value(UNIT_FIELD_HEALTH))
+			return;
 		p_caster->DealDamage(playerTarget,damage,0,0,spellId);
 		if(playerTarget->GetUInt32Value(UNIT_FIELD_POWER1)+damage > playerTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1))
 			playerTarget->SetUInt32Value(UNIT_FIELD_POWER1,playerTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1));
@@ -1169,8 +1171,7 @@
 		{
 			/* try to get a selection */
  			unitTarget = m_caster->GetMapMgr()->GetUnit(p_caster->GetSelection());
-//			if( (unitTarget == NULL ) || !isHostile(p_caster, unitTarget) || (unitTarget->CalcDistance(p_caster) > 25.0f)) //removed by Zack : no idea why hostile is used. Isattackable should give a wider solution range
-			if( (unitTarget == NULL ) || !isAttackable(p_caster, unitTarget, !(m_spellInfo->c_is_flags & SPELL_FLAG_IS_TARGETINGSTEALTHED) ) || (unitTarget->CalcDistance(p_caster) > 25.0f))
+			if(unitTarget == NULL || (unitTarget->CalcDistance(p_caster) > 25.0f))
 				return;
 		}
 
@@ -4440,7 +4441,7 @@
 	if(skill < 75)//can up skill
 	if(Rand(float(100-skill*100.0/75.0)))
 		caster->_AdvanceSkillLine(SKILL_ENCHANTING, float2int32( 1.0f * sWorld.getRate(RATE_SKILLRATE)));
-	AddItemFromDisenchant(it->GetProto(),caster);
+	AddItemFromDisenchant(it->GetEntry(),caster);
 
 	if(it==i_caster)
 		i_caster=NULL;
@@ -4879,16 +4880,16 @@
 		damage = damage*sunder_count;
 	}
 
+	//hemorage
+	if( p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_HEMORRHAGE )
+		p_caster->AddComboPoints(p_caster->GetSelection(), 1);
+
 	if( m_spellInfo->Effect[0] == SPELL_EFFECT_WEAPON_PERCENT_DAMAGE || m_spellInfo->Effect[1] == SPELL_EFFECT_WEAPON_PERCENT_DAMAGE)
 	{
 		add_damage = (uint32)(damage * 1.5);
 		return;
 	}
 
-	//hemorage
-	if( p_caster != NULL && m_spellInfo->NameHash == SPELL_HASH_HEMORRHAGE )
-		p_caster->AddComboPoints(p_caster->GetSelection(), 1);
-
 	//rogue - mutilate ads dmg if target is poisoned
 	if(	m_spellInfo->NameHash == SPELL_HASH_MUTILATE && unitTarget->IsPoisoned() )
 		damage = damage + float2int32( (float)damage * 0.5f );
@@ -4927,14 +4928,10 @@
 				data << (uint32)1;
 				data << aur->GetSpellId();
 				m_caster->SendMessageToSet(&data,true);
-				u_caster->CastSpell(u_caster, aur->GetSpellProto(), true);
+				Aura *aura = new Aura(aur->GetSpellProto(), (aur->GetDuration()>120000) ? 120000 : aur->GetDuration(), u_caster, u_caster);
+				u_caster->AddAura(aura);
 				unitTarget->RemoveAura(aur);
-				/*int32 dur = (aur->GetDuration()>120000) ? 120000 : aur->GetDuration();
-				//mb here should be another worldpacket for aurabuff.
-				aur->SetDuration(dur);
-				u_caster->AddAura(aur);
-				u_caster->AddAuraVisual(aur->GetSpellId(),1,true);
-					return;*/
+				return;
 			}			
 		}
 	}   
Index: src/game/Unit.cpp
===================================================================
--- src/game/Unit.cpp	(revision 3208)
+++ src/game/Unit.cpp	(working copy)
@@ -2141,7 +2141,7 @@
 //<SHIT END>
 
 //--------------------------------crushing blow chance--------------------------------------
-	if(pVictim->IsPlayer()&&!this->IsPlayer()&&!ability)
+	if(pVictim->IsPlayer()&&!this->IsPlayer()&&!ability && !dmg.school_type)
 	{
 		if(diffVcapped>=15.0f)
 			crush = -15.0f+2.0f*diffVcapped; 
@@ -3481,7 +3481,7 @@
 	pLastSpell = pSpell->m_spellInfo;
 }
 
-int32 Unit::GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg)
+int32 Unit::GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg, uint32 isDot)
 {
 	int32 plus_damage = 0;
 	Unit* caster = this;
@@ -3505,21 +3505,33 @@
 //==============================+Spell Damage Bonus Modifications===========================
 //==========================================================================================
 //------------------------------by cast duration--------------------------------------------
-	SpellCastTime *sd = dbcSpellCastTime.LookupEntry(spellInfo->CastingTimeIndex);
-	float castaff = float(GetCastTime(sd));
-	if(castaff < 1500) castaff = 1500;
+	float dmgdoneaffectperc = 1.0f;
+	// exception for spell with both dot and direct dmg - use bonus only for direct dmg for now
+	if (spellInfo->dmg_bonus && ((isDot && spellInfo->Effect[0] != SPELL_EFFECT_SCHOOL_DAMAGE && 
+		spellInfo->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE && spellInfo->Effect[2] != SPELL_EFFECT_SCHOOL_DAMAGE)
+		|| !isDot))
+	{
+		dmgdoneaffectperc = spellInfo->dmg_bonus/100.0f;
+	}
+	else if (!isDot) // this isnt valid for DoTs
+	{
+		SpellCastTime *sd = dbcSpellCastTime.LookupEntry(spellInfo->CastingTimeIndex);
+		float castaff = float(GetCastTime(sd));
+		if(castaff < 1500) castaff = 1500;
+		else
+			if(castaff > 7000) castaff = 7000;
+
+		dmgdoneaffectperc = castaff / 3500.0f;
+	}
 	else
-		if(castaff > 7000) castaff = 7000;
+	{
+		//DOT-DD (Moonfire-Immolate-IceLance-Pyroblast)(Hack Fix)
+		float td = float( GetDuration( dbcSpellDuration.LookupEntry( spellInfo->DurationIndex )  ));
+		if( spellInfo->NameHash == SPELL_HASH_MOONFIRE || spellInfo->NameHash == SPELL_HASH_IMMOLATE || spellInfo->NameHash == SPELL_HASH_ICE_LANCE || spellInfo->NameHash == SPELL_HASH_PYROBLAST )
+			dmgdoneaffectperc *= float( 1.0f - ( ( td / 15000.0f ) / ( ( td / 15000.0f ) + dmgdoneaffectperc ) ) );
+	}
 
-	float dmgdoneaffectperc = castaff / 3500;
-
 	//------------------------------by downranking----------------------------------------------
-	//DOT-DD (Moonfire-Immolate-IceLance-Pyroblast)(Hack Fix)
-
-	float td = float( GetDuration( dbcSpellDuration.LookupEntry( spellInfo->DurationIndex )  ));
-	if( spellInfo->NameHash == SPELL_HASH_MOONFIRE || spellInfo->NameHash == SPELL_HASH_IMMOLATE || spellInfo->NameHash == SPELL_HASH_ICE_LANCE || spellInfo->NameHash == SPELL_HASH_PYROBLAST )
-		dmgdoneaffectperc *= float( 1.0f - ( ( td / 15000.0f ) / ( ( td / 15000.0f ) + dmgdoneaffectperc ) ) );
-
 	if(spellInfo->baseLevel > 0 && spellInfo->maxLevel > 0)
 	{
 		float downrank1 = 1.0f;
@@ -3711,6 +3723,31 @@
 
 	switch(type)
 	{
+	case CHAT_MSG_MONSTER_EMOTE:
+		{
+			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
+			{
+				if((*i)->GetTypeId() == TYPEID_PLAYER)
+				{
+					std::stringstream szMessage;
+					szMessage << UnitName << msg;
+
+					WorldPacket data(SMSG_MESSAGECHAT, 35 + UnitNameLength + MessageLength);
+					data << type;
+					data << lang;
+					data << GetGUID();
+					data << uint32(0);			// new in 2.1.0
+					data << uint32(UnitNameLength);
+					data << UnitName;
+					data << ((Player*)(*i))->GetGUID();
+					data << uint32(strlen(szMessage.str().c_str())+1);
+					data << szMessage.str().c_str();
+					data << uint8(0x00);
+					WorldSession *session = ((Player*)(*i))->GetSession();
+					session->SendPacket(&data);
+				}
+			}
+		}break;
 	case CHAT_MSG_MONSTER_SAY:
 		{
 			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
Index: src/game/Unit.h
===================================================================
--- src/game/Unit.h	(revision 3208)
+++ src/game/Unit.h	(working copy)
@@ -810,7 +810,7 @@
 	void InterruptSpell();
 
 	//caller is the caster
-	int32 GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg);
+	int32 GetSpellDmgBonus(Unit *pVictim, SpellEntry *spellInfo,int32 base_dmg, uint32 isDot);
    
 	Unit* create_guardian(uint32 guardian_entry,uint32 duration,float angle);//guardians are temporary spawn that will inherit master faction and will folow them. Apart from that they have their own mind
 
Index: src/game/World.cpp
===================================================================
--- src/game/World.cpp	(revision 3208)
+++ src/game/World.cpp	(working copy)
@@ -1511,6 +1511,19 @@
 
 	SpellEntry* sp;
 
+	//"deal with the devil" custom spell based on unused dummy 
+	sp = dbcSpell.LookupEntry(32052);
+	if(sp != NULL)
+	{
+		sp->DurationIndex = 407;
+		sp->dummy = 1;
+		sp->procFlags = 0;
+		sp->Attributes = 0;
+		sp->AttributesEx = 0;
+		sp->Flags3 = 0;
+		sp->maxstack = 0;
+	}
+
 	sp = dbcSpell.LookupEntry( 16164 );
 	if( sp != NULL && sp->Id == 16164 )
 		sp->procFlags = PROC_ON_SPELL_CRIT_HIT_VICTIM;
@@ -6337,6 +6350,8 @@
 		new MailSystem;
 
 	channelmgr.seperatechannels = Config.MainConfig.GetBoolDefault("Server", "SeperateChatChannels", false);
+	PvpFactionLimitation = Config.MainConfig.GetBoolDefault("Server", "PvpFactionLimitation", true);
+	FriendFactionLimitation = Config.MainConfig.GetBoolDefault("Server", "FriendFactionLimitation", true);
 	sendRevisionOnJoin = Config.MainConfig.GetBoolDefault("Server", "SendBuildOnJoin", false);
 	MapPath = Config.MainConfig.GetStringDefault("Terrain", "MapPath", "maps");
 	UnloadMapFiles = Config.MainConfig.GetBoolDefault("Terrain", "UnloadMapFiles", true);
Index: src/game/World.h
===================================================================
--- src/game/World.h	(revision 3208)
+++ src/game/World.h	(working copy)
@@ -520,6 +520,8 @@
 
 	string MapPath;
 	bool UnloadMapFiles;
+	bool PvpFactionLimitation;
+	bool FriendFactionLimitation;
 	bool BreathingEnabled;
 	bool SpeedhackProtection;
 	void EventDeleteBattleground(Battleground * BG);
Index: src/shared/Database/DBCStores.h
===================================================================
--- src/shared/Database/DBCStores.h	(revision 3208)
+++ src/shared/Database/DBCStores.h	(working copy)
@@ -350,7 +350,8 @@
 	uint32 in_front_status;
 	bool is_melee_spell;
     uint32 EffectSpellGroupRelation_high[3];     //!!! this is not contained in client dbc but server must have it
-};
+	uint32 dmg_bonus;						//!!! CUSTOM, spell co-efficiency ( dmg/healing % taken from gear )
+};	
 
 struct ItemExtendedCostEntry
 {
