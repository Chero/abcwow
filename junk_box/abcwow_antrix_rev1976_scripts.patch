Index: projects/InstanceScripts2005.vcproj
===================================================================
--- projects/InstanceScripts2005.vcproj	(revision 1976)
+++ projects/InstanceScripts2005.vcproj	(working copy)
@@ -207,6 +207,38 @@
 				>
 			</File>
 			<File
+				RelativePath="..\src\InstanceScripts\Instance_Arcatraz.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\InstanceScripts\Instance_BloodFurnace.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\InstanceScripts\Instance_HellfireRamparts.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\InstanceScripts\Instance_SethekkHalls.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\InstanceScripts\Instance_TheMechanar.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\InstanceScripts\Instance_TheSteamvault.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\InstanceScripts\Raid_GruulsLair.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\src\InstanceScripts\Raid_Karazhan.cpp"
+				>
+			</File>
+			<File
 				RelativePath="..\src\InstanceScripts\Raid_BlackwingLair.cpp"
 				>
 			</File>
@@ -226,6 +258,10 @@
 				RelativePath="..\src\InstanceScripts\Raid_ZulGurub.cpp"
 				>
 			</File>
+			<File
+				RelativePath="..\src\InstanceScripts\Raid_TheEye.cpp"
+				>
+			</File>
 		</Filter>
 	</Files>
 	<Globals>
Index: src/InstanceScripts/Instance_Arcatraz.cpp
===================================================================
--- src/InstanceScripts/Instance_Arcatraz.cpp	(revision 0)
+++ src/InstanceScripts/Instance_Arcatraz.cpp	(revision 0)
@@ -0,0 +1,5965 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+/************************************************************************/
+/* Instance_Arcatraz.cpp Script											*/
+/************************************************************************/
+
+// Arcatraz DefenderAI
+
+#define CN_ARCATRAZ_DEFENDER 20857
+
+#define PROTEAN_SUBDUAL 36288
+#define FLAMING_WEAPON 36601
+#define IMMOLATE 36638
+
+class ArcatrazDefenderAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ArcatrazDefenderAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    ArcatrazDefenderAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(PROTEAN_SUBDUAL);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 5.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(FLAMING_WEAPON);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(IMMOLATE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 8.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Arcatraz SentinelAI
+
+#define CN_ARCATRAZ_SENTINEL 20869
+
+#define ENERGY_DISCHARGE 36717
+#define EXPLODE 36719 // DBC: 36722, 36719
+
+//Permanent Feign Death (Root) 31261 ?
+
+class ArcatrazSentinelAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ArcatrazSentinelAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    ArcatrazSentinelAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ENERGY_DISCHARGE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(EXPLODE);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		if (_unit->GetHealthPct() <= 5)
+			_unit->CastSpell(_unit, spells[1].info, spells[1].instant);
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Arcatraz WarderAI
+
+#define CN_ARCATRAZ_WARDER 20859
+
+#define ARCANE_SHOT 36609
+#define SHOT 15620
+#define IMPROVED_WING_CLIP 35963
+#define CHARGED_ARCANE_SHOT 36608
+
+//Shoot Arcane Explosion Arrow 36327 ?
+
+class ArcatrazWarderAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ArcatrazWarderAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    ArcatrazWarderAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ARCANE_SHOT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SHOT);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(IMPROVED_WING_CLIP);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 8.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(CHARGED_ARCANE_SHOT);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		if (_unit->GetAIInterface()->GetNextTarget())
+		{
+			Unit *target = NULL;
+			target = _unit->GetAIInterface()->GetNextTarget();
+			if (_unit->GetDistance2dSq(target) >= 100.0f && _unit->GetDistanceSq(target) <= 900.0f)
+			{
+				_unit->GetAIInterface()->m_canMove = false;
+				int RangedSpell;
+				sRand.randInt(1000);
+				RangedSpell=rand()%100;
+				if (RangedSpell >= 0 && RangedSpell <= 20)
+				{
+					_unit->CastSpell(target, spells[3].info, spells[3].instant);
+					_unit->setAttackTimer(spells[3].attackstoptimer, false);
+				}
+				if (RangedSpell > 20 && RangedSpell <= 40)
+				{
+					_unit->CastSpell(target, spells[0].info, spells[0].instant);
+					_unit->setAttackTimer(spells[0].attackstoptimer, false);
+				}
+				else
+				{
+					_unit->CastSpell(target, spells[1].info, spells[1].instant);
+					_unit->setAttackTimer(spells[1].attackstoptimer, false);
+				}
+			}
+
+			else
+			{
+				_unit->GetAIInterface()->m_canMove = true;
+				if (_unit->GetDistance2dSq(target) < 100.0f)
+				{
+					float val = sRand.rand(100.0f);
+					SpellCast(val);
+				}
+			}
+		}
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())	// I was too lazy to rewrite it =S
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Blackwing DrakonaarAI
+
+#define CN_BLACKWING_DRAKONAAR 20911
+
+#define SIMPLE_TELEPORT 12980
+#define BROOD_POWER_BLACK 39033
+#define MORTAL_STRIKE 13737
+#define BLAST_WAVE 39038
+
+class BlackwingDrakonaarAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BlackwingDrakonaarAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    BlackwingDrakonaarAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SIMPLE_TELEPORT);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(BROOD_POWER_BLACK);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(MORTAL_STRIKE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 10.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(BLAST_WAVE);
+		spells[3].targettype = TARGET_VARIOUS;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 6.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Blazing TricksterAI
+
+#define CN_BLACKWING_TRICKSTER 20905
+
+#define FIREBOLT 36906
+#define FIRE_SHIELD 36907
+
+class BlackwingTricksterAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BlackwingTricksterAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    BlackwingTricksterAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FIREBOLT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(FIRE_SHIELD);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Death WatcherAI
+
+#define CN_DEATH_WATCHER 20867
+
+#define TENTACLE_CLEAVE 36664
+#define DRAIN_LIFE 36655
+#define DEATH_COUNT 36657	// DBC: 36657, 36660
+
+class DeathWatcherAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(DeathWatcherAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    DeathWatcherAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(TENTACLE_CLEAVE);
+		spells[0].targettype = TARGET_ATTACKING;	// to prevent crashes changed from VARIOUS
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(DRAIN_LIFE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(DEATH_COUNT);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+		MarkApplied = 0;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		MarkApplied = 0;
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		MarkApplied = 0;
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		MarkApplied = 0;
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		if (_unit->GetHealthPct() <= 50 && !MarkApplied)
+		{
+			_unit->CastSpell(_unit, spells[2].info, spells[2].instant);
+			MarkApplied = 1;
+		}
+
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	uint32 MarkApplied;
+	int nrspells;
+};
+
+// Defender CorpseAI
+
+#define CN_DEFENDER_CORPSE 21303
+
+#define CORPSE_BURST 36593
+#define BLOODY_EXPLOSION 36599
+//#define PERMANENT_FEIGN_DEATH_ROOT 31261	// I don't have much infos and I am not sure about how it should work
+											// I presume this is just corpse which should cast spell when player is close or attk it
+
+class DefenderCorpseAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(DefenderCorpseAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    DefenderCorpseAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(CORPSE_BURST);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(BLOODY_EXPLOSION);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[1].info, spells[1].instant);
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Protean SpawnAI
+
+#define CN_PROTEAN_SPAWN 21395	// it's sth that spawns from Defender Corpse
+
+#define ACIDIC_BITE 36796
+//#define BLOODY_EXPLOSION 36588
+
+class ProteanSpawnAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ProteanSpawnAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    ProteanSpawnAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ACIDIC_BITE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Entropic EyeAI
+
+#define CN_ENTROPIC_EYE 20868
+
+#define WAVERING_WILL 36699	// not sure if this is right one (I mean spell, not ID)
+#define PIERCING_SHADOW 36698		// this "smaller" list must be rechecked =S
+#define HEX 36700
+#define TANTACLE_CLEAVE_EYE 36664
+
+/*
+#define TANTACLE_CLEAVE_EYE 36664
+#define FIREBALL_EYE 36711
+#define FROSTBOLT_EYE 36710
+#define WITHERED_TOUCH_EYE 36696
+#define HEX_EYE 36700
+#define PIERCING_SHADOW_EYE 36698
+#define CHAOS_BREATH_EYE 36677	// SSS
+#define POISON_BOLT_EYE 36713				// DBC List :O
+#define NECROTIC_POISON_EYE 36693
+#define SHRINK_EYE 36697
+#define SHADOW_BOLT_EYE 36714
+#define FEVERED_FATIGUE_EYE 36695
+#define WAVERING_WILL_EYE 36699
+#define CORROSIVE_POISON_EYE 36694
+#define ARCANE_BOLT_EYE 36712
+*/
+
+class EntropicEyeAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(EntropicEyeAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    EntropicEyeAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(WAVERING_WILL);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 5.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(PIERCING_SHADOW);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 5.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(HEX);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(TANTACLE_CLEAVE_EYE);
+		spells[3].targettype = TARGET_ATTACKING;	// changed from VAR. to prevent crashes
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 12.0f;
+		spells[3].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Eredar DeathbringerAI
+
+#define CN_EREDAR_DEATHBRINGER 20880
+
+#define UNHOLY_AURA 27987	// DBC: 27988, 27987
+#define DIMINISH_SOUL 36789	// DBC: 36789, 36791 (SSS)
+#define FORCEFUL_CLEAVE 36787
+
+class EredarDeathbringerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(EredarDeathbringerAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    EredarDeathbringerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(UNHOLY_AURA);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(DIMINISH_SOUL);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(FORCEFUL_CLEAVE);
+		spells[2].targettype = TARGET_ATTACKING;	// to prevent crashes changed
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 13.0f;
+		spells[2].attackstoptimer = 1000;
+
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Eredar Soul-EaterAI
+
+#define CN_EREDAR_SOUL_EATER 20879
+
+#define SOUL_CHILL 36786
+#define SOUL_STEAL1 36778	// this on target, another on self
+#define SOUL_STEAL2 36782	// DBC: 36782, 36778
+
+class EredarSoulEaterAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(EredarSoulEaterAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    EredarSoulEaterAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SOUL_CHILL);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SOUL_STEAL1);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(SOUL_STEAL2);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (m_spellcheck[1] == true)
+						_unit->CastSpell(_unit, spells[2].info, spells[2].instant);
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Ethereum Life-BinderAI
+
+#define CN_ETHEREUM_LIFE_BINDER 21702
+
+#define BIND 37480
+#define SHADOW_WORD_PAIN 15654
+
+class EthereumLifeBinderAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(EthereumLifeBinderAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    EthereumLifeBinderAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(BIND);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SHADOW_WORD_PAIN);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Ethereum SlayerAI
+
+#define CN_ETHEREUM_SLAYER 20896
+
+#define IMPARING_POISON 36839
+#define SLAYER_STRIKE 36838
+#define EVASION 15087
+
+class EthereumSlayerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(EthereumSlayerAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    EthereumSlayerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(IMPARING_POISON);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 7.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SLAYER_STRIKE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 12.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(EVASION);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Ethereum Wave-CasterAI
+
+#define CN_ETHEREUM_WAVE_CASTER 20897
+
+#define POLYMORPH 36840
+#define ARCANE_HASTE 32693
+#define SONIC_BOMB 36841	// should counter spell so I must code it a bit more
+// KNOCKBACK ?
+
+class EthereumWaveCasterAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(EthereumWaveCasterAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    EthereumWaveCasterAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(POLYMORPH);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 7.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(ARCANE_HASTE);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 5.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(SONIC_BOMB);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 11.0f;
+		spells[2].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Gargantuan AbyssalAI
+
+#define CN_GARGANTUAN_ABYSSAL 20898
+
+#define FIRE_SHIELD_ABY 38855	// DBC: 38855, 38893
+#define METEOR 36837
+
+class GargantuanAbyssalAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(GargantuanAbyssalAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    GargantuanAbyssalAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FIRE_SHIELD_ABY);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 7.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(METEOR);
+		spells[1].targettype = TARGET_DESTINATION;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Greater Fire ElementalAI
+
+#define CN_GREATER_FIRE_ELEMENTAL 15438
+
+#define FIRE_SHIELD_GFE 13376
+#define FIRE_NOVA 12470
+#define FIRE_BLAST 13339
+#define MARK_OF_DEATH 37128	// SSS	// should be applied on target
+
+class GreaterFireElementalAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(GreaterFireElementalAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    GreaterFireElementalAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FIRE_SHIELD_GFE);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(FIRE_NOVA);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 9.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(FIRE_BLAST);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 9.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(MARK_OF_DEATH);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// IronjawAI	// spells verification, coz some of those are for sure pet spells? :| :| :|
+
+#define CN_IRONJAW 18670
+// I couldn't force Ironjaw to cast spells with "?"
+#define FURIOUS_HOWL 24597	// ?
+#define DASH 23110
+#define BITE 27050
+#define GROWL 14921			// ?
+#define FEROCIOUS_INSPIRATION 34456	// ?
+#define FRENZY_EFFECT 19615
+#define KILL_COMMAND 34027
+#define BESTIAL_WRATH 24395	// DBC: 24395, 24396, 24397, 26592 (all are diffrent)	// ?
+#define SNARL 32919
+#define CHILLING_HOWL 32918
+
+class IronjawAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(IronjawAI);
+	SP_AI_Spell spells[10];
+	bool m_spellcheck[10];
+
+    IronjawAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 10;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FURIOUS_HOWL);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 3.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(DASH);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 3.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(BITE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 8.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(GROWL);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(FEROCIOUS_INSPIRATION);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 3.0f;
+		spells[4].attackstoptimer = 1000;
+
+		spells[5].info = dbcSpell.LookupEntry(FRENZY_EFFECT);
+		spells[5].targettype = TARGET_SELF;
+		spells[5].instant = true;
+		spells[5].cooldown = -1;
+		spells[5].perctrigger = 4.0f;
+		spells[5].attackstoptimer = 1000;
+
+		spells[6].info = dbcSpell.LookupEntry(KILL_COMMAND);
+		spells[6].targettype = TARGET_ATTACKING;
+		spells[6].instant = true;
+		spells[6].cooldown = -1;
+		spells[6].perctrigger = 6.0f;
+		spells[6].attackstoptimer = 1000;
+
+		spells[7].info = dbcSpell.LookupEntry(BESTIAL_WRATH);
+		spells[7].targettype = TARGET_ATTACKING;
+		spells[7].instant = true;
+		spells[7].cooldown = -1;
+		spells[7].perctrigger = 4.0f;
+		spells[7].attackstoptimer = 1000;
+
+		spells[8].info = dbcSpell.LookupEntry(SNARL);
+		spells[8].targettype = TARGET_ATTACKING;
+		spells[8].instant = true;
+		spells[8].cooldown = -1;
+		spells[8].perctrigger = 8.0f;
+		spells[8].attackstoptimer = 1000;
+
+		spells[9].info = dbcSpell.LookupEntry(CHILLING_HOWL);
+		spells[9].targettype = TARGET_ATTACKING;
+		spells[9].instant = true;
+		spells[9].cooldown = -1;
+		spells[9].perctrigger = 5.0f;
+		spells[9].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Millhouse ManastormAI
+
+#define CN_MILLHOUSE_MANASTORM 20977
+
+#define SIMPLE_TELEPORT_MM 12980
+#define CONJURE_WATER 36879	// SSS =/
+#define ARCANE_INTELLECT 36880
+#define ICE_ARMOR 36881
+#define DRINK 30024
+#define FIREBALL_MM 14034
+#define FROSTBOLT_MM 15497
+#define FIRE_BLAST_MM 13341
+#define CONE_OF_COLD 12611
+#define ARCANE_MISSILES 33832	// DBC: 33832, 33833
+#define PYROBLAST 33975
+//#define CHILLED 7321 effect of ICE_ARMOR 36881
+
+class MillhouseManastormAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MillhouseManastormAI);
+	SP_AI_Spell spells[11];
+	bool m_spellcheck[11];
+
+    MillhouseManastormAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 11;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SIMPLE_TELEPORT_MM);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(CONJURE_WATER);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(ARCANE_INTELLECT);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 3.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(ICE_ARMOR);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 3.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(DRINK);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+		spells[5].info = dbcSpell.LookupEntry(FIREBALL_MM);
+		spells[5].targettype = TARGET_ATTACKING;
+		spells[5].instant = false;
+		spells[5].cooldown = -1;
+		spells[5].perctrigger = 5.0f;
+		spells[5].attackstoptimer = 1000;
+
+		spells[6].info = dbcSpell.LookupEntry(FROSTBOLT_MM);
+		spells[6].targettype = TARGET_ATTACKING;
+		spells[6].instant = false;
+		spells[6].cooldown = -1;
+		spells[6].perctrigger = 5.0f;
+		spells[6].attackstoptimer = 1000;
+
+		spells[7].info = dbcSpell.LookupEntry(FIRE_BLAST_MM);
+		spells[7].targettype = TARGET_ATTACKING;
+		spells[7].instant = true;
+		spells[7].cooldown = -1;
+		spells[7].perctrigger = 5.0f;
+		spells[7].attackstoptimer = 1000;
+
+		spells[8].info = dbcSpell.LookupEntry(CONE_OF_COLD);
+		spells[8].targettype = TARGET_VARIOUS;
+		spells[8].instant = true;
+		spells[8].cooldown = -1;
+		spells[8].perctrigger = 4.0f;
+		spells[8].attackstoptimer = 1000;
+
+		spells[9].info = dbcSpell.LookupEntry(ARCANE_MISSILES);
+		spells[9].targettype = TARGET_ATTACKING;
+		spells[9].instant = false;
+		spells[9].cooldown = -1;
+		spells[9].perctrigger = 5.0f;
+		spells[9].attackstoptimer = 1000;
+
+		spells[10].info = dbcSpell.LookupEntry(PYROBLAST);
+		spells[10].targettype = TARGET_ATTACKING;
+		spells[10].instant = false;
+		spells[10].cooldown = -1;
+		spells[10].perctrigger = 2.0f;
+		spells[10].attackstoptimer = 1000;
+
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {/*
+		CastTime();
+		if (_unit->GetUInt32Value(UNIT_FIELD_POWER1) < _unit->GetUInt32Value(UNIT_FIELD_BASE_MANA))
+		{
+			_unit->CastSpell(_unit, spells[1].info, spells[1].instant);
+			_unit->CastSpell(_unit, spells[4].info, spells[4].instant);
+		}*/
+		_unit->CastSpell(_unit, spells[1].info, spells[1].instant);
+		_unit->CastSpell(_unit, spells[4].info, spells[4].instant);
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Negaton ScreamerAI	// this one needs some more work for dmg taken dmg type, but I don't have time for it...
+
+#define CN_NEGATON_SCREAMER 20875		// I need to add missing about 15 mobs (w00t? More? =() and to this script
+										// OnDamageTaken function with check of spell dmg type and correc spell casts in diff cases
+#define PSYCHIC_SCREAM 13704
+#define DAMAGE_REDUCTION_SHADOW 34338
+#define DAMAGE_REDUCTION_FROST 34334
+#define DAMAGE_REDUCTION_ARCANE 34331
+#define DAMAGE_REDUCTION_FIRE 34333
+#define DAMAGE_REDUCTION_HOLY 34336
+#define DAMAGE_REDUCTION_NATURE 34335
+//#define DAMAGE_REDUCTION_PHYSICAL 34337
+#define SHADOW_ENERGY 34399 // Energy SSS-s (I am sure only to spells shadow-frost-arcane-fire)
+#define FROST_ENERGY 34404
+#define ARCANE_ENERGY 34401
+#define FIRE_ENERGY 34398
+#define HOLY_ENERGY 34403
+#define NATURE_ENERGY 34402
+//#define PHYSICAL_ENERGY 
+#define SHADOW_BOLT_VOLLEY 36736
+#define FROSTBOLT_VOLLEY 36741
+#define ARCANE_VOLLEY 36738
+#define FIREBALL_VOLLEY 36742
+#define HOLY_VOLLEY 36743
+#define LIGHTNING_BOLT_VOLLEY	36740
+//#define _VOLLEY
+
+
+class NegatonScreamerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(NegatonScreamerAI);
+	SP_AI_Spell spells[19];
+	bool m_spellcheck[19];
+
+    NegatonScreamerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 19;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(PSYCHIC_SCREAM);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 5.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(DAMAGE_REDUCTION_SHADOW);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(DAMAGE_REDUCTION_FROST);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(DAMAGE_REDUCTION_ARCANE);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(DAMAGE_REDUCTION_FIRE);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+		spells[5].info = dbcSpell.LookupEntry(DAMAGE_REDUCTION_HOLY);
+		spells[5].targettype = TARGET_SELF;
+		spells[5].instant = true;
+		spells[5].cooldown = -1;
+		spells[5].perctrigger = 0.0f;
+		spells[5].attackstoptimer = 1000;
+
+		spells[6].info = dbcSpell.LookupEntry(DAMAGE_REDUCTION_NATURE);
+		spells[6].targettype = TARGET_SELF;
+		spells[6].instant = true;
+		spells[6].cooldown = -1;
+		spells[6].perctrigger = 0.0f;
+		spells[6].attackstoptimer = 1000;
+
+		spells[7].info = dbcSpell.LookupEntry(SHADOW_ENERGY);
+		spells[7].targettype = TARGET_SELF;
+		spells[7].instant = true;
+		spells[7].cooldown = -1;
+		spells[7].perctrigger = 0.0f;
+		spells[7].attackstoptimer = 1000;
+
+		spells[8].info = dbcSpell.LookupEntry(FROST_ENERGY);
+		spells[8].targettype = TARGET_SELF;
+		spells[8].instant = true;
+		spells[8].cooldown = -1;
+		spells[8].perctrigger = 0.0f;
+		spells[8].attackstoptimer = 1000;
+
+		spells[9].info = dbcSpell.LookupEntry(ARCANE_ENERGY);
+		spells[9].targettype = TARGET_SELF;
+		spells[9].instant = true;
+		spells[9].cooldown = -1;
+		spells[9].perctrigger = 0.0f;
+		spells[9].attackstoptimer = 1000;
+
+		spells[10].info = dbcSpell.LookupEntry(FIRE_ENERGY);
+		spells[10].targettype = TARGET_SELF;
+		spells[10].instant = true;
+		spells[10].cooldown = -1;
+		spells[10].perctrigger = 0.0f;
+		spells[10].attackstoptimer = 1000;
+
+		spells[11].info = dbcSpell.LookupEntry(HOLY_ENERGY);
+		spells[11].targettype = TARGET_SELF;
+		spells[11].instant = true;
+		spells[11].cooldown = -1;
+		spells[11].perctrigger = 0.0f;
+		spells[11].attackstoptimer = 1000;
+
+		spells[12].info = dbcSpell.LookupEntry(NATURE_ENERGY);
+		spells[12].targettype = TARGET_SELF;
+		spells[12].instant = true;
+		spells[12].cooldown = -1;
+		spells[12].perctrigger = 0.0f;
+		spells[12].attackstoptimer = 1000;
+
+		spells[13].info = dbcSpell.LookupEntry(SHADOW_BOLT_VOLLEY);
+		spells[13].targettype = TARGET_VARIOUS;
+		spells[13].instant = false;
+		spells[13].cooldown = -1;
+		spells[13].perctrigger = 0.0f;
+		spells[13].attackstoptimer = 1000;
+
+		spells[14].info = dbcSpell.LookupEntry(FROSTBOLT_VOLLEY);
+		spells[14].targettype = TARGET_VARIOUS;
+		spells[14].instant = false;
+		spells[14].cooldown = -1;
+		spells[14].perctrigger = 0.0f;
+		spells[14].attackstoptimer = 1000;
+
+		spells[15].info = dbcSpell.LookupEntry(ARCANE_VOLLEY);
+		spells[15].targettype = TARGET_VARIOUS;
+		spells[15].instant = false;
+		spells[15].cooldown = -1;
+		spells[15].perctrigger = 0.0f;
+		spells[15].attackstoptimer = 1000;
+
+		spells[16].info = dbcSpell.LookupEntry(FIREBALL_VOLLEY);
+		spells[16].targettype = TARGET_VARIOUS;
+		spells[16].instant = false;
+		spells[16].cooldown = -1;
+		spells[16].perctrigger = 0.0f;
+		spells[16].attackstoptimer = 1000;
+
+		spells[17].info = dbcSpell.LookupEntry(HOLY_VOLLEY);
+		spells[17].targettype = TARGET_VARIOUS;
+		spells[17].instant = false;
+		spells[17].cooldown = -1;
+		spells[17].perctrigger = 0.0f;
+		spells[17].attackstoptimer = 1000;
+
+		spells[18].info = dbcSpell.LookupEntry(LIGHTNING_BOLT_VOLLEY);
+		spells[18].targettype = TARGET_VARIOUS;
+		spells[18].instant = false;
+		spells[18].cooldown = -1;
+		spells[18].perctrigger = 0.0f;
+		spells[18].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Negaton Warp-MasterAI
+
+#define CN_NEGATON_WARP_MASTER 20873
+
+#define SUMMON_NEGATION_FIELD 36813
+
+class NegatonWarpMasterAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(NegatonWarpMasterAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    NegatonWarpMasterAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SUMMON_NEGATION_FIELD);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Negaton FieldAI
+
+#define CN_NEGATON_FIELD 21414
+
+#define NEGATION_FIELD 36728 // DBC: 36728, 36729;
+
+class NegatonFieldAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(NegatonFieldAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    NegatonFieldAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(NEGATION_FIELD);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Phase-HunterAI
+
+#define CN_PHASE_HUNTER 20906
+
+#define SIMPLE_TELEPORT_PH 12980
+#define BACK_ATTACK 36909
+#define WARP 36908	// lack of core support?
+#define PHASE_BURST 36910
+
+class PhaseHunterAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(PhaseHunterAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    PhaseHunterAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SIMPLE_TELEPORT_PH);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(BACK_ATTACK);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(WARP);
+		spells[2].targettype = TARGET_SELF;	//?
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(PHASE_BURST);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (m_spellcheck[2] == true)
+					{
+						uint32 chance = sRand.randInt(100);
+						if (chance > 0 && chance <= 30)
+							_unit->CastSpell(_unit, spells[1].info, spells[1].instant);
+						else return;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Protean HorrorAI
+
+#define CN_PROTEAN_HORROR 20865
+
+#define TOOTHY_BITE 36612
+//#define BLOODY_EXPLOSION 36588
+
+class ProteanHorrorAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ProteanHorrorAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    ProteanHorrorAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(TOOTHY_BITE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Protean NightmareAI
+
+#define CN_PROTEAN_NIGHTMARE 20864
+
+#define INCUBATION 36622
+#define INFECTIOUS_POISON 36619
+#define GAPIND_MAW 36617
+
+class ProteanNightmareAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ProteanNightmareAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    ProteanNightmareAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(INCUBATION);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 6.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(INFECTIOUS_POISON);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 10.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(GAPIND_MAW);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = false;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Sulfuron Magma-ThrowerAI
+
+#define CN_SULFURON_MAGMA_THROWER 20909
+
+#define SIMPLE_TELEPORT_SMT 12980
+#define SHADOW_BOLT_SMT 36986	// DBC: 36987, 36986;
+#define MAGMA_THROWERS_CURSE 36917
+#define RAIN_OF_FIRE 19717
+
+class SulfuronMagmaThrowerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SulfuronMagmaThrowerAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SulfuronMagmaThrowerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SIMPLE_TELEPORT_SMT);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SHADOW_BOLT_SMT);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 12.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(MAGMA_THROWERS_CURSE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(RAIN_OF_FIRE);
+		spells[3].targettype = TARGET_DESTINATION;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 9.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Spiteful TemptressAI
+
+#define CN_SPITEFUL_TEMPTRESS 20883
+
+#define SHADOW_BOLT_ST 36868
+#define DOMINATION_ST 36866
+#define SPITEFUL_FURY 36886
+#define PRAYER_OF_MENDING 33280	// DBC: 33280, 33110; SSS
+
+class SpitefulTemptressAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SpitefulTemptressAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SpitefulTemptressAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SHADOW_BOLT_ST);
+		spells[0].targettype = TARGET_DESTINATION;	// not sure DESTINATION or ATTACKING
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 12.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(DOMINATION_ST);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 5.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(SPITEFUL_FURY);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 7.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(PRAYER_OF_MENDING);
+		spells[3].targettype = TARGET_VARIOUS;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 8.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Soul DevourerAI
+
+#define CN_SOUL_DEVOURER 20866
+
+#define SIGHTLESS_EYE 36644
+#define LAVA_BREATH 21333	// doesn't have animation?
+#define FEL_BREATH 36654
+#define FRENZY 33958
+
+class SoulDevourerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SoulDevourerAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SoulDevourerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SIGHTLESS_EYE);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 7.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(LAVA_BREATH);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 12.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(FEL_BREATH);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 8.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(FRENZY);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 8.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// SolomonAI
+
+#define CN_SOLOMON 798	// not sure if this boy should be scripted, but he was in DBC and had spells, so I couldn't
+						// stop myself to not give little boy deadly skills muhahah =)
+
+#define SLIME_SPRAY 36486
+#define SAW_BLADE 32735
+#define CRUSADER_STRIKE 35509	// SE (script effect)
+
+class SolomonAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SolomonAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    SolomonAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SLIME_SPRAY);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SAW_BLADE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(CRUSADER_STRIKE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 12.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Skulking WitchAI
+
+#define CN_SKULKING_WITCH 20882	// works really cool as assassin :)
+
+#define CHASTISE 36863
+#define GOUGE 36862
+#define LASH_OF_PAIN 36864
+#define GREAT_INVISIBILITY 16380
+
+class SkulkingWitchAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SkulkingWitchAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SkulkingWitchAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(CHASTISE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 12.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(GOUGE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(LASH_OF_PAIN);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(GREAT_INVISIBILITY);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+		_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		FIRST_ATTACK = 1;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		FIRST_ATTACK = 1;
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		FIRST_ATTACK = 1;
+		_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		FIRST_ATTACK = 1;
+		_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		if (FIRST_ATTACK && _unit->GetAIInterface()->GetNextTarget())
+		{
+			FIRST_ATTACK = 0;
+			Unit * target = NULL;
+			target = _unit->GetAIInterface()->GetNextTarget();
+			_unit->CastSpell(target, spells[1].info, spells[1].instant);
+		}
+
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	uint32 FIRST_ATTACK;
+	int nrspells;
+};
+
+// Sightless EyeAI
+
+#define CN_SIGHTLESS_EYE 21346	
+
+#define SIGHTLESS_TOUCH 36646
+
+class SightlessEyeAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SightlessEyeAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    SightlessEyeAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SIGHTLESS_TOUCH);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Sargeron HellcallerAI
+
+#define CN_SARGERON_HELLCALLER 20902	
+
+#define HELL_RAIN 36829
+#define CURSE_OF_THE_ELEMENTS 36831
+#define INCINERATE 36832
+
+class SargeronHellcallerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SargeronHellcallerAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    SargeronHellcallerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(HELL_RAIN);
+		spells[0].targettype = TARGET_DESTINATION;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(CURSE_OF_THE_ELEMENTS);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 6.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(INCINERATE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = false;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 11.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Unbound DevastatorAI
+
+#define CN_UNBOUND_DEVASTATOR 20881
+
+#define DEAFENING_ROAR 36887
+#define DEVASTATE 36894	// DBC: 36891, 36894;
+
+class UnboundDevastatorAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(UnboundDevastatorAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    UnboundDevastatorAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(DEAFENING_ROAR);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 7.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(DEVASTATE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 10.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Unchained DoombringerAI
+
+#define CN_UNCHAINED_DOOMBRINGER 20900	
+
+#define AGONIZING_ARMOR 36836
+#define WAR_STOMP 36835
+#define BERSEKER_CHARGE 36833	// should charge the farthest enemy
+
+class UnchainedDoombringerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(UnchainedDoombringerAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    UnchainedDoombringerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(AGONIZING_ARMOR);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 9.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(WAR_STOMP);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 12.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(BERSEKER_CHARGE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Warder CorpseAI
+
+#define CN_WARDER_CORPSE 21303
+
+#define CORPSE_BURST_WC 36593
+#define BLOODY_EXPLOSION_WC 36599
+//#define PERMANENT_FEIGN_DEATH_ROOT_WC 31261	// I don't have much infos and I am not sure about how it should work
+												// I presume this is just corpse which should cast spell when player is close or attk it
+												// so same situation like in Defender Corpse
+class WarderCorpseAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(WarderCorpseAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    WarderCorpseAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(CORPSE_BURST_WC);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(BLOODY_EXPLOSION_WC);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[1].info, spells[1].instant);
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Sargeron ArcherAI
+
+#define CN_SARGERON_ARCHER 20901
+
+#define FROST_ARROW	35964 //DBC: 35965, 35964;
+#define SHOT_SA 22907
+#define RAPID_FIRE 36828
+#define SCATTER_SHOT 23601
+#define HOOKED_NET 36827
+#define IMMOLATION_ARROW 35932	// DBC: 35932, 35935
+
+class SargeronArcherAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SargeronArcherAI);
+	SP_AI_Spell spells[6];
+	bool m_spellcheck[6];
+
+    SargeronArcherAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 6;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FROST_ARROW);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SHOT_SA);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(RAPID_FIRE);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(SCATTER_SHOT);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(HOOKED_NET);
+		spells[4].targettype = TARGET_VARIOUS;
+		spells[4].instant = false;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 6.0f;
+		spells[4].attackstoptimer = 1000;
+
+		spells[5].info = dbcSpell.LookupEntry(IMMOLATION_ARROW);
+		spells[5].targettype = TARGET_ATTACKING;
+		spells[5].instant = false;
+		spells[5].cooldown = -1;
+		spells[5].perctrigger = 0.0f;
+		spells[5].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		if (_unit->GetAIInterface()->GetNextTarget())
+		{
+			Unit *target = NULL;
+			target = _unit->GetAIInterface()->GetNextTarget();
+			if (_unit->GetDistance2dSq(target) >= 100.0f && _unit->GetDistanceSq(target) <= 900.0f)
+			{
+				_unit->GetAIInterface()->m_canMove = false;
+				int RangedSpell;
+				sRand.randInt(1000);
+				RangedSpell=rand()%100;
+				if (RangedSpell >= 0 && RangedSpell <= 13)
+				{
+					_unit->CastSpell(target, spells[0].info, spells[0].instant);
+					_unit->setAttackTimer(spells[0].attackstoptimer, false);
+				}
+
+				if (RangedSpell > 12 && RangedSpell <= 25)
+				{
+					_unit->CastSpell(target, spells[3].info, spells[3].instant);
+					_unit->setAttackTimer(spells[3].attackstoptimer, false);
+				}
+
+				if (RangedSpell > 25 && RangedSpell <= 38)
+				{
+					_unit->CastSpell(target, spells[5].info, spells[5].instant);
+					_unit->setAttackTimer(spells[5].attackstoptimer, false);
+				}
+
+				if (RangedSpell > 38 && RangedSpell <= 44)
+				{
+					_unit->CastSpell(target, spells[2].info, spells[2].instant);
+					_unit->setAttackTimer(spells[2].attackstoptimer, false);
+				}
+
+				if (RangedSpell > 44 && RangedSpell <= 50)
+				{
+					_unit->CastSpell(target, spells[4].info, spells[4].instant);
+					_unit->setAttackTimer(spells[4].attackstoptimer, false);
+				}
+
+				else
+				{
+					_unit->CastSpell(target, spells[1].info, spells[1].instant);
+					_unit->setAttackTimer(spells[1].attackstoptimer, false);
+				}
+			}
+
+			else
+			{
+				_unit->GetAIInterface()->m_canMove = true;
+				if (_unit->GetDistance2dSq(target) < 100.0f)
+				{
+					float val = sRand.rand(100.0f);
+					SpellCast(val);
+				}
+			}
+		}
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())	// I was too lazy to rewrite it =S
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+/*****************************/
+/*                           */
+/*         Boss AIs          */
+/*                           */
+/*****************************/
+
+// Zereketh the UnboundAI
+
+#define CN_ZEREKETH_THE_UNBOUND 20870	
+
+#define SEED_OF_CORRUPTION 36123	//32865, 36123
+#define SHADOW_NOVA	36127 // 30533, 39005, 36127 (normal mode), 39005 (heroic mode?)
+#define VOID_ZONE 36119	// DBC: 36119; it's not fully functionl without additional core support (for dmg and random place targeting).
+
+class ZerekethTheUnboundAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(ZerekethTheUnboundAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    ZerekethTheUnboundAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(SEED_OF_CORRUPTION);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 6.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SHADOW_NOVA);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(VOID_ZONE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = false;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 9.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Life energy to... consume.");
+		_unit->PlaySoundToSet(11250);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "This vessel...is empty.");
+				_unit->PlaySoundToSet(11251);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "No... more... life.");	// not sure
+				_unit->PlaySoundToSet(11252);
+				break;
+			}
+		}
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "The Void... beckons.");
+		_unit->PlaySoundToSet(11255);
+    }
+
+    void AIUpdate()
+	{
+		int RandomSpeach;
+		RandomSpeach=rand()%100;	// 2% chance to say sth (no idea if this is right as names "TEMPEST_Zerek_ShadowHell01/02" tell me nothing =/
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "The shadow... will <missing_word> you.");	// missing word! =(
+			_unit->PlaySoundToSet(11253);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Darkness... consumes all.");	// verification needed
+			_unit->PlaySoundToSet(11254);
+			break;
+		}
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Dalliah the DoomsayerAI
+
+#define CN_DALLIAH_THE_DOOMSAYER 20885	
+
+#define GIFT_OF_THE_DOOMSAYER 36173 // DBC: 36173
+#define WHIRLWIND 36175	// DBC: 36142, 36175
+#define HEAL 36144
+#define SHADOW_WAVE 39016	// Heroic mode spell
+// sounds missing related to Wrath... (look on script below this one)
+
+class DalliahTheDoomsayerAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(DalliahTheDoomsayerAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    DalliahTheDoomsayerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(GIFT_OF_THE_DOOMSAYER);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(WHIRLWIND);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = false;
+		spells[1].cooldown = 10;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(HEAL);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = false;
+		spells[2].cooldown = 10;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(SHADOW_WAVE);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = false;
+		spells[3].cooldown = 10;
+		spells[3].perctrigger = 8.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "It is unwise to anger me.");	// verification needed
+		_unit->PlaySoundToSet(11086);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)
+		{
+			int RandomSpeach;
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Completely ineffective! Just like someone else I know!");	// need verif.
+				_unit->PlaySoundToSet(11087);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You choosed the wrong opponenet!");	// verification needed
+				_unit->PlaySoundToSet(11088);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Now I'm really angry...");	// verification needed
+		_unit->PlaySoundToSet(11093);
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void HealSound()
+	{
+		int RandomSpeach;
+		RandomSpeach=rand()%20;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "That is much better.");
+			_unit->PlaySoundToSet(11091);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Ah, just what I needed.");	// both need verif.
+			_unit->PlaySoundToSet(11092);
+			break;
+		}
+	}
+
+	void WhirlwindSound()
+	{
+		int RandomWhirlwind;
+		RandomWhirlwind=rand()%20;
+		switch (RandomWhirlwind)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Rip the Whirlwind!");
+			_unit->PlaySoundToSet(11089);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I'll cut you to pices!");	// all to verification
+			_unit->PlaySoundToSet(11090);
+			break;
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{		
+					if (m_spellcheck[2] == true)
+						HealSound();
+
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (m_spellcheck[1] == true)
+					{
+						WhirlwindSound();
+						int NextAttack;
+						NextAttack=rand()%100+1;
+						if (NextAttack <= 25 && NextAttack > 0)
+						{
+							m_spellcheck[2] = true;
+						}
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Wrath-Scryer SoccothratesAI
+
+#define CN_WRATH_SCRYER_SOCCOTHRATES 20886	
+
+#define IMMOLATION 35959 // DBC: 36051, 35959
+#define FELFIRE_SHOCK 35759
+#define FELFIRE_LINE_UP 35770	// ?
+#define KNOCK_AWAY 20686 // DBC: 36512; but it uses it on himself too so changed to other
+#define CHARGE 35754 // DBC: 36058, 35754 =( =(
+// CHARGE_TARGETING 36038 ?
+// There are more sounds connected with Dalliah and some spells, but I don't know situation in which they are used
+// so haven't added them.
+
+class WrathScryerSoccothratesAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(WrathScryerSoccothratesAI);
+	SP_AI_Spell spells[5];
+	bool m_spellcheck[5];
+
+    WrathScryerSoccothratesAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+
+		nrspells = 5;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(IMMOLATION);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(FELFIRE_SHOCK);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 10;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(FELFIRE_LINE_UP);	// ?
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = 10;
+		spells[2].perctrigger = 8.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(KNOCK_AWAY);
+		spells[3].targettype = TARGET_DESTINATION;	// changed from VARIOUS to prevent crashes and gives it at least half working spell
+		spells[3].instant = true;
+		spells[3].cooldown = 10;
+		spells[3].perctrigger = 6.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(CHARGE);
+		spells[4].targettype = TARGET_ATTACKING;
+		spells[4].instant = true;
+		spells[4].cooldown = 10;
+		spells[4].perctrigger = 4.0f;
+		spells[4].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "At least target for my frustration!");	// verification needed
+		_unit->PlaySoundToSet(11238);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)
+		{
+			int RandomSpeach;
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Yes, that was quiet... satisfied.");	// need verif.
+				_unit->PlaySoundToSet(11239);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Ha! Much better!");	// verification needed
+				_unit->PlaySoundToSet(11240);
+				break;
+			}		
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "<missing_text>");	// verification needed
+		_unit->PlaySoundToSet(11243);
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Harbinger SkyrissAI
+
+#define CN_HARBRINGER_SKYRISS 20912	
+
+#define MIND_REND 36924 // DBC: 36859, 36924;
+#define FEAR 39415
+#define DOMINATION 37162
+#define SUMMON_ILLUSION_66 36931	// those 2 don't work
+#define SUMMON_ILLUSION_33 36932
+// BLINK_VISUAL 36937 ?
+// SIMPLE_TELEPORT 12980 ?
+// Add sounds related to his dialog with mind controlled guy
+
+class HarbringerSkyrissAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(HarbringerSkyrissAI);
+	SP_AI_Spell spells[5];
+	bool m_spellcheck[5];
+
+    HarbringerSkyrissAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+
+		IllusionCount = 0;
+		nrspells = 5;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(MIND_REND);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 15.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(FEAR);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(DOMINATION);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = false;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(SUMMON_ILLUSION_66);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(SUMMON_ILLUSION_33);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		IllusionCount = 0;
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Bear witness to the agent of your demise!");	// used when he kills Warden Mellichar
+		_unit->PlaySoundToSet(11123);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)
+		{
+			int RandomSpeach;
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your fate is written!");	// this one needs verification
+				_unit->PlaySoundToSet(11124);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "The chaos I have sown here is but a taste....");
+				_unit->PlaySoundToSet(11125);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		IllusionCount = 0;
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		IllusionCount = 0;
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I am merely one of... infinite multitudes.");
+		_unit->PlaySoundToSet(11126);
+    }
+
+    void AIUpdate()
+	{
+		if (_unit->GetHealthPct() <= 66 && !IllusionCount)
+		{
+			IllusionCount = 1;
+			_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+			//_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "We span the universe, as countless as the stars!");
+			_unit->PlaySoundToSet(11131);	// Idk if those texts shouldn't be told by clones and by org. so disabled MSG to make it harder to detect =P
+		}
+
+		if (_unit->GetHealthPct() <= 33 && IllusionCount == 1)
+		{
+			IllusionCount = 2;
+			_unit->CastSpell(_unit, spells[4].info, spells[4].instant);
+			//_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "We span the universe, as countless as the stars!");
+			_unit->PlaySoundToSet(11131);
+		}
+		
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+    }
+
+	void FearSound()
+	{
+		int RandomFear;
+		RandomFear=rand()%4;
+		switch (RandomFear)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Flee in terror.");
+			_unit->PlaySoundToSet(11129);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I will show you horrors undreamed of.");
+			_unit->PlaySoundToSet(11130);
+			break;
+		}
+	}
+
+	void DominationSound()
+	{
+		int RandomDomination;
+		RandomDomination=rand()%4;
+		switch (RandomDomination)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You will do my bidding, weakling.");
+			_unit->PlaySoundToSet(11127);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your will is no longer your own.");
+			_unit->PlaySoundToSet(11128);
+			break;
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					if (m_spellcheck[1] == true)
+					{
+						FearSound();
+					}
+
+					if (m_spellcheck[2] == true)
+					{
+						DominationSound();
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	uint32 IllusionCount;
+	int nrspells;
+};
+/*
+// Warden MellicharAI	// he is EVENT STARTER and needs some more time I don't have atm =(
+
+#define CN_WARDEN_MELLICHAR 20904	
+
+#define 
+
+class WardenMellicharAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(WardenMellicharAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    WardenMellicharAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry();
+		spells[0].targettype = TARGET_;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "");
+		_unit->PlaySoundToSet();
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		int RandomSpeach;
+		RandomSpeach=rand()%2;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "");
+			_unit->PlaySoundToSet();
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "");
+			_unit->PlaySoundToSet();
+			break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "");
+		_unit->PlaySoundToSet();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+*/
+void SetupArcatraz(ScriptMgr * mgr)
+{
+
+	mgr->register_creature_script(CN_ARCATRAZ_DEFENDER, &ArcatrazDefenderAI::Create);
+	mgr->register_creature_script(CN_ARCATRAZ_SENTINEL, &ArcatrazSentinelAI::Create);
+	mgr->register_creature_script(CN_ARCATRAZ_WARDER, &ArcatrazWarderAI::Create);
+	mgr->register_creature_script(CN_BLACKWING_DRAKONAAR, &BlackwingDrakonaarAI::Create);
+	mgr->register_creature_script(CN_BLACKWING_TRICKSTER, &BlackwingTricksterAI::Create);
+	mgr->register_creature_script(CN_DEATH_WATCHER, &DeathWatcherAI::Create);
+	mgr->register_creature_script(CN_DEFENDER_CORPSE, &DefenderCorpseAI::Create);
+	mgr->register_creature_script(CN_PROTEAN_SPAWN, &ProteanSpawnAI::Create);
+	mgr->register_creature_script(CN_ENTROPIC_EYE, &EntropicEyeAI::Create);
+	mgr->register_creature_script(CN_EREDAR_DEATHBRINGER, &EredarDeathbringerAI::Create);
+	mgr->register_creature_script(CN_EREDAR_SOUL_EATER, &EredarSoulEaterAI::Create);
+	mgr->register_creature_script(CN_ETHEREUM_LIFE_BINDER, &EthereumLifeBinderAI::Create);
+	mgr->register_creature_script(CN_ETHEREUM_SLAYER, &EthereumSlayerAI::Create);
+	mgr->register_creature_script(CN_ETHEREUM_WAVE_CASTER, &EthereumWaveCasterAI::Create);
+	mgr->register_creature_script(CN_GARGANTUAN_ABYSSAL, &GargantuanAbyssalAI::Create);
+	mgr->register_creature_script(CN_GREATER_FIRE_ELEMENTAL, &GreaterFireElementalAI::Create);
+	mgr->register_creature_script(CN_IRONJAW, &IronjawAI::Create);
+	mgr->register_creature_script(CN_MILLHOUSE_MANASTORM, &MillhouseManastormAI::Create);
+	mgr->register_creature_script(CN_NEGATON_SCREAMER, &NegatonScreamerAI::Create);
+	mgr->register_creature_script(CN_NEGATON_WARP_MASTER, &NegatonWarpMasterAI::Create);
+	mgr->register_creature_script(CN_NEGATON_FIELD, &NegatonFieldAI::Create);
+	mgr->register_creature_script(CN_PHASE_HUNTER, &PhaseHunterAI::Create);
+	mgr->register_creature_script(CN_PROTEAN_HORROR, &ProteanHorrorAI::Create);
+	mgr->register_creature_script(CN_PROTEAN_NIGHTMARE, &ProteanNightmareAI::Create);
+
+	mgr->register_creature_script(CN_SULFURON_MAGMA_THROWER, &SulfuronMagmaThrowerAI::Create);
+	mgr->register_creature_script(CN_SPITEFUL_TEMPTRESS, &SpitefulTemptressAI::Create);
+	mgr->register_creature_script(CN_SOUL_DEVOURER, &SoulDevourerAI::Create);
+	mgr->register_creature_script(CN_SOLOMON, &SolomonAI::Create);
+	mgr->register_creature_script(CN_SKULKING_WITCH, &SkulkingWitchAI::Create);
+	mgr->register_creature_script(CN_SIGHTLESS_EYE, &SightlessEyeAI::Create);
+	mgr->register_creature_script(CN_SARGERON_HELLCALLER, &SargeronHellcallerAI::Create);
+	mgr->register_creature_script(CN_UNBOUND_DEVASTATOR, &UnboundDevastatorAI::Create);
+	mgr->register_creature_script(CN_UNCHAINED_DOOMBRINGER, &UnchainedDoombringerAI::Create);
+	mgr->register_creature_script(CN_WARDER_CORPSE, &WarderCorpseAI::Create);
+	mgr->register_creature_script(CN_SARGERON_ARCHER, &SargeronArcherAI::Create);
+
+	mgr->register_creature_script(CN_ZEREKETH_THE_UNBOUND, &ZerekethTheUnboundAI::Create);
+	mgr->register_creature_script(CN_DALLIAH_THE_DOOMSAYER, &DalliahTheDoomsayerAI::Create);
+	mgr->register_creature_script(CN_WRATH_SCRYER_SOCCOTHRATES, &WrathScryerSoccothratesAI::Create);
+	mgr->register_creature_script(CN_HARBRINGER_SKYRISS, &HarbringerSkyrissAI::Create);
+	//mgr->register_creature_script(CN_WARDEN_MELLICHAR, &WardenMellicharAI::Create);
+}
+
+// Note: Don't have infos about: Akkiris Lightning-Waker, Nathan, Third Fragment Guardian, Udalo, Whisper and 
+// Twilight Drakonaar; some of those mobs aren't aggresive.
+//
+
Index: src/InstanceScripts/Instance_BloodFurnace.cpp
===================================================================
--- src/InstanceScripts/Instance_BloodFurnace.cpp	(revision 0)
+++ src/InstanceScripts/Instance_BloodFurnace.cpp	(revision 0)
@@ -0,0 +1,2951 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+/************************************************************************/
+/* Instance_BloodFurnace.cpp Script		                                */
+/************************************************************************/
+
+// Shadowmoon WarlockAI
+
+#define CN_BILL 19621	// B.O.O.M. Fire Marshal
+
+#define FROST_NOVA 34326	// it uses visual only spells :O
+#define LIQUID_BLAST_VISUAL 37993
+
+class BILLAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BILLAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    BILLAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FROST_NOVA);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(LIQUID_BLAST_VISUAL);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = false;
+		spells[1].cooldown = 10;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Shadowmoon WarlockAI
+
+#define CN_SHADOWMOON_WARLOCK 17371
+
+#define SHADOW_BOLT 12739
+#define CURSE_OF_TONGUES 13338
+#define CORRUPTION_WARLOCK 32197
+#define FEL_POWER 33111 // not sure to these ones (as always :P)
+#define DAZED_WARLOCK 1604
+
+class SHADOWMOONWARLOCKAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SHADOWMOONWARLOCKAI);
+	SP_AI_Spell spells[5];
+	bool m_spellcheck[5];
+
+    SHADOWMOONWARLOCKAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 5;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SHADOW_BOLT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(CURSE_OF_TONGUES);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(FEL_POWER);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = false;
+		spells[2].cooldown = 55;
+		spells[2].perctrigger = 0;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(CORRUPTION_WARLOCK);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = 45;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+        spells[4].info = dbcSpell.LookupEntry(DAZED_WARLOCK);
+		spells[4].targettype = TARGET_ATTACKING;
+		spells[4].instant = true;
+		spells[4].cooldown = 15;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Shadowmoon TechnicianAI
+
+#define CN_SHADOWMOON_TECHNICIAN 17414
+
+#define THROW_DYNAMITE 7978
+#define THROW_PROXIMITY_BOMB 30846	// lack of core support =(
+#define SILENCE 6726				// those spell must be checked (as I am not sure if it uses all those)
+#define DAZED_TECHNICIAN 1604
+
+class SHADOWMOONTECHNICIANAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SHADOWMOONTECHNICIANAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SHADOWMOONTECHNICIANAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(THROW_DYNAMITE);
+		spells[0].targettype = TARGET_DESTINATION;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(THROW_PROXIMITY_BOMB);
+		spells[1].targettype = TARGET_DESTINATION;	// doesn't work
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(SILENCE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 35;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(DAZED_TECHNICIAN);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = 15;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Shadowmoon SummonerAI
+
+#define CN_SHADOWMOON_SUMMONER 17395
+
+#define SUMMON_SEDUCTRESS 30853
+#define FLAMESTRIKE 18399	// not sure to spells which weren't made to summon creatures
+#define FIREBALL 15242
+#define SUMMON_FELHOUND_MANASTALKER 30851
+
+class SHADOWMOONSUMMONERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SHADOWMOONSUMMONERAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SHADOWMOONSUMMONERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SUMMON_SEDUCTRESS);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = false;
+		spells[0].cooldown = 20;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(FLAMESTRIKE);
+		spells[1].targettype = TARGET_DESTINATION;
+		spells[1].instant = false;
+		spells[1].cooldown = 15;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(FIREBALL);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = false;
+		spells[2].cooldown = 10;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(SUMMON_FELHOUND_MANASTALKER);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = false;
+		spells[3].cooldown = 25;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Shadowmoon ChannelerAI
+
+#define CN_SHADOWMOON_CHANNELER 17653
+
+#define MARK_OF_SHADOW 30937	// wth it isn't casted by mob and work when used by player :| ?
+#define SHADOW_BOLT_SUMMONER 12739
+#define DAZED_SUMMONER 1604
+#define STAR_BEAM 30888	// W00T? MUST CHECK IT MORE IN DBC (Idk have more infos about 
+						// this spell, so can't do nothing more for now [also lack of 
+						// core support?])
+
+class SHADOWMOONCHANNELERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SHADOWMOONCHANNELERAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SHADOWMOONCHANNELERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(MARK_OF_SHADOW);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 55;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SHADOW_BOLT_SUMMONER);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = 10;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_SUMMONER);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(STAR_BEAM);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = false;
+		spells[3].cooldown = 45;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Shadowmoon AdeptAI
+
+#define CN_SHADOWMOON_ADEPT 17397
+
+#define TRASH 3391 // ? doesn't work coz lack of core support?
+#define KICK 11978
+#define DAZED_ADEPT 1604 // not sure to any spell of these :S
+
+class SHADOWMOONADEPTAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SHADOWMOONADEPTAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    SHADOWMOONADEPTAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(TRASH);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = 35;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(KICK);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_ADEPT);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// SeductressAI
+
+#define CN_SEDUCTRESS 17399
+
+#define SEDUCTION 31865
+#define LASH_OF_PAIN 32202
+
+class SEDUCTRESSAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SEDUCTRESSAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    SEDUCTRESSAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SEDUCTION);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(LASH_OF_PAIN);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 10;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Nascent Fel OrcAI
+
+#define CN_NASCENT_FEL_ORC 17398
+
+#define STOMP 31900
+#define CONCUSSION_BLOW 22427
+#define DAZED_NASCENT_FEL_ORC 1604
+
+class NASCENTFELORCAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(NASCENTFELORCAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    NASCENTFELORCAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(STOMP);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 35;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(CONCUSSION_BLOW);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 20;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_NASCENT_FEL_ORC);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Hellfire ImpAI
+
+#define CN_HELLFIRE_IMP 17477
+
+#define FIREBALL 15242
+#define SUMMON_VISUAL_TEST 35766 // hmm... ?	Idk if this shouldn't been activated OnCombatStart
+#define FIRE_BLAST 15574 // there wasn't any in DBC so I added one I thought can be accurate =(
+
+class HELLFIREIMPAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(HELLFIREIMPAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    HELLFIREIMPAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FIREBALL);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SUMMON_VISUAL_TEST);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(FIRE_BLAST);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Hellfire FamiliarAI
+
+#define CN_HELLFIRE_FAMILIAR 19016
+
+#define FIREBALL_FAMILIAR 11921
+#define DAZED_FAMILIAR 1604
+
+class HELLFIREFAMILIARAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(HELLFIREFAMILIARAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    HELLFIREFAMILIARAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FIREBALL_FAMILIAR);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(DAZED_FAMILIAR);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 15;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Felhound ManastalkerAI
+
+#define CN_FELHOUND_MANASTALKER 17401
+
+#define MANA_BURN 13321
+#define SPELL_LOCK 30849
+
+class FELHOUNDMANASTALKERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(FELHOUNDMANASTALKERAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    FELHOUNDMANASTALKERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(MANA_BURN);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SPELL_LOCK);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Felguard BruteAI
+
+#define CN_FELGUARD_BRUTE 18894
+
+#define UPPERCUT 18072
+#define PUMMEL 15615
+#define DAZED_FELGUARD_BRUTE 1604
+
+class FELGUARDBRUTEAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(FELGUARDBRUTEAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    FELGUARDBRUTEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(UPPERCUT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(PUMMEL);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 20;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_FELGUARD_BRUTE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Felguard AnnihilatorAI
+
+#define CN_FELGUARD_ANNIHILATOR 17400
+
+#define UPPERCUT 18072
+#define PUMMEL 15615
+#define DAZED_FELGUARD_ANNIHILATOR 1604
+#define INTERCEPT 27577 //DBC: 20615, 27577, 27826
+
+class FELGUARDANNIHILATORAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(FELGUARDANNIHILATORAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    FELGUARDANNIHILATORAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(UPPERCUT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(PUMMEL);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 20;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_FELGUARD_ANNIHILATOR);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(INTERCEPT);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = 35;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Fel Orc NeophyteAI
+
+#define CN_FEL_ORC_NEOPHYTE 17429
+
+#define ENRAGE 8269
+#define CHARGE 22120
+#define DAZED_NEOPHYTE 1604
+
+class FELORCNEOPHYTEAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(FELORCNEOPHYTEAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    FELORCNEOPHYTEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ENRAGE);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = 80;	// hmm...
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(CHARGE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_NEOPHYTE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Laughing Skull WardenAI
+
+#define CN_LAUGHING_SKULL_WARDEN 17624
+
+#define BATTLE_SHOUT 30833
+#define DAZED_WARDEN 1604
+
+class LAUGHINGSKULLWARDENAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(LAUGHINGSKULLWARDENAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    LAUGHINGSKULLWARDENAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(BATTLE_SHOUT);
+		spells[0].targettype = TARGET_VARIOUS;	// Should affect mobs friendly to this one (not player :S)
+		spells[0].instant = true;
+		spells[0].cooldown = 70;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(DAZED_WARDEN);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 15;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Laughing Skull RogueAI
+
+#define CN_LAUGHING_SKULL_ROGUE 17491
+
+#define POISON 34969
+#define KIDNEY_SHOT 30832
+#define DAZED_ROGUE 1604
+#define SLICE_AND_DICE 6434
+#define STEALTH 30831
+
+class LAUGHINGSKULLROGUEAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(LAUGHINGSKULLROGUEAI);
+	SP_AI_Spell spells[5];
+	bool m_spellcheck[5];
+
+    LAUGHINGSKULLROGUEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		FIRST_ATTACK = 1;
+		nrspells = 5;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(POISON);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 40;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(KIDNEY_SHOT);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_ROGUE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(SLICE_AND_DICE);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = 70;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+        spells[4].info = dbcSpell.LookupEntry(STEALTH);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+
+		_unit->CastSpell(_unit, spells[4].info, spells[4].instant);
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		FIRST_ATTACK = 1;
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		FIRST_ATTACK = 1;
+		_unit->CastSpell(_unit, spells[4].info, spells[4].instant);
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		FIRST_ATTACK = 1;
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		if (FIRST_ATTACK && _unit->GetAIInterface()->GetNextTarget())
+		{
+			FIRST_ATTACK = 0;
+			Unit *target = NULL;
+			target = _unit->GetAIInterface()->GetNextTarget();
+			_unit->CastSpell(target, spells[1].info, spells[1].instant);
+		}
+
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int FIRST_ATTACK;
+	int nrspells;
+};
+
+// Laughing Skull LegionnaireAI
+
+#define CN_LAUGHING_SKULL_LEGIONNAIRE 17626
+
+#define ENRAGE_LEGIONNAIRE 8599
+#define UPPERCUT_LEGIONNAIRE 10966
+#define SWEEPING_STRIKES 18765	// DBC: 18765, 12723
+#define DAZED_LEGIONNAIRE 1604
+
+class LAUGHINGSKULLLEGIONNAIREAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(LAUGHINGSKULLLEGIONNAIREAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    LAUGHINGSKULLLEGIONNAIREAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ENRAGE_LEGIONNAIRE);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = 70;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(UPPERCUT_LEGIONNAIRE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(SWEEPING_STRIKES);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = 50;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(DAZED_LEGIONNAIRE);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = 15;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Laughing Skull EnforcerAI
+
+#define CN_LAUGHING_SKULL_ENFORCER 17370
+
+#define STRIKE 14516
+#define SHIELD_SLAM 30688
+#define DAZED_ENFORCER 1604
+
+class LAUGHINGSKULLENFORCERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(LAUGHINGSKULLENFORCERAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    LAUGHINGSKULLENFORCERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(STRIKE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SHIELD_SLAM);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_ENFORCER);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+/*****************************/
+/*                           */
+/*         Boss AIs          */
+/*                           */
+/*****************************/
+
+// Keli'dan the BreakerAI
+
+#define CN_KELIDAN_THE_BREAKER 17377
+
+#define SHADOW_BOLT_VOLLEY 30510 // DBC: 17228; 38840/29924/40070/30510/30354 //CONE_SHADOW_BOLTS 
+#define BLAST_WAVE 30600 // DBC: 33775; 39038 or 30600
+#define CORRUPTION 30938
+
+class KELIDANTHEBREAKERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(KELIDANTHEBREAKERAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    KELIDANTHEBREAKERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SHADOW_BOLT_VOLLEY);
+		spells[0].targettype = TARGET_DESTINATION;
+		spells[0].instant = false;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(BLAST_WAVE);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = false;
+		spells[1].cooldown = 30;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+		spells[1].speech = "Closer... Come closer... And burn!";
+		spells[1].soundid = 10165;
+
+        spells[2].info = dbcSpell.LookupEntry(CORRUPTION);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 45;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%3;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You mustn't let him loose!");
+			_unit->PlaySoundToSet(10166);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Ignorant whelps!");
+			_unit->PlaySoundToSet(10167);
+			break;
+		case 2:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You fools, he'll kill us all!");
+			_unit->PlaySoundToSet(10168);
+			break;
+		}
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Just as you deserve.");
+				_unit->PlaySoundToSet(10169);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your friends, will soon be joining you.");
+				_unit->PlaySoundToSet(10170);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Good luck... You'll need it.");
+		_unit->PlaySoundToSet(10171);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// BroggokAI
+
+#define CN_BROGGOK 17380
+
+#define POISON_BOLT 30917
+#define POISON_CLOUD 31259 // DBC: 30916; no idea if correct
+#define SLIME_SPRAY 30913
+
+class BROGGOKAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BROGGOKAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    BROGGOKAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(POISON_BOLT);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(POISON_CLOUD);
+		spells[1].targettype = TARGET_DESTINATION;
+		spells[1].instant = true;
+		spells[1].cooldown = 70;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(SLIME_SPRAY);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = 25;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+	}
+
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// The MakerAI
+
+#define CN_THE_MAKER 17381
+
+#define DOMINATION 30923 // 36866
+#define ACID_SPRAY 38973 // 38973 or 38153	// not sure about casting of this
+#define KNOCKDOWN 38576 // 38576 or 37317	// and this spell
+#define EXPLODING_BEAKER 30925 // Throw beaker <--- maybe this is it?
+
+class THEMAKERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(THEMAKERAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    THEMAKERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(DOMINATION);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 50;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(ACID_SPRAY);
+		spells[1].targettype = TARGET_VARIOUS; // maybe that?
+		spells[1].instant = true;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(KNOCKDOWN);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = 25;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(EXPLODING_BEAKER);
+		spells[3].targettype = TARGET_DESTINATION;
+		spells[3].instant = true;
+		spells[3].cooldown = 15;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%3;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "My work must not be interrupted.");
+			_unit->PlaySoundToSet(10286);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Perhaps I can find a use for you.");
+			_unit->PlaySoundToSet(10287);
+			break;
+		case 2:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Anger... Hate... These are tools I can use.");
+			_unit->PlaySoundToSet(10288);
+			break;
+		}
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Let's see what I can make of you.");
+				_unit->PlaySoundToSet(10289);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "It is pointless to resist.");
+				_unit->PlaySoundToSet(10290);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Stay away from... me.");
+		_unit->PlaySoundToSet(10291);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+void SetupBloodFurnace(ScriptMgr * mgr)
+{
+	mgr->register_creature_script(CN_BILL, &BILLAI::Create);
+	mgr->register_creature_script(CN_SEDUCTRESS, &SEDUCTRESSAI::Create);
+	mgr->register_creature_script(CN_NASCENT_FEL_ORC, &NASCENTFELORCAI::Create);
+	mgr->register_creature_script(CN_LAUGHING_SKULL_WARDEN, &LAUGHINGSKULLWARDENAI::Create);
+	mgr->register_creature_script(CN_LAUGHING_SKULL_ROGUE, &LAUGHINGSKULLROGUEAI::Create);
+	mgr->register_creature_script(CN_LAUGHING_SKULL_LEGIONNAIRE, &LAUGHINGSKULLLEGIONNAIREAI::Create);
+	mgr->register_creature_script(CN_LAUGHING_SKULL_ENFORCER, &LAUGHINGSKULLENFORCERAI::Create);
+	mgr->register_creature_script(CN_HELLFIRE_IMP, &HELLFIREIMPAI::Create);
+	mgr->register_creature_script(CN_HELLFIRE_FAMILIAR, &HELLFIREFAMILIARAI::Create);
+	mgr->register_creature_script(CN_FELHOUND_MANASTALKER, &FELHOUNDMANASTALKERAI::Create);
+	mgr->register_creature_script(CN_FELGUARD_BRUTE, &FELGUARDBRUTEAI::Create);
+	mgr->register_creature_script(CN_FELGUARD_ANNIHILATOR, &FELGUARDANNIHILATORAI::Create);
+	mgr->register_creature_script(CN_FEL_ORC_NEOPHYTE, &FELORCNEOPHYTEAI::Create);
+	mgr->register_creature_script(CN_SHADOWMOON_WARLOCK, &SHADOWMOONWARLOCKAI::Create);
+	mgr->register_creature_script(CN_SHADOWMOON_TECHNICIAN, &SHADOWMOONTECHNICIANAI::Create);
+	mgr->register_creature_script(CN_SHADOWMOON_SUMMONER, &SHADOWMOONSUMMONERAI::Create);
+	mgr->register_creature_script(CN_SHADOWMOON_CHANNELER, &SHADOWMOONCHANNELERAI::Create);
+	mgr->register_creature_script(CN_SHADOWMOON_ADEPT, &SHADOWMOONADEPTAI::Create);
+	mgr->register_creature_script(CN_KELIDAN_THE_BREAKER, &KELIDANTHEBREAKERAI::Create);
+	mgr->register_creature_script(CN_BROGGOK, &BROGGOKAI::Create);
+	mgr->register_creature_script(CN_THE_MAKER, &THEMAKERAI::Create);
+}
+
+// No info about spells: Orc Captive (17416), Emeriss (14889)
+// No idea if I should script NPC Bill (19621) as he has 2 spell with visual effects only
Index: src/InstanceScripts/Instance_HellfireRamparts.cpp
===================================================================
--- src/InstanceScripts/Instance_HellfireRamparts.cpp	(revision 0)
+++ src/InstanceScripts/Instance_HellfireRamparts.cpp	(revision 0)
@@ -0,0 +1,2607 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+/************************************************************************/
+/* Instance_HellfireRamparts.cpp Script		                            */
+/************************************************************************/
+
+// Bleeding Hollow ArcherAI
+
+#define CN_BLEEDING_HOLLOW_ARCHER 17270
+
+#define MULTI_SHOT 18651
+#define AIMED_SHOT 30614
+#define DAZED 1604
+
+class BLEEDINGHOLLOWARCHERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BLEEDINGHOLLOWARCHERAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    BLEEDINGHOLLOWARCHERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(MULTI_SHOT);
+		spells[0].targettype = TARGET_ATTACKING;	// changed from VARIOUS to prevent crashes when caster kills itself by using this ability on low hp
+		spells[0].instant = true;
+		spells[0].cooldown = 35;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(AIMED_SHOT);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bleeding Hollow DarkcasterAI
+
+#define CN_BLEEDING_HOLLOW_DARKCASTER 17269
+
+#define SCORCH 36807	// DBC: 15241 // not sure
+#define RAIN_OF_FIRE 36808	// DBC: 20754 same here
+
+class BLEEDINGHOLLOWDARKCASTERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BLEEDINGHOLLOWDARKCASTERAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    BLEEDINGHOLLOWDARKCASTERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+        spells[0].info = dbcSpell.LookupEntry(SCORCH);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 13;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(RAIN_OF_FIRE);
+		spells[1].targettype = TARGET_DESTINATION;
+		spells[1].instant = false;
+		spells[1].cooldown = 30;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bleeding Hollow ScryerAI
+
+#define CN_BLEEDING_HOLLOW_SCRYER 17478
+
+#define FEAR 30615
+#define SHADOW_BOLT_SCRYER 12471 // not sure to those two
+#define FEL_INFUSION 30659 // not sure if it's using it
+
+class BLEEDINGHOLLOWSCRYERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BLEEDINGHOLLOWSCRYERAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    BLEEDINGHOLLOWSCRYERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(FEAR);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 35;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SHADOW_BOLT_SCRYER);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = 10;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(FEL_INFUSION);
+		spells[2].targettype = TARGET_VARIOUS;	// why it targets enemy :O
+		spells[2].instant = true;
+		spells[2].cooldown = 25;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bonechewer BeastmasterAI
+
+#define CN_BONECHEWER_BEASTMASTER 17455
+
+#define BATTLE_SHOUT 30635
+#define UPPERCUT 10966		// not sure to any spell
+#define DAZED_BEASTMASTER 1604
+// in a certain ammount of time he calls in about 2-4 more dogs.
+class BONECHEWERBEASTMASTERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BONECHEWERBEASTMASTERAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    BONECHEWERBEASTMASTERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(BATTLE_SHOUT);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = 45;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(UPPERCUT);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = 30;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DAZED_BEASTMASTER);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bonechewer DestroyerAI
+
+#define CN_BONECHEWER_DESTROYER 17271
+
+#define MORTAL_STRIKE 15708
+#define KNOCK_AWAY 10101
+#define SWEEPING_STRIKES 18765	// 12723
+#define DAZED_DESTROYER 1604 // it's same everywhere, but I will keep it separated as they are connected with diff creatures
+
+class BONECHEWERDESTROYERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BONECHEWERDESTROYERAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    BONECHEWERDESTROYERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(MORTAL_STRIKE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 20;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(KNOCK_AWAY);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(SWEEPING_STRIKES);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = 40;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(DAZED_DESTROYER);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = 15;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bonechewer HungererAI
+
+#define CN_BONECHEWER_HUNGERER 17259
+
+#define DEMORALIZING_SHOUT 16244
+#define STRIKE 14516
+#define DISARM 6713	// no idea if those are correct spells
+#define DAZED_HUNGERER 1604
+
+class BONECHEWERHUNGERERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BONECHEWERHUNGERERAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    BONECHEWERHUNGERERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(DEMORALIZING_SHOUT);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = 40;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(STRIKE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 10;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(DISARM);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 50;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(DAZED_HUNGERER);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = 15;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bonechewer RavenerAI
+
+#define CN_BONECHEWER_RAVENER 17264
+
+#define DAZED_RAVENGER 1604
+#define KIDNEY_SHOT 30621
+// Invisibility and Stealth Detection ? 18950
+class BONECHEWERRAVENERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BONECHEWERRAVENERAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    BONECHEWERRAVENERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(DAZED_RAVENGER);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(KIDNEY_SHOT);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bonechewer RipperAI
+
+#define CN_BONECHEWER_RIPPER 17281
+
+#define ENRAGE 18501
+#define DAZED_RIPPER 1604
+
+class BONECHEWERRIPPERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BONECHEWERRIPPERAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    BONECHEWERRIPPERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ENRAGE);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = 20;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(DAZED_RIPPER);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 15;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Fiendish HoundAI
+
+#define CN_FIENDISH_HOUND 17540
+
+#define DRAIN_LIFE 35748
+
+class FIENDISHHOUNDAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(FIENDISHHOUNDAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    FIENDISHHOUNDAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(DRAIN_LIFE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Hellfire WatcherAI
+
+#define CN_HELLFIRE_WATCHER 17309
+
+#define SHADOW_WORD_PAIN 14032
+#define HEAL 30643	// DBC: 12039, 30643
+#define RENEW 37260 // DBC: 8362; no idea if those are correct spells // uses it also on enemy :O // DBC: 8362
+// renew? other heal?
+
+class HELLFIREWATCHERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(HELLFIREWATCHERAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    HELLFIREWATCHERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SHADOW_WORD_PAIN);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 30;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(HEAL);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = false;
+		spells[1].cooldown = 45;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(RENEW);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 60;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Shattered Hand WarhoundAI
+
+#define CN_SHATTERED_HAND_WARHOUND 17280
+
+#define CARNIVOROUS_BITE 30639
+#define DAZED_WARHOUND 1604
+//#define FURIOUS_HOWL 30636
+// Invisibility and Stealth Detection 18950 ? && Increase Spell Dam 43 17280 ?
+class SHATTEREDHANDWARHOUNDAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SHATTEREDHANDWARHOUNDAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    SHATTEREDHANDWARHOUNDAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(CARNIVOROUS_BITE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 35;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(DAZED_WARHOUND);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 15;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+/*
+        spells[2].info = dbcSpell.LookupEntry(FURIOUS_HOWL);	// crashes server :O
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = 20;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+*/
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+/*****************************/
+/*                           */
+/*         Boss AIs          */
+/*                           */
+/*****************************/
+
+// Watchkeeper GargolmarAI
+
+#define CN_WATCHKEEPER_GARGOLMAR 17306
+
+#define SURGE 34645 // 25787 not sure
+#define MORTAL_WOUND 30641 // 25646
+#define	OVERPOWER 32154	// I am not sure about this spell and those down there
+#define RETALIATION 22857 // DBC: 22857, 22858
+
+class WATCHKEEPERGARGOLMARAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(WATCHKEEPERGARGOLMARAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    WATCHKEEPERGARGOLMARAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		HEAL_SOUND_LIMITER = 0;
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SURGE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 40;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+		spells[0].speech = "Back off, pup!";
+		spells[0].soundid = 10330;
+
+        spells[1].info = dbcSpell.LookupEntry(MORTAL_WOUND);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(OVERPOWER);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 10;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(RETALIATION);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = 45;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		HEAL_SOUND_LIMITER = 0;
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%3;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "What do we have here? ...");
+			_unit->PlaySoundToSet(10331);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Heh... this may hurt a little.");
+			_unit->PlaySoundToSet(10332);
+			break;
+		case 2:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I'm gonna enjoy this!");
+			_unit->PlaySoundToSet(10333);
+			break;
+		}
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Say farewell!");
+				_unit->PlaySoundToSet(10334);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Much too easy!");
+				_unit->PlaySoundToSet(10335);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+		HEAL_SOUND_LIMITER = 0;
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+		HEAL_SOUND_LIMITER = 0;
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Hah..."); // needs corrections!
+		_unit->PlaySoundToSet(10336);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		if (_unit->GetHealthPct() <= 40 && !HEAL_SOUND_LIMITER)
+		{
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Heal me! QUICKLY!");
+			_unit->PlaySoundToSet(10329);
+			HEAL_SOUND_LIMITER = 1;
+		}
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+protected:
+
+	int HEAL_SOUND_LIMITER;
+	int nrspells;
+};
+
+// Omor the UnscarredAI
+
+#define CN_OMOR_THE_UNSCARRED 17308
+
+#define DEMONIC_SHIELD 31901
+#define SUMMON_FIENDISH_HOUND 30707 // lack of core support
+#define SHADOW_WIP 30638
+#define TREACHEROUS_AURA 30695
+#define BANE_OF_TREACHERY 37566 // it's heroic spell which replaces treacherous aura
+#define SHADOW_BOLT 30686 // 30686, 31627, 31618, 31627 and many other possibilities
+#define ORBITAL_STRIKE 30637 // Not sure here (if it uses this spell)
+// TO DO: Add sound *Knock1* with spell if needed (I think it's for Orbital Strike)
+// as it has knockdown effect
+
+class OMORTHEUNSCARREDAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(OMORTHEUNSCARREDAI);
+	SP_AI_Spell spells[7];
+	bool m_spellcheck[7];
+
+    OMORTHEUNSCARREDAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		DEMONIC_SHIELDCooldown = 0; // not sure if this should be casted once or after some time
+		nrspells = 7;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(DEMONIC_SHIELD);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SUMMON_FIENDISH_HOUND);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = false;
+		spells[1].cooldown = 20;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+		spells[1].speech = "<missing_text>";
+		spells[1].soundid = 10277;
+
+        spells[2].info = dbcSpell.LookupEntry(SHADOW_WIP);
+		spells[2].targettype = TARGET_ATTACKING;	// should be random target
+		spells[2].instant = true;
+		spells[2].cooldown = 30;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(TREACHEROUS_AURA);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = false;
+		spells[3].cooldown = 35;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+        spells[4].info = dbcSpell.LookupEntry(BANE_OF_TREACHERY);
+		spells[4].targettype = TARGET_ATTACKING;
+		spells[4].instant = false;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+        spells[5].info = dbcSpell.LookupEntry(SHADOW_BOLT);
+		spells[5].targettype = TARGET_ATTACKING;
+		spells[5].instant = false;
+		spells[5].cooldown = 15;
+		spells[5].perctrigger = 0.0f;
+		spells[5].attackstoptimer = 1000;
+
+        spells[6].info = dbcSpell.LookupEntry(ORBITAL_STRIKE);
+		spells[6].targettype = TARGET_ATTACKING;
+		spells[6].instant = false;
+		spells[6].cooldown = 70;
+		spells[6].perctrigger = 0.0f;
+		spells[6].attackstoptimer = 1000;
+		spells[6].speech = "<missing_text>";
+		spells[6].soundid = 10278;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		DEMONIC_SHIELDCooldown = 0;
+		_unit->CastSpell(_unit, spells[1].info, spells[1].instant);
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%3;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I will not be... defeated!");
+			_unit->PlaySoundToSet(10279);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You dare stand against me?");	// ofc they need corrections ;)
+			_unit->PlaySoundToSet(10280);
+			break;
+		case 2:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your incidents will be your death!");
+			_unit->PlaySoundToSet(10281);
+			break;
+		}
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Die weakling!");
+				_unit->PlaySoundToSet(10282);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I am victorious!");
+				_unit->PlaySoundToSet(10283);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+		DEMONIC_SHIELDCooldown = 0;
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "It is... not... over...");
+		_unit->PlaySoundToSet(10284);
+		DEMONIC_SHIELDCooldown = 0;
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		DEMONIC_SHIELDCooldown--;
+		if (_unit->GetHealthPct() <= 20 && DEMONIC_SHIELDCooldown <= 0)
+		{
+			_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+			DEMONIC_SHIELDCooldown = 30;
+		}
+
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+protected:
+
+	int DEMONIC_SHIELDCooldown;
+	int nrspells;
+};
+
+/*****************************/
+/*                           */
+/*    Vazruden the Herald	 */
+/*			*Full Event*	 */
+/*                           */
+/*****************************/
+
+// EVENT DEFINITIONS/VARIABLES
+uint32 VAZRUDEN_THE_HERALD_EVENT_PHASE;
+uint32 HERALDS_SENTRY_DEATHS;	
+
+// Hellfire Sentry AI - mob
+
+#define CN_HELLFIRE_SENTRY 17517
+
+#define KIDNEY_SHOT_SENTRY 30621
+// Not sure!
+class HELLFIRESENTRYAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(HELLFIRESENTRYAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    HELLFIRESENTRYAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+		
+        spells[0].info = dbcSpell.LookupEntry(KIDNEY_SHOT_SENTRY);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// VazrudenAI
+
+#define CN_VAZRUDEN 17537
+
+#define REVENGE 40392 // DBC: 19130; 37517, 40392, 19130 or other
+
+class VAZRUDENAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(VAZRUDENAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    VAZRUDENAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		PHASE_LIMITER = 2;
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(REVENGE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		PHASE_LIMITER = 2;
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+		PHASE_LIMITER = 2;
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		if (_unit->GetHealthPct() <= 20 && PHASE_LIMITER == 2)
+		{
+			VAZRUDEN_THE_HERALD_EVENT_PHASE = 3;
+			PHASE_LIMITER = 3;
+		}
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	uint32 PHASE_LIMITER;
+	int nrspells;
+};
+
+// NazanAI
+								// DOESN'T WORK YET!
+#define WALK 0
+#define RUN 256
+#define FLY 768
+
+//#define CN_NAZAN 17536
+#define CN_NAZAN 17307 // 17307 = 17536 + 17537; VAZRUDEN THE HERALD = NAZAN (MOUNT) + VAZRUDEN
+// Event: Phase1 spells
+#define SUMMON_VAZRUDEN 30717
+// Event: Phase2 spells
+#define FIREBALL 30691	// DBC: 34653, 30691
+#define LIQUID_FLAME 1
+#define CONE_OF_FIRE 30926
+// FACE HIGHEST THREAT 30700
+struct Coords
+{
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+static Coords fly[] = 
+{
+	{ 0, 0, 0, 0 },
+	{ -1413.410034, 1744.969971,  80.900000, 0.147398 },	// fly starting position
+	{ -1413.410034, 1744.969971,  92.948196, 0.147398 },	// fly !
+	{ -1378.454712, 1687.340332, 110.200218, 1.017074 },	// 1 full fly in circle wp
+	{ -1352.973145, 1726.131470, 110.408745, 1.297234 },	// 2
+    { -1362.943970, 1767.925415, 110.101616, 5.212438 },	// 3
+	{ -1415.544189, 1804.141357, 110.075363, 5.974271 },	// 4
+	{ -1461.189575, 1780.554932, 110.854507, 0.460774 },	// 5
+	{ -1482.489380, 1718.727783, 110.248772, 5.847037 },	// 6
+	{ -1418.811646, 1676.112427, 110.405968, 0.231439 },	// 7
+	{ -1413.408203, 1744.974121,  92.000000, 0.147398 }		// land place
+};
+//	{ -1413.410034, 1744.969971,  80.948196, 0.147398 },	// fly starting position
+
+class NAZANAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(NAZANAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    NAZANAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		VAZRUDEN_THE_HERALD_EVENT_PHASE = 1;
+		HERALDS_SENTRY_DEATHS = 0;
+        m_entry = pCreature->GetEntry();
+        m_useSpell = false;
+        m_FireballCooldown = 5;
+        m_ConeOfFireCooldown = 0;
+
+		_unit->GetAIInterface()->addWayPoint(CreateWaypoint(1, 2000, RUN));	//RUN
+		_unit->GetAIInterface()->addWayPoint(CreateWaypoint(2, 0, FLY));	// FLY START!
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(3, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(4, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(5, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(6, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(7, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(8, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(9, 0, FLY));
+		_unit->GetAIInterface()->addWayPoint(CreateWaypoint(10, 1000, FLY));	// SPECIAL WP! (FOR VAZRUDEN LANDING!)
+
+        //infoFireball = dbcSpell.LookupEntry(FIREBALL);
+        infoLiquidFlame = dbcSpell.LookupEntry(LIQUID_FLAME);
+        //infoConeOfFire = dbcSpell.LookupEntry(CONE_OF_FIRE);
+		infoSummonVazruden = dbcSpell.LookupEntry(SUMMON_VAZRUDEN);
+
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+        spells[0].info = dbcSpell.LookupEntry(FIREBALL);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(CONE_OF_FIRE);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = 20;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        if(/*!infoFireball || */!infoLiquidFlame ||/* !infoConeOfFire || */!infoSummonVazruden)
+            m_useSpell = false;
+
+        _unit->GetAIInterface()->setOutOfCombatRange(200000);
+
+		VAZRUDEN_LAND = false;
+		NAZAN_LAND = false;
+		_unit->GetAIInterface()->SetAllowedToEnterCombat(false);
+        _unit->GetAIInterface()->StopMovement(0);
+        _unit->GetAIInterface()->SetAIState(STATE_SCRIPTMOVE);
+		_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+		_unit->GetAIInterface()->setWaypointToMove(1);
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+    void OnCombatStop(Unit *mTarget)	// not finished yet, as I must force Nazan to go into combat state
+    {
+		_unit->GetAIInterface()->SetAllowedToEnterCombat(false);
+		if (VAZRUDEN_THE_HERALD_EVENT_PHASE == 3)
+		{
+			VAZRUDEN_THE_HERALD_EVENT_PHASE = 1;
+			HERALDS_SENTRY_DEATHS = 0;
+			_unit->GetAIInterface()->SetAIState(STATE_SCRIPTMOVE);
+			_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			_unit->GetAIInterface()->setWaypointToMove(1);
+			VAZRUDEN_LAND = false;
+			NAZAN_LAND = false;
+		}
+
+		if (VAZRUDEN_THE_HERALD_EVENT_PHASE == 2)
+		{
+			HERALDS_SENTRY_DEATHS = 0;
+			VAZRUDEN_THE_HERALD_EVENT_PHASE = 1;
+			VAZRUDEN_LAND = false;
+		}
+
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		VAZRUDEN_THE_HERALD_EVENT_PHASE = 1;
+		HERALDS_SENTRY_DEATHS = 0;
+		VAZRUDEN_LAND = false;
+		NAZAN_LAND = false;
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		switch (VAZRUDEN_THE_HERALD_EVENT_PHASE)
+		{
+		case 1: 
+			{
+				PhaseOne();
+			}break;
+		case 2:
+			{
+				PhaseTwo();
+			}break;
+		case 3: 
+			{
+				PhaseThree();
+			}break;
+		default:
+			{
+				VAZRUDEN_THE_HERALD_EVENT_PHASE = 1;
+			};
+		};
+		//float val = sRand.rand(100.0f);
+		//SpellCast(val);
+    }
+
+    void PhaseOne()
+    {
+    }
+
+	void PhaseTwo()
+	{
+		m_useSpell = true;
+		m_FireballCooldown--;
+        if(!m_FireballCooldown && _unit->GetAIInterface()->GetNextTarget())
+        {
+            _unit->CastSpell(_unit->GetAIInterface()->GetNextTarget(), infoFireball, false);
+            m_FireballCooldown = 5;
+        }
+	}
+
+    void PhaseThree()
+    {
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+    void Fly()
+    {
+        _unit->Emote(EMOTE_ONESHOT_LIFTOFF);
+        _unit->GetAIInterface()->m_moveFly = true;
+    }
+
+    void Land()
+    {
+        _unit->Emote(EMOTE_ONESHOT_LAND);
+        _unit->GetAIInterface()->m_moveFly = false;
+    }
+
+    void OnReachWP(uint32 iWaypointId, bool bForwards)
+    {
+		if (HERALDS_SENTRY_DEATHS == 2 && VAZRUDEN_LAND == false) /*VAZRUDEN_THE_HERALD_EVENT_PHASE == 2*/
+		{
+			VAZRUDEN_THE_HERALD_EVENT_PHASE = 2;
+			VAZRUDEN_LAND = true;
+			_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+            _unit->GetAIInterface()->setWaypointToMove(10);
+		}
+
+		if (VAZRUDEN_THE_HERALD_EVENT_PHASE == 3 && NAZAN_LAND == false)
+		{
+			NAZAN_LAND = true;
+            _unit->SetFloatValue(UNIT_MOD_CAST_SPEED, 1.0f);
+            if(_unit->GetCurrentSpell() != NULL)				// these 3 lines added from Onyxia script
+                _unit->GetCurrentSpell()->cancel();
+            _unit->GetAIInterface()->m_canMove = true;
+            _unit->GetAIInterface()->SetAllowedToEnterCombat(false);
+            //_unit->GetAIInterface()->StopMovement(0);	// commented? this crap "despawns" creature
+            _unit->GetAIInterface()->SetAIState(STATE_SCRIPTMOVE);
+			_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			_unit->GetAIInterface()->setWaypointToMove(2);
+			if (_unit->GetAIInterface()->GetNextTarget())
+			{
+				Unit *target = NULL;
+				target = _unit->GetAIInterface()->GetNextTarget();
+				_unit->CastSpell(target, spells[1].info, spells[1].instant);
+			}
+		}
+
+		else
+		{
+			switch(iWaypointId)
+			{
+			case 1:
+				{
+					if (VAZRUDEN_THE_HERALD_EVENT_PHASE == 3)
+					{
+						_unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+						_unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+						_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+						_unit->GetAIInterface()->setWaypointToMove(0);
+						WorldPacket data(SMSG_MOVE_UNSET_HOVER, 13);
+						data << _unit->GetNewGUID();
+						data << uint32(0);
+						_unit->SendMessageToSet(&data, false);
+						Land();
+
+					}
+
+					else
+					{
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+						_unit->GetAIInterface()->setWaypointToMove(2);
+						Fly();
+					}
+				}break;
+
+			case 2:
+				{
+					if (VAZRUDEN_THE_HERALD_EVENT_PHASE == 3)
+					{
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+						_unit->GetAIInterface()->setWaypointToMove(1);
+					}
+
+					else
+					{
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+						_unit->GetAIInterface()->setWaypointToMove(3);	
+					}
+				}break;
+
+			case 3:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(4);
+			    }break;
+
+			case 4:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(5);
+			    }break;
+
+			case 5:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(6);
+					/*
+			        _unit->GetAIInterface()->m_canMove = false;
+			        _unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+			        _unit->GetAIInterface()->setCurrentAgent(AGENT_SPELL);
+			        //_unit->m_pacified--;
+			        _unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+			        _unit->GetAIInterface()->setWaypointToMove(0);
+			        WorldPacket data(SMSG_MOVE_SET_HOVER, 13);
+			        data << _unit->GetNewGUID();
+			        data << uint32(0);
+			        _unit->SendMessageToSet(&data, false);
+			        m_currentWP = 3;*/
+			    }break;
+
+			case 6:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(7);
+			    }break;
+
+			case 7:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(8);
+			    }break;
+
+			case 8:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(9);
+			    }break;
+
+			case 9:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(3);
+			    }break;
+
+			case 10:
+			    {
+					if (VAZRUDEN_THE_HERALD_EVENT_PHASE == 3)
+					{
+						/*_unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+						_unit->GetAInterface()->setCurrentAgent(AGENT_NULL);
+						_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+						//_unit->GetAIInterface()->setWaypointToMove(0);
+						//_unit->GetAIInterface()->m_canMove = true;
+						//_unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+						//_unit->GetAIInterface()->StopMovement(0);
+						//_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+						//_unit->GetAIInterface()->SetAIState(STATE_SCRIPTMOVE);
+						//_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+						Land();
+						m_useSpell = true;
+		                _unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+						_unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+						_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+						_unit->GetAIInterface()->setWaypointToMove(0);
+		                WorldPacket data(SMSG_MOVE_UNSET_HOVER, 13);
+						data << _unit->GetNewGUID();
+						data << uint32(0);
+						_unit->SendMessageToSet(&data, false);
+						Land();*/
+					    //_unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+						//_unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+						/*nit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);*/	// this shit messes all =/ // SCRIPTIDLE
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+						_unit->GetAIInterface()->setWaypointToMove(9);
+						/*_unit->m_pacified--;
+						if(_unit->m_pacified > 0)
+					    _unit->m_pacified--;*/
+						/*WorldPacket data(SMSG_MOVE_UNSET_HOVER, 13);
+						data << _unit->GetNewGUID();
+						data << uint32(0);
+						_unit->SendMessageToSet(&data, false);*/ // Hover disabled for now
+						//_unit->GetAIInterface()->m_moveFly = false;
+						Land();
+						/* working partially
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+						_unit->GetAIInterface()->setWaypointToMove(0);
+						Land();
+						*/
+					}
+
+					if (VAZRUDEN_THE_HERALD_EVENT_PHASE == 2)
+					{
+						m_useSpell = true;
+						_unit->CastSpell(_unit, infoSummonVazruden, true);
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+						_unit->GetAIInterface()->setWaypointToMove(3);
+					}
+
+				}break;
+
+			default:
+				{
+                _unit->GetAIInterface()->m_canMove = false;
+                _unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+                _unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+                _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+                _unit->GetAIInterface()->setWaypointToMove(0);
+                WorldPacket data(SMSG_MOVE_SET_HOVER, 13);
+                data << _unit->GetNewGUID();
+                data << uint32(0);
+                _unit->SendMessageToSet(&data, false);
+				}break;
+			}
+		}
+    }
+
+    inline WayPoint* CreateWaypoint(int id, uint32 waittime, uint32 flags)
+    {
+        WayPoint * wp = _unit->CreateWaypointStruct();
+        wp->id = id;
+        wp->x = fly[id].x;
+        wp->y = fly[id].y;
+        wp->z = fly[id].z;
+        wp->o = fly[id].o;
+        wp->waittime = waittime;
+        wp->flags = flags;
+        wp->forwardemoteoneshot = 0;
+        wp->forwardemoteid = 0;
+        wp->backwardemoteoneshot = 0;
+        wp->backwardemoteid = 0;
+        wp->forwardskinid = 0;
+        wp->backwardskinid = 0;
+        return wp;
+    }
+
+protected:
+
+    uint32 m_entry;
+    bool m_useSpell;
+	bool VAZRUDEN_LAND;
+	bool NAZAN_LAND;
+    uint32 m_FireballCooldown;
+    uint32 m_ConeOfFireCooldown;
+    uint32 m_fCastCount;
+    uint32 m_currentWP;
+    SpellEntry *infoConeOfFire, *infoLiquidFlame, *infoFireball, *infoSummonVazruden;
+	int nrspells;
+};
+
+void SetupHellfireRamparts(ScriptMgr * mgr)
+{
+	mgr->register_creature_script(CN_BLEEDING_HOLLOW_ARCHER, &BLEEDINGHOLLOWARCHERAI::Create);
+	mgr->register_creature_script(CN_BLEEDING_HOLLOW_DARKCASTER, &BLEEDINGHOLLOWDARKCASTERAI::Create);
+	mgr->register_creature_script(CN_BLEEDING_HOLLOW_SCRYER, &BLEEDINGHOLLOWSCRYERAI::Create);
+	mgr->register_creature_script(CN_BONECHEWER_BEASTMASTER, &BONECHEWERBEASTMASTERAI::Create);	
+	mgr->register_creature_script(CN_BONECHEWER_DESTROYER, &BONECHEWERDESTROYERAI::Create);	
+	mgr->register_creature_script(CN_WATCHKEEPER_GARGOLMAR, &WATCHKEEPERGARGOLMARAI::Create);
+	mgr->register_creature_script(CN_BONECHEWER_HUNGERER, &BONECHEWERHUNGERERAI::Create);
+	mgr->register_creature_script(CN_BONECHEWER_RAVENER, &BONECHEWERRAVENERAI::Create);
+	mgr->register_creature_script(CN_BONECHEWER_RIPPER, &BONECHEWERRIPPERAI::Create);
+	mgr->register_creature_script(CN_FIENDISH_HOUND, &FIENDISHHOUNDAI::Create);
+	mgr->register_creature_script(CN_HELLFIRE_WATCHER, &HELLFIREWATCHERAI::Create);
+	mgr->register_creature_script(CN_SHATTERED_HAND_WARHOUND, &SHATTEREDHANDWARHOUNDAI::Create);
+	mgr->register_creature_script(CN_OMOR_THE_UNSCARRED, &OMORTHEUNSCARREDAI::Create);
+	mgr->register_creature_script(CN_HELLFIRE_SENTRY, &HELLFIRESENTRYAI::Create);
+	mgr->register_creature_script(CN_VAZRUDEN, &VAZRUDENAI::Create);
+	mgr->register_creature_script(CN_NAZAN, &NAZANAI::Create);
+}
Index: src/InstanceScripts/Instance_SethekkHalls.cpp
===================================================================
--- src/InstanceScripts/Instance_SethekkHalls.cpp	(revision 0)
+++ src/InstanceScripts/Instance_SethekkHalls.cpp	(revision 0)
@@ -0,0 +1,1981 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+/************************************************************************/
+/* Instance_SethekkHalls.cpp Script										*/
+/************************************************************************/
+
+// Avian Darkhawk AI
+
+#define CN_AVIAN_DARKHAWK 20686
+
+#define CHARGE 36509 // no idea if this is correct id
+
+class AVIANDARKHAWKAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(AVIANDARKHAWKAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    AVIANDARKHAWKAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(CHARGE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 5.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	Unit *target;
+	int nrspells;
+};
+
+// Avian Ripper AI
+
+#define CN_AVIAN_RIPPER 21891
+
+#define FLESH_RIP 40199
+
+class AVIANRIPPERAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(AVIANRIPPERAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    AVIANRIPPERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(FLESH_RIP);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 15.0f;
+		spells[0].attackstoptimer = 3000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Avian Warhawk AI
+
+#define CN_AVIAN_WARHAWK 21904		// test it more@
+
+#define CLEAVE 38474 // no idea if this is right
+#define CHARGE_WARHAWK 40602 // same here
+#define CARNIVOROUS_BITE 39382 // and here =)
+
+class AVIANWARHAWKAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(AVIANWARHAWKAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    AVIANWARHAWKAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(CLEAVE);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].perctrigger = 12.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(CHARGE_WARHAWK);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].perctrigger = 5.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(CARNIVOROUS_BITE);
+		spells[2].targettype = TARGET_ATTACKING; // check targeting!
+		spells[2].instant = true;
+		spells[2].perctrigger = 12.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	Unit *target;
+	int nrspells;
+};
+
+// Cobalt Serpent AI
+
+#define CN_COBALT_SERPENT 19428
+
+#define WING_BUFFET 41572
+#define FROSTBOLT 40429 // no idea about if these are good ids :P
+#define CHAIN_LIGHTNING_SERPENT 39945
+
+class COBALTSERPENTAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(COBALTSERPENTAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    COBALTSERPENTAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(WING_BUFFET);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = false;
+		spells[0].perctrigger = 7.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(FROSTBOLT);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 1000; 
+
+		spells[2].info = dbcSpell.LookupEntry(CHAIN_LIGHTNING_SERPENT);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = false;
+		spells[2].perctrigger = 9.0f;
+		spells[2].attackstoptimer = 1000; 
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Time-Lost Controller AI
+
+#define CN_TIME_LOST_CONTROLLER 20691
+
+#define SHIRNK 36697 // 36697 or 35013
+//#define CONTROL_TOTEM		// Can't find spell for that :O
+
+class TIMELOSTCONTROLLERAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(TIMELOSTCONTROLLERAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    TIMELOSTCONTROLLERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(SHIRNK);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+/*
+		spells[1].info = dbcSpell.LookupEntry(CONTROL_TOTEM);
+		spells[1].targettype = TARGET_;
+		spells[1].instant = false;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000; 
+*/
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Time-Lost Scryer AI
+
+#define CN_TIME_LOST_SCRYER 20697
+
+#define FLASH_HEAL 38588 // let's try this one
+#define ARCANE_MISSILES 35034 // and those: 35033, 35034	// doesn't work somehow
+
+class TIMELOSTSCRYERAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(TIMELOSTSCRYERAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    TIMELOSTSCRYERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(FLASH_HEAL);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].perctrigger = 5.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(ARCANE_MISSILES);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].perctrigger = 12.0f;
+		spells[1].attackstoptimer = 1000; 
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+
+// Time-Lost Shadowmage AI
+
+#define CN_TIME_LOST_SHADOWMAGE 20698
+
+#define CURSE_OF_THE_DARK_TALON 32682
+
+class TIMELOSTSHADOWMAGEAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(TIMELOSTSHADOWMAGEAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    TIMELOSTSHADOWMAGEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(CURSE_OF_THE_DARK_TALON);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Sethekk Guard AI
+
+#define CN_SETHEKK_GUARD 18323
+
+#define THUNDERCLAP 36214
+#define SUNDER_ARMOR 30901 // 1000 arm per use (to 5 uses!) O_O
+
+class SETHEKKGUARDAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(SETHEKKGUARDAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    SETHEKKGUARDAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(THUNDERCLAP);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].perctrigger = 12.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SUNDER_ARMOR);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Sethekk Initiate AI
+
+#define CN_SETHEKK_INITIATE 18318
+
+#define MAGIC_REFLECTION 20223 // 20223 or 20619
+
+class SETHEKKINITIATEAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(SETHEKKINITIATEAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    SETHEKKINITIATEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(MAGIC_REFLECTION);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Sethekk Oracle AI
+
+#define CN_SETHEKK_ORACLE 18328
+
+#define FAERIE_FIRE 21670 // 20656 or 21670 or 32129 or other
+#define ARCANE_LIGHTNING 38146 // 38146, 32690 or 38634
+
+class SETHEKKORACLEAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(SETHEKKORACLEAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    SETHEKKORACLEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(FAERIE_FIRE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(ARCANE_LIGHTNING);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Sethekk Prophet AI
+
+#define CN_SETHEKK_PROPHET 18325
+
+#define FEAR 32241 // Should it be aoe or normal? // damn it fears caster too
+//#define   // Ghost spawning similar to those in Sunken Temple
+
+class SETHEKKPROPHETAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(SETHEKKPROPHETAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    SETHEKKPROPHETAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(FEAR);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+/*
+		spells[1].info = dbcSpell.LookupEntry();
+		spells[1].targettype = TARGET_;
+		spells[1].instant = true;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+*/
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Sethekk Ravenguard AI
+
+#define CN_SETHEKK_RAVENGUARD 18322
+
+#define BLOODTHIRST 31996 // check also spells like this: 31996 and this: 35948
+#define HOWLING_SCREECH 32651
+
+class SETHEKKRAVENGUARDAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(SETHEKKRAVENGUARDAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    SETHEKKRAVENGUARDAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(BLOODTHIRST);
+		spells[0].targettype = TARGET_ATTACKING;	//?
+		spells[0].instant = true;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(HOWLING_SCREECH);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Sethekk Shaman AI
+
+#define CN_SETHEKK_SHAMAN 18326
+
+#define SUMMON_DARK_VORTEX 32663 //SUMMON_VOIDWALKER 30208 // Shouldn't be Dark Vortex (spell id: 32663) ?
+
+class SETHEKKSHAMANAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(SETHEKKSHAMANAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    SETHEKKSHAMANAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(SUMMON_DARK_VORTEX);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// Sethekk Talon Lord AI
+
+#define CN_SETHEKK_TALON_LORD 18321
+
+#define TALON_OF_JUSTICE 32654 // 32654 or 39229
+#define AVENGERS_SHIELD 32774 // On WoWWiki is Shield of Revenge, but that should be it. Also spells that can be: 32774, 32674, 37554
+
+class SETHEKKTALONLORDAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(SETHEKKTALONLORDAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    SETHEKKTALONLORDAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(TALON_OF_JUSTICE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(AVENGERS_SHIELD);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	Unit *target;
+	int nrspells;
+};
+
+/*****************************/
+/*                           */
+/*         Boss AIs          */
+/*                           */
+/*****************************/
+
+// Darkweaver SythAI
+
+#define CN_DARKWEAVER_SYTH 18472
+
+// Spells
+#define FROST_SHOCK 25464	// Workaround as this is player spell, but with proly same effect. (lower dmg - 37865, higher dmg - 37332)
+#define FLAME_SHOCK 34354	// To small dmg, need to find better one 
+#define SHADOW_SHOCK 30138	// SELF IN DESCR. ?_? I think more accurate can be found (but this is quiet good)
+#define ARCANE_SHOCK 33175	// I think better can be found, but still it's good
+#define CHAIN_LIGHTNING 33643	// Couldn't find more info about this spell?
+
+// Summons
+#define SUMMON_SYTH_FIRE_ELEMENTAL 33537	//needs more core support, but those are correct ids!
+#define SUMMON_SYTH_FROST_ELEMENTAL 33539
+#define SUMMON_SYTH_ARCANE_ELEMENTAL 33538
+#define SUMMON_SYTH_SHADOW_ELEMENTAL 33540
+
+class DARKWEAVERSYTHAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(DARKWEAVERSYTHAI);
+	SP_AI_Spell spells[9];
+	bool m_spellcheck[9];
+
+    DARKWEAVERSYTHAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		SUMMON_LIMITER = 1;
+		nrspells = 9;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+        spells[0].info = dbcSpell.LookupEntry(FROST_SHOCK);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 9.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(FLAME_SHOCK);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].perctrigger = 9.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(SHADOW_SHOCK);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].perctrigger = 9.0f;
+		spells[2].attackstoptimer = 1000;
+
+        spells[3].info = dbcSpell.LookupEntry(ARCANE_SHOCK);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].perctrigger = 9.0f;
+		spells[3].attackstoptimer = 1000;
+
+        spells[4].info = dbcSpell.LookupEntry(CHAIN_LIGHTNING);
+		spells[4].targettype = TARGET_ATTACKING;
+		spells[4].instant = true;
+		spells[4].perctrigger = 15.0f;
+		spells[4].attackstoptimer = 1000;
+
+        spells[5].info = dbcSpell.LookupEntry(SUMMON_SYTH_FIRE_ELEMENTAL);
+		spells[5].targettype = TARGET_SELF;
+		spells[5].instant = true;
+		spells[5].perctrigger = 0.0f;
+		spells[5].attackstoptimer = 1000;
+
+        spells[6].info = dbcSpell.LookupEntry(SUMMON_SYTH_FROST_ELEMENTAL);
+		spells[6].targettype = TARGET_SELF;
+		spells[6].instant = true;
+		spells[6].perctrigger = 0.0f;
+		spells[6].attackstoptimer = 1000;
+
+        spells[7].info = dbcSpell.LookupEntry(SUMMON_SYTH_ARCANE_ELEMENTAL);
+		spells[7].targettype = TARGET_SELF;
+		spells[7].instant = true;
+		spells[7].perctrigger = 0.0f;
+		spells[7].attackstoptimer = 1000;
+
+        spells[8].info = dbcSpell.LookupEntry(SUMMON_SYTH_SHADOW_ELEMENTAL);
+		spells[8].targettype = TARGET_SELF;
+		spells[8].instant = true;
+		spells[8].perctrigger = 0.0f;
+		spells[8].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		SUMMON_LIMITER = 1;
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%3;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Time to... make my move!"); // needs corrections
+			_unit->PlaySoundToSet(10503);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Nice pets, yes!"); // corrections needed!
+			_unit->PlaySoundToSet(10504);
+			break;
+		case 2:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Nice pets have... weapons, not so... nice!");
+			_unit->PlaySoundToSet(10505);
+			break;
+		}
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Yes! Fleeting life is..."); // need to add it
+				_unit->PlaySoundToSet(10506);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Be free!"); // corrections needed!!
+				_unit->PlaySoundToSet(10507);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		SUMMON_LIMITER = 1;
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		SUMMON_LIMITER = 1;
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "No more life, no more pain!"); // It's talking so <censored>
+		_unit->PlaySoundToSet(10508);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		if ((_unit->GetHealthPct() <= 75 && SUMMON_LIMITER == 1) || (_unit->GetHealthPct() <= 50 && SUMMON_LIMITER == 2) || (_unit->GetHealthPct() <= 25 && SUMMON_LIMITER == 3))
+		{
+			SummonElementalWave();
+		}
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+	}
+
+	void SummonElementalWave()
+	{
+		_unit->CastSpell(_unit, spells[5].info, spells[5].instant);
+		_unit->CastSpell(_unit, spells[6].info, spells[6].instant);
+		_unit->CastSpell(_unit, spells[7].info, spells[7].instant);
+		_unit->CastSpell(_unit, spells[8].info, spells[8].instant);
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I have pets... of my own"); // It's talking so <doublecensored> -.-'
+		_unit->PlaySoundToSet(10502);
+		SUMMON_LIMITER += 1;
+	}
+
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+                  	m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	uint32 SUMMON_LIMITER;
+	int nrspells;
+};
+
+
+// Talon King IkissAI
+
+#define CN_TALON_KING_IKISS 18473
+
+#define ARCANE_VOLLEY 37078 // maybe should be: 37078 or other
+#define ARCANE_EXPLOSION 38197 // bit too high dmg, but should work nearly in the same way
+#define BLINK 38642 // Should be to random character, also can be: 38642, 29883, 38932, 36718, // doesn't work, because of lack features in core
+#define POLYMORPH 38245 // worth to try also: 38245, 38896
+#define MANA_SHIELD 38151 // also: 35064, 38151
+
+class TALONKINGIKISSAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(TALONKINGIKISSAI);
+	SP_AI_Spell spells[5];
+	bool m_spellcheck[5];
+
+    TALONKINGIKISSAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 5;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        
+		spells[0].info = dbcSpell.LookupEntry(ARCANE_VOLLEY);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = false;
+		spells[0].perctrigger = 15.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(ARCANE_EXPLOSION);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = false;
+		spells[1].perctrigger = 5.0f;	// with 8.0f it was casted too often
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(BLINK);
+		spells[2].targettype = TARGET_ATTACKING; // SELF?
+		spells[2].instant = true;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(POLYMORPH);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = false;
+		spells[3].perctrigger = 7.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(MANA_SHIELD);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].perctrigger = 6.0f;
+		spells[4].attackstoptimer = 1000;
+
+	} 
+
+    void OnCombatStart(Unit* mTarget)
+    {
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%3;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You make war on Ikiss!"); // needs corrections
+			_unit->PlaySoundToSet(10554);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Ikiss caught you pretty... sliced you, yes!"); // corrections needed!
+			_unit->PlaySoundToSet(10555);
+			break;
+		case 2:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "No escape for... for you!");
+			_unit->PlaySoundToSet(10556);
+			break;
+		}
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void OnTargetDied(Unit* mTarget) // left to keep it easy to add needed data.
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You'll die! Stay away from trinkets!"); // needs corrections
+				_unit->PlaySoundToSet(10558);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "<strange_noises>"); // corrections needed!
+				_unit->PlaySoundToSet(10559);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Ikiss will not... die!");
+		_unit->PlaySoundToSet(10560);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+
+// AnzuAI
+
+#define CN_ANZU 23035 // that should be real id, but it is not existing in my DB
+
+#define SUMMON_RAVEN_GOD 40098	// event just to test it!
+
+#define SPELL_BOMB 40303
+#define CYCLONE_OF_FEATHERS 40321
+#define PARALYZING_SCREECH 40184
+#define CHARGE_ANZU 40602 // no idea, can be: 40602, 39574 and others
+#define BANISH 40370 // can be: 38791, 38009, 40370, 39674, 35182, 40825 // should banish for one minute
+//#define SPAWN_BIRDS Can't find for now =/
+
+class ANZUAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ANZUAI);
+	SP_AI_Spell spells[6];
+	bool m_spellcheck[6];
+
+    ANZUAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		SUMMON_LIMITER = 1;
+		nrspells = 6;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        
+		spells[0].info = dbcSpell.LookupEntry(SPELL_BOMB);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(CYCLONE_OF_FEATHERS);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].perctrigger = 10.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(PARALYZING_SCREECH);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = false;
+		spells[2].perctrigger = 10.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(CHARGE_ANZU);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(BANISH);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+		spells[5].info = dbcSpell.LookupEntry(SUMMON_RAVEN_GOD);
+		spells[5].targettype = TARGET_SELF;
+		spells[5].instant = true;
+		spells[5].perctrigger = 0.0f;
+		spells[5].attackstoptimer = 1000;
+/*
+		spells[6].info = dbcSpell.LookupEntry(SUMMON_BIRDS);
+		spells[6].targettype = TARGET_SELF;
+		spells[6].instant = true;
+		spells[6].perctrigger = 0.0f;
+		spells[6].attackstoptimer = 1000;
+*/
+	} 
+
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[5].info, spells[5].targettype);
+		SUMMON_LIMITER = 1;
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void OnTargetDied(Unit* mTarget) // left to keep it easy to add needed data.
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		SUMMON_LIMITER = 1;
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+		SUMMON_LIMITER = 1;
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		if((_unit->GetHealthPct() <= 66 && SUMMON_LIMITER == 1) || (_unit->GetHealthPct() <= 33 && SUMMON_LIMITER == 2) )
+		{
+			SummonPhase();
+		}
+
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+    }
+
+	void SummonPhase()
+	{
+		SUMMON_LIMITER += 1;
+		_unit->CastSpell(_unit,spells[4].info, spells[4].targettype);
+		//_unit->CastSpell(_unit,spells[6].info, spells[6].targettype); Bird summon spell
+	}
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	Unit *target;
+	uint32 SUMMON_LIMITER;
+	int nrspells;
+};
+
+void SetupSethekkHalls(ScriptMgr * mgr)
+{
+	mgr->register_creature_script(CN_AVIAN_DARKHAWK, &AVIANDARKHAWKAI::Create);
+	mgr->register_creature_script(CN_AVIAN_RIPPER, &AVIANRIPPERAI::Create);
+	mgr->register_creature_script(CN_AVIAN_WARHAWK, &AVIANWARHAWKAI::Create);
+	mgr->register_creature_script(CN_COBALT_SERPENT, &COBALTSERPENTAI::Create);
+	mgr->register_creature_script(CN_TIME_LOST_CONTROLLER, &TIMELOSTCONTROLLERAI::Create);
+	mgr->register_creature_script(CN_TIME_LOST_SCRYER, &TIMELOSTSCRYERAI::Create);
+	mgr->register_creature_script(CN_TIME_LOST_SHADOWMAGE, &TIMELOSTSHADOWMAGEAI::Create);
+	mgr->register_creature_script(CN_SETHEKK_GUARD, &SETHEKKGUARDAI::Create);
+	mgr->register_creature_script(CN_SETHEKK_INITIATE, &SETHEKKINITIATEAI::Create);
+	mgr->register_creature_script(CN_SETHEKK_ORACLE, &SETHEKKORACLEAI::Create);
+	mgr->register_creature_script(CN_SETHEKK_PROPHET, &SETHEKKPROPHETAI::Create);
+	mgr->register_creature_script(CN_SETHEKK_RAVENGUARD, &SETHEKKRAVENGUARDAI::Create);
+	mgr->register_creature_script(CN_SETHEKK_SHAMAN, &SETHEKKSHAMANAI::Create);
+	mgr->register_creature_script(CN_SETHEKK_TALON_LORD, &SETHEKKTALONLORDAI::Create);
+    mgr->register_creature_script(CN_DARKWEAVER_SYTH, &DARKWEAVERSYTHAI::Create);
+    mgr->register_creature_script(CN_TALON_KING_IKISS, &TALONKINGIKISSAI::Create);
+	mgr->register_creature_script(CN_ANZU, &ANZUAI::Create);
+}
+
+// Can't check Anzu, as I don't have it in DB right now. Add some spells (2?) and
+// change other if needed.
Index: src/InstanceScripts/Instance_TheMechanar.cpp
===================================================================
--- src/InstanceScripts/Instance_TheMechanar.cpp	(revision 0)
+++ src/InstanceScripts/Instance_TheMechanar.cpp	(revision 0)
@@ -0,0 +1,2895 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+/************************************************************************/
+/* Instance_TheMechanar.cpp Script										*/
+/************************************************************************/
+
+// Arcane ServantAI
+
+#define CN_ARCANE_SERVANT 20478
+
+#define ARCANE_VOLLEY 35255
+#define ARCANE_EXPLOSION 22271
+//#define SPOTLIGHT 35259 // SSS
+
+class ArcaneServantAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ArcaneServantAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    ArcaneServantAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ARCANE_VOLLEY);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(ARCANE_EXPLOSION);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bloodwarder CenturionAI
+
+#define CN_BLOODWARDER_CENTURION 19510
+
+#define SHIELD_BASH 35178
+#define UNSTABLE_AFFLICTION 35183
+#define MELT_ARMOR 35185
+#define CHILLING_TOUCH 12531
+#define ETHEREAL_TELEPORT 34427	// SSS
+
+//#define SEED_OF_CORRUPTION 37826 // SSS
+
+class BloodwarderCenturionAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BloodwarderCenturionAI);
+	SP_AI_Spell spells[5];
+	bool m_spellcheck[5];
+
+    BloodwarderCenturionAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 5;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SHIELD_BASH);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 5.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(UNSTABLE_AFFLICTION);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 6.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(MELT_ARMOR);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(CHILLING_TOUCH);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 8.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(ETHEREAL_TELEPORT);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[4].info, spells[4].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bloodwarder PhysicianAI
+
+#define CN_BLOODWARDER_PHYSICIAN 20990
+
+#define HOLY_SHOCK 36340
+#define ANESTHETIC 36333
+#define BANDAGE 36348	// DBC: 36348; mine choice 38919
+#define ETHEREAL_TELEPORT_PHYS 34427 // SSS
+//#define SEED_OF_CORRUPTION 37826 // SSS
+
+class BloodwarderPhysicianAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BloodwarderPhysicianAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    BloodwarderPhysicianAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(HOLY_SHOCK);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(ANESTHETIC);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 6.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(BANDAGE);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = false;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(ETHEREAL_TELEPORT_PHYS);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Bloodwarder SlayerAI
+
+#define CN_BLOODWARDER_SLAYER 19167
+
+#define WHIRLWIND 13736 // DBC: 13736, 15589;
+#define SOLAR_STRIKE 35189
+#define MELT_ARMOR_SLAYER 35231
+#define CHILLING_TOUCH_SLAYER 12531
+#define MORTAL_STRIKE 15708
+
+class BloodwarderSlayerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BloodwarderSlayerAI);
+	SP_AI_Spell spells[5];
+	bool m_spellcheck[5];
+
+    BloodwarderSlayerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 5;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(WHIRLWIND);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 15.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SOLAR_STRIKE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(MELT_ARMOR_SLAYER);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(CHILLING_TOUCH_SLAYER);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(MORTAL_STRIKE);
+		spells[4].targettype = TARGET_ATTACKING;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 10.0f;
+		spells[4].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Mechanar CrusherAI
+
+#define CN_MECHANAR_CRUSHER 19231
+
+#define DISARM 31955	// is that all?	and not sure to this one :)
+
+class MechanarCrusherAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MechanarCrusherAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    MechanarCrusherAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(DISARM);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Mechanar DrillerAI
+
+#define CN_MECHANAR_DRILLER 19712
+
+#define GLOB_OF_MACHINE_FLUID 35056
+#define DRILL_ARMOR 35047
+#define CRIPPLING_POISON 30981	// not sure if crippling poison and glob should be here (I mean if both should be)
+#define POUND 35049
+
+class MechanarDrillerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MechanarDrillerAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    MechanarDrillerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(GLOB_OF_MACHINE_FLUID);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 5.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(DRILL_ARMOR);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(CRIPPLING_POISON);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 10.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(POUND);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 10.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Mechanar TinkererAI
+
+#define CN_MECHANAR_TINKERER 19716 // recheck and add some stuff
+
+#define NETHERBOMB 35057
+#define PRAYER_OF_MENDING 35092 // DBC: 35092, 33110, 35094	// SSS
+#define MANIACAL_CHARGE 35062	// those two are connected with each other and Idk if those shouldn't be scripted separately
+#define NETHER_EXPLOSION 35058	// additional coding to add health percent check, chance to cast and killing caster =/
+
+class MechanarTinkererAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MechanarTinkererAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    MechanarTinkererAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(NETHERBOMB);
+		spells[0].targettype = TARGET_DESTINATION;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 5.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(PRAYER_OF_MENDING);
+		spells[1].targettype = TARGET_VARIOUS;	// ?
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(MANIACAL_CHARGE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(NETHER_EXPLOSION);
+		spells[3].targettype = TARGET_VARIOUS;
+		spells[3].instant = false;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{/*	// not working yet, I must found out why you can't loot after death (hmm, sth is wrong? :P)
+		if (_unit->GetHealthPct() < 15 && _unit->GetAIInterface()->GetNextTarget())
+		{
+			uint32 val = sRand.rand(100);
+			if (val > 0 && val < 20)
+			{
+				_unit->SetUInt32Value(UNIT_FIELD_HEALTH, 0);
+				_unit->setDeathState(JUST_DIED);
+				_unit->GetAIInterface()->HandleEvent(EVENT_UNITDIED, _unit, 0);
+				//_unit->setDeathState(DEATH);
+				//CALL_SCRIPT_EVENT(m_Unit, OnDied)(_unit);
+				//_unit->GetAIInterface()->HandleEvent(EVENT_UNITDIED, _unit, misc1);	//, uint32 misc1
+				//CastTime();
+				//RemoveAIUpdateEvent();
+			}
+		}
+*/
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Mechanar WreckerAI
+
+#define CN_MECHANAR_WRECKER 19713
+
+#define POUND_WRECKER 35049
+#define GLOB_OF_MACHINE_FLUID_WRECKER 35056
+#define PRAYER_OF_MENDING_WRECKER 33280	// DBC: 33280, 33110, 35093; SSS (hmm... not sure if it uses it =S)	should also affect allies, not enemies
+
+class MechanarWreckerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MechanarWreckerAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    MechanarWreckerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(POUND_WRECKER);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 12.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(GLOB_OF_MACHINE_FLUID_WRECKER);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(PRAYER_OF_MENDING_WRECKER);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Raging FlamesAI
+
+#define CN_RAGING_FLAMES 20481
+
+#define RAGING_FLAMES 35278 // DBC: 35278;
+#define INFERNO 35268 // DBC: 35268, 35283;
+// his skills needs additional core support I think
+
+class RagingFlamesAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(RagingFlamesAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    RagingFlamesAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(RAGING_FLAMES);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;	// 8// disabled to prevent crashes
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(INFERNO);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 9.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Sunseeker AstromageAI
+
+#define CN_SUNSEEKER_ASTROMAGE 19168
+
+#define SCORCH 17195
+#define SOLARBURN 35267
+#define FIRE_SHIELD 35265 //  DBC: 35266, 35265
+#define ETHEREAL_TELEPORT_ASTROMAGE 34427
+
+class SunseekerAstromageAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SunseekerAstromageAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SunseekerAstromageAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SCORCH);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 12.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SOLARBURN);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 10.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(FIRE_SHIELD);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 8.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(ETHEREAL_TELEPORT_ASTROMAGE);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Sunseeker EngineerAI
+
+#define CN_SUNSEEKER_ENGINEER 20988
+
+#define SUPER_SHRINK_RAY 36341
+#define DEATH_RAY 36345
+#define GROWTH_RAY 36346	// doesn't work, even when used by player =(
+#define ETHEREAL_TELEPORT_ENGINEER 34427
+
+class SunseekerEngineerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SunseekerEngineerAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    SunseekerEngineerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SUPER_SHRINK_RAY);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(DEATH_RAY);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 13.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(GROWTH_RAY);
+		spells[2].targettype = TARGET_SELF;	// ?
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 7.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(ETHEREAL_TELEPORT_ENGINEER);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Sunseeker NetherbinderAI
+
+#define CN_SUNSEEKER_NETHERBINDER 20059
+
+#define ARCANE_NOVA 35261
+#define STARFIRE 35243
+#define SUMMON_ARCANE_GOLEM1 35251	// DBC: 35251, 35260; Guardian, so won't work now
+#define SUMMON_ARCANE_GOLEM2 35260
+#define DISPEL_MAGIC 23859 // no idea about this one
+//#define SEED_OF_CORRUPTION 37826
+
+class SunseekerNetherbinderAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SunseekerNetherbinderAI);
+	SP_AI_Spell spells[5];
+	bool m_spellcheck[5];
+
+    SunseekerNetherbinderAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 5;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ARCANE_NOVA);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(STARFIRE);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 13.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(SUMMON_ARCANE_GOLEM1);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(SUMMON_ARCANE_GOLEM2);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(DISPEL_MAGIC);
+		spells[4].targettype = TARGET_SELF;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 8.0f;
+		spells[4].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Tempest-Forge DestroyerAI
+
+#define CN_TEMPEST_FORGE_DESTROYER 19735
+
+#define KNOCKDOWN 35783
+#define CHARGED_FIST 36582 // DBC: 36582, 36583;	doesn't work anyway at all (lack of core support?)
+
+class TempestForgeDestroyerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(TempestForgeDestroyerAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    TempestForgeDestroyerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(KNOCKDOWN);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(CHARGED_FIST);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 12.0f;
+		spells[1].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Tempest-Forge PatrollerAI
+
+#define CN_TEMPEST_FORGE_PATROLLER 19166
+
+#define CHARGED_ARCANE_MISSILE 35012
+#define KNOCKDOWN_PATROLLER 35011
+
+class TempestForgePatrollerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(TempestForgePatrollerAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    TempestForgePatrollerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(CHARGED_ARCANE_MISSILE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 12.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(KNOCKDOWN_PATROLLER);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+/**************************/
+/*                        */
+/*       Boss AIs         */
+/*                        */
+/**************************/
+
+// Gatewatcher Gyro-Kill AI
+
+#define CN_GATEWATCHER_GYRO_KILL 19218
+
+#define SAW_BLADE 35318
+#define SHADOW_POWER_GKILL 35322
+#define STEAM_OF_MACHINE_FLUID_GKILL 35311
+
+class GatewatcherGyroKillAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(GatewatcherGyroKillAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    GatewatcherGyroKillAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(SAW_BLADE);
+		spells[0].targettype = TARGET_ATTACKING;	// to prevent crashes when used VARIOUS
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 13.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SHADOW_POWER_GKILL);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(STEAM_OF_MACHINE_FLUID_GKILL);
+		spells[2].targettype = TARGET_VARIOUS;	// VARIOUS doesn't work somehow :S (sometimes yes, sometimes no)
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 9.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I predict a painful death.");
+		_unit->PlaySoundToSet(11101);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your strategy was flat!");	// flat?
+				_unit->PlaySoundToSet(11102);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Yes, the only magical outcome!");	// magical outcome?
+				_unit->PlaySoundToSet(11103);
+				break;
+			}
+		}
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "An unforseen... contingency.");
+		_unit->PlaySoundToSet(11106);
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SawBladesSound()
+	{
+		int RandomSawBlades;
+		RandomSawBlades=rand()%30;
+		switch (RandomSawBlades)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Measure twice; cut once.");
+			_unit->PlaySoundToSet(11104);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "If my devision is correct, you should be quiet dead!");	// needs checks
+			_unit->PlaySoundToSet(11105);
+			break;
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					
+					if (m_spellcheck[0] == true)
+						SawBladesSound();
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Gatewatcher Iron-Hand AI
+
+#define CN_GATEWATCHER_IRON_HAND 19710	
+
+#define JACK_HAMMER 35327 // DBC: 35327, 35330
+#define HAMMER_PUNCH 35326
+#define STREAM_OF_MACHINE_FLUID_IHAND 35311
+#define SHADOW_POWER_IHAND 35322
+
+class GatewatcherIronHandAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(GatewatcherIronHandAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    GatewatcherIronHandAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(JACK_HAMMER);
+		spells[0].targettype = TARGET_VARIOUS;	// why this is spammed when casted ? :| maybe core bug? :|
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 7.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(HAMMER_PUNCH);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 9.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(STREAM_OF_MACHINE_FLUID_IHAND);
+		spells[2].targettype = TARGET_VARIOUS;	// VARIOUS doesn't work somehow (sometimes yes, sometimes no)
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 7.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(SHADOW_POWER_IHAND);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = false;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You have approximately 5 seconds to live!");	// needs checks!
+		_unit->PlaySoundToSet(11109);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Afford gun conclusion!");
+				_unit->PlaySoundToSet(11110);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "The processing will continue a schedule!");
+				_unit->PlaySoundToSet(11111);
+				break;
+			}
+		}
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "My calculations... did not...");	// ??
+		_unit->PlaySoundToSet(11114);
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void HammerSound()
+	{
+		uint32 RandomHammer;
+		RandomHammer=rand()%10;
+		switch (RandomHammer)
+		{
+		case 0:
+			{
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "With the precise <missing_rest_of_text>");	// !!
+				_unit->PlaySoundToSet(11112);
+			}break;
+		case 1:
+			{
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Low tech yet quiet effective!");	// this one too =/
+				_unit->PlaySoundToSet(11113);
+			}break;
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (m_spellcheck[1] == true)
+					{
+						HammerSound();
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Mechano-Lord Capacitus AI
+
+#define CN_MECHANO_LORD_CAPACITUS 19219	
+
+#define HEAD_CRACK 35161
+#define REFLECTIVE_DAMAGE_SHIELD 35159
+#define REFLECTIVE_MAGIC_SHIELD 35158
+#define SEED_OF_CORRUPTION 37826	// SSS (server side script) (is it really used?)
+
+/*#define NETHER_CHARGE 34303
+#define NETHER_CHARGE_PASSIVE 35150 // SSS
+#define NETHER_CHARGE_PULSE 35151	// SSS
+#define NETHER_CHARGE_TIMER 37670
+#define NETHER_DETONATION 35152		// Spell from Timer
+// Note: All for bombs :O*/
+
+class MechanoLordCapacitusAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(MechanoLordCapacitusAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    MechanoLordCapacitusAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(HEAD_CRACK);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(REFLECTIVE_DAMAGE_SHIELD);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = false;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 7.0f;
+		spells[1].attackstoptimer = 1000;
+		spells[1].speech = "Think you can hurt me, huh? Think I'm afraid a' you?";
+		spells[1].soundid = 11165;
+
+		spells[2].info = dbcSpell.LookupEntry(REFLECTIVE_MAGIC_SHIELD);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = false;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 7.0f;
+		spells[2].attackstoptimer = 1000;
+		spells[2].speech = "Go ahead, gimme your best shot. I can take it!";
+		spells[2].soundid = 11166;
+
+		spells[3].info = dbcSpell.LookupEntry(SEED_OF_CORRUPTION);	// it won't work anyway
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You should split while you can.");
+		_unit->PlaySoundToSet(11162);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Can't say I didn't warn you!");	// checks here
+				_unit->PlaySoundToSet(11163);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Damn, I'm good!");
+				_unit->PlaySoundToSet(11164);
+				break;
+			}
+		}
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Bully!");
+		_unit->PlaySoundToSet(11167);
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Nethermancer Sepethrea AI
+
+#define CN_NETHERMANCER_SEPETHREA 19221	
+
+#define SUMMON_RAGIN_FLAMES 35275	// must add despawning after death!
+#define FROST_ATTACK 35263
+#define ARCANE_BLAST 35314
+#define DRAGONS_BREATH 35250
+//#define KNOCKBACK 37317	// not sure to this one!
+
+class NethermancerSepethreaAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(NethermancerSepethreaAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    NethermancerSepethreaAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		SummonTimer = 4;
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(SUMMON_RAGIN_FLAMES);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(FROST_ATTACK);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 9.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(ARCANE_BLAST);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 3.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(DRAGONS_BREATH);
+		spells[3].targettype = TARGET_VARIOUS;	// doesn't afffect when VARIOUS? WTF? :|  Sometimes works, sometimes not? :|
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 8.0f;
+		spells[3].attackstoptimer = 1000;
+/*
+		spells[4].info = dbcSpell.LookupEntry(KNOCKBAC);
+		spells[4].targettype = TARGET_ATTACKING;
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 2.0f;
+		spells[4].attackstoptimer = 1000;
+*/
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		SummonTimer = 4;
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		//_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Don't value your life very much, do you?");
+		_unit->PlaySoundToSet(11186);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		SummonTimer = 4;
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "And don't come back!");	// checks here
+				_unit->PlaySoundToSet(11187);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "<missing_text>");	// ? ? ! !
+				_unit->PlaySoundToSet(11188);
+				break;
+			}
+		}
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		SummonTimer = 4;
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Anu... bala belore...alon.");
+		_unit->PlaySoundToSet(11192);
+    }
+
+    void AIUpdate()
+	{
+		SummonTimer--;
+
+		if (!SummonTimer)
+		{
+			_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I am not alone!");	// checks!
+			_unit->PlaySoundToSet(11191);
+		}
+
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void DragonsBreathSound()
+	{
+		uint32 RandomDragonsBreath;
+		RandomDragonsBreath=rand()%10;
+		switch (RandomDragonsBreath)
+		{
+		case 0:
+			{
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Think you can take the heat?");
+				_unit->PlaySoundToSet(11189);
+			}break;
+		case 1:
+			{
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Anar'endal dracon!");
+				_unit->PlaySoundToSet(11190);
+			}break;
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (m_spellcheck[3] == true)
+						DragonsBreathSound();
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int SummonTimer;
+	int nrspells;
+};
+
+// Pathaleon the Calculator AI
+
+#define CN_PATHALEON_THE_CALCULATOR 19220	
+
+#define MANA_TRAP 36021 // I am not sure to any of those ids =(
+#define DOMINATION 36866
+#define SILENCE 38491
+#define SUMMON_NETHER_WRAITH1 35285	// not the best way, but blizzlike :) (but they don't work for now =()
+#define SUMMON_NETHER_WRAITH2 35286
+#define SUMMON_NETHER_WRAITH3 35287
+#define SUMMON_NETHER_WRAITH4 35288
+// hmm... he switches weapons and there is sound for it, but I must know when he does that, how it looks like etc.
+// before adding weapon switching =/	(Sound: 11199; speech: "I prefer to be hands-on...";)
+
+class PathaleonTheCalculatorAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(PathaleonTheCalculatorAI);
+	SP_AI_Spell spells[7];
+	bool m_spellcheck[7];
+
+    PathaleonTheCalculatorAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		SummonTimer=rand()%16+30;	// 30 - 45 sec
+		nrspells = 7;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(MANA_TRAP);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(DOMINATION);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 4.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(SILENCE);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 6.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(SUMMON_NETHER_WRAITH1);
+		spells[3].targettype = TARGET_SELF;	// hmm
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(SUMMON_NETHER_WRAITH2);
+		spells[4].targettype = TARGET_SELF;	// hmm
+		spells[4].instant = true;
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+		spells[5].info = dbcSpell.LookupEntry(SUMMON_NETHER_WRAITH3);
+		spells[5].targettype = TARGET_SELF;	// hmm
+		spells[5].instant = true;
+		spells[5].cooldown = -1;
+		spells[5].perctrigger = 0.0f;
+		spells[5].attackstoptimer = 1000;
+
+		spells[6].info = dbcSpell.LookupEntry(SUMMON_NETHER_WRAITH4);
+		spells[6].targettype = TARGET_SELF;	// hmm
+		spells[6].instant = true;
+		spells[6].cooldown = -1;
+		spells[6].perctrigger = 0.0f;
+		spells[6].attackstoptimer = 1000;
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		SummonTimer=rand()%16+30;
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "We are on a strict timetable. You will not interfere!");
+		_unit->PlaySoundToSet(11193);
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		SummonTimer=rand()%16+30;
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "A minor inconvenience.");
+				_unit->PlaySoundToSet(11194);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Looks like you lose.");
+				_unit->PlaySoundToSet(11195);
+				break;
+			}
+		}
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		SummonTimer=rand()%16+30;
+		CastTime();
+       RemoveAIUpdateEvent();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "The project will... continue.");
+		_unit->PlaySoundToSet(11200);
+    }
+
+    void AIUpdate()
+	{
+		SummonTimer--;
+
+		if (!SummonTimer)
+		{
+			_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+			_unit->CastSpell(_unit, spells[4].info, spells[4].instant);
+			_unit->CastSpell(_unit, spells[5].info, spells[5].instant);
+			_unit->CastSpell(_unit, spells[6].info, spells[6].instant);
+			SummonTimer=rand()%16+30;	// 30 - 45
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Time to supplement my work force.");
+			_unit->PlaySoundToSet(11196);;
+		}
+
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void DominationSound()
+	{
+		int RandomDomination;
+		RandomDomination=rand()%2;
+		switch (RandomDomination)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I'm looking for a team player...");
+			_unit->PlaySoundToSet(11197);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You work for me now!");
+			_unit->PlaySoundToSet(11198);
+			break;
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (m_spellcheck[1] == true)
+					{
+						DominationSound();
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	uint32 SummonTimer;
+	int nrspells;
+};
+
+void SetupTheMechanar(ScriptMgr * mgr)
+{
+	mgr->register_creature_script(CN_ARCANE_SERVANT, &ArcaneServantAI::Create);
+	mgr->register_creature_script(CN_BLOODWARDER_CENTURION, &BloodwarderCenturionAI::Create);
+	mgr->register_creature_script(CN_BLOODWARDER_PHYSICIAN, &BloodwarderPhysicianAI::Create);
+	mgr->register_creature_script(CN_BLOODWARDER_SLAYER, &BloodwarderSlayerAI::Create);
+	mgr->register_creature_script(CN_MECHANAR_CRUSHER, &MechanarCrusherAI::Create);
+	mgr->register_creature_script(CN_MECHANAR_DRILLER, &MechanarDrillerAI::Create);
+	mgr->register_creature_script(CN_MECHANAR_TINKERER, &MechanarTinkererAI::Create);
+	mgr->register_creature_script(CN_MECHANAR_WRECKER, &MechanarWreckerAI::Create);
+	mgr->register_creature_script(CN_RAGING_FLAMES, &RagingFlamesAI::Create);
+	mgr->register_creature_script(CN_SUNSEEKER_ASTROMAGE, &SunseekerAstromageAI::Create);
+	mgr->register_creature_script(CN_SUNSEEKER_ENGINEER, &SunseekerEngineerAI::Create);
+	mgr->register_creature_script(CN_SUNSEEKER_NETHERBINDER, &SunseekerNetherbinderAI::Create);
+	mgr->register_creature_script(CN_TEMPEST_FORGE_DESTROYER, &TempestForgeDestroyerAI::Create);
+	mgr->register_creature_script(CN_TEMPEST_FORGE_PATROLLER, &TempestForgePatrollerAI::Create);
+	mgr->register_creature_script(CN_GATEWATCHER_GYRO_KILL, &GatewatcherGyroKillAI::Create);
+	mgr->register_creature_script(CN_GATEWATCHER_IRON_HAND, &GatewatcherIronHandAI::Create);
+	mgr->register_creature_script(CN_MECHANO_LORD_CAPACITUS, &MechanoLordCapacitusAI::Create);
+	mgr->register_creature_script(CN_NETHERMANCER_SEPETHREA, &NethermancerSepethreaAI::Create);
+	mgr->register_creature_script(CN_PATHALEON_THE_CALCULATOR, &PathaleonTheCalculatorAI::Create);
+}
+
+// Data needed for: Nether Wraith, Mechanar Crusher (maybe not enough?)
Index: src/InstanceScripts/Instance_TheSteamvault.cpp
===================================================================
--- src/InstanceScripts/Instance_TheSteamvault.cpp	(revision 0)
+++ src/InstanceScripts/Instance_TheSteamvault.cpp	(revision 0)
@@ -0,0 +1,2376 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+/************************************************************************/
+/* Instance_TheSteamvault.cpp Script		                            */
+/************************************************************************/
+
+// Coilfang Engineer AI
+
+#define CN_COILFANG_ENGINEER 17721
+
+#define BOMB 22334 //40332 // AOE
+#define NET 6533 //38338 // Should stay for 5 or 8 sec?
+// DAZED?
+
+class COILFANGENGINEERAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(COILFANGENGINEERAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    COILFANGENGINEERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(BOMB);
+		spells[0].targettype = TARGET_DESTINATION;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(NET);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+
+// Coilfang Oracle AI
+
+
+#define CN_COILFANG_ORACLE 17803
+
+#define FROST_SHOCK 22582 //34353
+#define SONIC_BURST 8281 //39052 // Should make dmg? or maybe it shouldn't be added here?
+#define HEAL 31730 //39378 // Hmm... no idea if this is correct id (and how much should heal)
+// Also it should heal other naga like etc.
+// DAZED?
+
+class COILFANGORACLEAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(COILFANGORACLEAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    COILFANGORACLEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(FROST_SHOCK);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(SONIC_BURST);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+        spells[2].info = dbcSpell.LookupEntry(HEAL);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = false;
+		spells[2].cooldown = 45;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Coilfang Warrior AI
+
+#define CN_COILFANG_WARRIOR 17802  // at least, couldn't find any data to compare it with blizz
+
+//#define MORTAL_STRIKE 29572	// should it really be here?
+#define MORTAL_BLOW 35105
+#define BATTLE_SHOUT 31403 
+// Defensive Stance 7164 ?
+// DAZED?
+
+class COILFANGWARRIORAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(COILFANGWARRIORAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    COILFANGWARRIORAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+/*
+		spells[0].info = dbcSpell.LookupEntry(MORTAL_STRIKE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = ;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+*/
+		spells[0].info = dbcSpell.LookupEntry(MORTAL_BLOW);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(BATTLE_SHOUT);	// should affect friends not enemies :S
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+
+// Coilfang Siren AI
+
+#define CN_COILFANG_SIREN 17801
+
+//#define MOONFIRE 20690 // not sure to id	// not used ? 
+#define AOE_FEAR 29321 //30584 // Maybe should be: 33547 or 29321
+#define LIGHTNING_BOLT 15234 //36152 // 1 target
+#define ARCANE_FLARE 35106
+// DAZED?
+
+class COILFANGSIRENAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(COILFANGSIRENAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    COILFANGSIRENAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(AOE_FEAR);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].cooldown = 35;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(LIGHTNING_BOLT);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = false;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(ARCANE_FLARE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 15;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+/*
+		spells[2].info = dbcSpell.LookupEntry(MOONFIRE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = ;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+*/
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+
+
+// Bog OverlordAI
+
+#define CN_BOG_OVERLORD 21694
+
+#define FUNGAL_DECAY 32065
+#define TRAMPLE 15550 //40340 // Should be used when enraged
+#define ENRAGE_BOG_OVERLORD 8599 //40683 // No idea if this is good spell id (used ENRAGE_B [B = Bog], because of redefining)
+#define DISEASE_CLOUD 37266 //DBC: 37266, 37267 || Heroic: 37863, 37864 ?
+// Should be immunite on CC's and slowing down effects.
+// Also should detect players in stealth mode. (Invisibility and Stealth Detection 18950 ?)
+
+class BOGOVERLORDAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(BOGOVERLORDAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    BOGOVERLORDAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(FUNGAL_DECAY);
+		spells[0].targettype = TARGET_ATTACKING;	// should be random (as in many other spells)
+		spells[0].instant = true;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(TRAMPLE);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = 10;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(ENRAGE_BOG_OVERLORD);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = false;
+		spells[2].cooldown = 55;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(DISEASE_CLOUD);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;	// not sure to this and...
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+		_unit->CastSpell(_unit, spells[3].info, spells[3].instant); // ...and this
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Coilfang Sorceress
+
+#define CN_COILFANG_SORCERESS 17722
+
+#define FROSTBOLT 12675 //39064
+#define BLIZZARD 39416 //38646 // or maybe: 37263
+#define FROST_NOVA 15063 //29849 // also can be: 30094 or 32365
+
+class COILFANGSORCERESSAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(COILFANGSORCERESSAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    COILFANGSORCERESSAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+		
+        spells[0].info = dbcSpell.LookupEntry(FROSTBOLT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(BLIZZARD);
+		spells[1].targettype = TARGET_DESTINATION;
+		spells[1].instant = false;
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+    
+        spells[2].info = dbcSpell.LookupEntry(FROST_NOVA);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = 25;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Coilfang Leper 
+
+#define CN_COILFANG_LEPER 21338 // Couldn't find source to compare it's spells
+
+#define SHADOW_BOLT 9613 //39025
+#define FIRE_BLAST_LEPER 13339 // not sure to those
+#define STRIKE 13446
+#define FROST_NOVA_LEPER 11831
+#define CLEAVE_LEPER 5532		// THOSE SPELLS MUST BE VERIFIED!
+#define HEAL_LEPER 11642
+#define SUNDER_ARMOR_LEPER 13444
+#define SHOOT 15547
+//DAZED
+
+class COILFANGLEPERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(COILFANGLEPERAI);
+	SP_AI_Spell spells[8];
+	bool m_spellcheck[8];
+
+    COILFANGLEPERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 8;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+		
+        spells[0].info = dbcSpell.LookupEntry(SHADOW_BOLT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(FIRE_BLAST_LEPER);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(STRIKE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 35;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(FROST_NOVA_LEPER);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].cooldown = 55;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(CLEAVE_LEPER);
+		spells[4].targettype = TARGET_VARIOUS;	// ?
+		spells[4].instant = true;
+		spells[4].cooldown = 45;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+		spells[5].info = dbcSpell.LookupEntry(HEAL_LEPER);
+		spells[5].targettype = TARGET_SELF;
+		spells[5].instant = false;
+		spells[5].cooldown = 85;
+		spells[5].perctrigger = 0.0f;
+		spells[5].attackstoptimer = 1000;
+
+		spells[6].info = dbcSpell.LookupEntry(SUNDER_ARMOR_LEPER);
+		spells[6].targettype = TARGET_ATTACKING;
+		spells[6].instant = true;
+		spells[6].cooldown = 95;
+		spells[6].perctrigger = 0.0f;
+		spells[6].attackstoptimer = 1000;
+
+		spells[7].info = dbcSpell.LookupEntry(SHOOT);
+		spells[7].targettype = TARGET_ATTACKING;
+		spells[7].instant = true;
+		spells[7].cooldown = -1;	// disabled for now
+		spells[7].perctrigger = 0.0f;
+		spells[7].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Coilfang Slavemaster
+
+#define CN_COILFANG_SLAVEMASTER 17805
+
+#define GEYSER 10987 //40089 // It don't have to be good spell id [can be: 10987, 37478, 40089, 37427] - no idea why it doesn't knock you out
+#define ENRAGE_SlAVEMASTER 8269
+// Slaves should run after killing slavemaster
+
+class COILFANGSLAVEMASTERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(COILFANGSLAVEMASTERAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    COILFANGSLAVEMASTERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+		
+        spells[0].info = dbcSpell.LookupEntry(GEYSER);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;		
+		spells[0].cooldown = 20;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(ENRAGE_SlAVEMASTER);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;		
+		spells[1].cooldown = 55;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Coilfang water elemental
+
+#define CN_COILFANG_WATER_ELEMENTAL 17917
+
+//#define FROSTBOLT_VOLLEY 36741
+#define WATER_BOLT_WOLLEY 34449
+// DAZED?
+class COILFANGWATERELEMENTALAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(COILFANGWATERELEMENTALAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    COILFANGWATERELEMENTALAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+/*
+        spells[0].info = dbcSpell.LookupEntry(FROSTBOLT_VOLLEY);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;		// Should be false, but doesn't work then
+		spells[0].cooldown = ;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+*/
+        spells[0].info = dbcSpell.LookupEntry(WATER_BOLT_WOLLEY);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Coilfang MyrmidonAI
+
+#define CN_COILFANG_MYRMIDON 17800
+
+#define SWEEPING_STRIKES 18765 // DBC: 18765, 12723 //35429
+#define CLEAVE 15622 //38260 // no idea about it's id
+#define EXECUTE 7160 //38959 // should activate only on target with <= 25% hp // not sure about it
+
+class COILFANGMYRMIDONAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(COILFANGMYRMIDONAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    COILFANGMYRMIDONAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(SWEEPING_STRIKES);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(CLEAVE);
+		spells[1].targettype = TARGET_VARIOUS;	// not sure
+		spells[1].instant = true;
+		spells[1].cooldown = 15;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(EXECUTE);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 35;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Tidal SurgerAI
+
+#define CN_TIDAL_SURGER 21695
+
+//#define KNOCKBACK 30056
+#define WATER_SPOUT 37250
+#define FROST_NOVA_SURGER 15531
+// Should has immunite to frost spells (as adds) + should has 
+// 3-4 minons (Idk if they should be spawned by script)
+
+class TIDALSURGERAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(TIDALSURGERAI);
+	SP_AI_Spell spells[2];
+	bool m_spellcheck[2];
+
+    TIDALSURGERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 2;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+/*
+		spells[0].info = dbcSpell.LookupEntry(KNOCKBACK);
+		spells[0].targettype = TARGET_ATTACKING; // should be random
+		spells[0].instant = true;
+		spells[0].cooldown = ;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+*/
+		spells[0].info = dbcSpell.LookupEntry(WATER_SPOUT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(FROST_NOVA_SURGER);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = 15;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Steamrigger MechanicAI
+
+#define CN_STEAMRIGGER_MECHANIC 17951
+
+#define REPAIR 31532
+// DAZED?
+
+class STEAMRIGGERMECHANICAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(STEAMRIGGERMECHANICAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    STEAMRIGGERMECHANICAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(REPAIR);
+		spells[0].targettype = TARGET_SELF;	//Should be mechanical ally =/
+		spells[0].instant = false;
+		spells[0].cooldown = 10;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+// Steam SurgerAI
+
+#define CN_STEAM_SURGER 21696
+
+#define WATER_BOLT 37252
+// DAZED?
+
+class STEAMSURGERAI : public CreatureAIScript
+{
+public:
+	ADD_CREATURE_FACTORY_FUNCTION(STEAMSURGERAI);
+	SP_AI_Spell spells[1];
+	bool m_spellcheck[1];
+
+    STEAMSURGERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 1;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+		spells[0].info = dbcSpell.LookupEntry(WATER_BOLT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+/*****************************/
+/*                           */
+/*         Boss AIs          */
+/*                           */
+/*****************************/
+
+struct Coords
+{
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+//Mekgineer Steamrigger
+
+static Coords spawnCoords[] =
+{
+    { -300.037842, -115.296227, -7.865229, 4.197916 },
+    { -330.083008, -121.505997, -7.985120, 5.061450 },
+    { -346.530273, -147.167892, -6.703687, 0.010135 }
+};
+
+#define CN_MEKGINEER_STEAMRIGGER 17796
+#define CN_STEAMRIGGER_MECHANIC 17951
+
+#define SUPER_SHRINK_RAY 31485
+#define SAW_BLADE 31486 // Or this: 35318
+#define ELECTRIFIED_NET 35107
+#define ENRAGE 41447  // No idea if these are good ids // still not sue
+
+// Must spawn 3 Steamrigger Mechanics when his health is on 75%, 50% and 25%
+class MEKGINEERSTEAMRIGGERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MEKGINEERSTEAMRIGGERAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    MEKGINEERSTEAMRIGGERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(SUPER_SHRINK_RAY);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 35;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SAW_BLADE);
+		spells[1].targettype = TARGET_ATTACKING; // when killed with VARIOUS (because with that caster attacks also himself) server crashes
+		spells[1].instant = true;
+		spells[1].cooldown = 20;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(ELECTRIFIED_NET);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 25;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(ENRAGE);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+		spells[3].soundid = 10374;
+		spells[3].speech = "Have fun dyin', cupcake!"; //cupcake?
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		Timer = 0;
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%4;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your in for a World-O-Hurt !");
+			_unit->PlaySoundToSet(10368);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Eat hot metal! Scumbag!");
+			_unit->PlaySoundToSet(10369);
+			break;
+		case 2:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I'll come over there!"); // really?
+			_unit->PlaySoundToSet(10370);
+			break;
+		case 3:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I'm bringin' the pain!"); // really2?
+			_unit->PlaySoundToSet(10371);
+			break;
+		}
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%3;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You just got served, Punk!");
+				_unit->PlaySoundToSet(10372);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I own you!");
+				_unit->PlaySoundToSet(10373);
+				break;
+			case 2:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Have fun dying, capcake!"); // capcake?
+				_unit->PlaySoundToSet(10374);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		Timer = 0;
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		Timer = 0;
+		CastTime();
+	   _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Mommy");
+       _unit->PlaySoundToSet(10375);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		Timer++;
+
+		if (Timer == 100)
+		{
+			_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		}
+
+		if(_unit->GetHealthPct() == 25 || _unit->GetHealthPct() == 50 || _unit->GetHealthPct() == 75)
+        {
+            Creature *cre = NULL;
+            for(int i = 0; i < 3; i++)
+            {
+                cre = _unit->GetMapMgr()->GetInterface()->SpawnCreature(CN_STEAMRIGGER_MECHANIC, 
+                    spawnCoords[i].x, spawnCoords[i].y,
+                    spawnCoords[i].z, spawnCoords[i].o,
+                    true, false, _unit->GetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE), 50); //63
+                if(cre)
+                {
+                    //cre->GetAIInterface()->MoveTo(14.161, -177.874, -85.649, 0.23);
+                    cre->GetAIInterface()->setOutOfCombatRange(100000);
+                }
+                cre = _unit->GetMapMgr()->GetInterface()->SpawnCreature(CN_STEAMRIGGER_MECHANIC, 
+                    spawnCoords[2-i].x, spawnCoords[2-i].y,
+                    spawnCoords[2-i].z, spawnCoords[2-i].o,
+                    true, false, _unit->GetUInt32Value(UNIT_FIELD_FACTIONTEMPLATE), 63);
+                if(cre)
+                {
+                    //cre->GetAIInterface()->MoveTo(27.133, -232.030, -84.188, 0.44);
+                    cre->GetAIInterface()->setOutOfCombatRange(100000);
+                }
+            }
+        }
+
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int Timer;
+	int nrspells;
+};
+
+
+// Hydromancer ThespiaAI
+
+#define CN_HYDROMANCER_THESPIA 17797
+
+#define ENVELOPING_WINDS 31718
+#define LIGHTNING_CLOUD 25033
+#define LUNG_BURST 31481
+
+class HYDROMANCERTHESPIAAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(HYDROMANCERTHESPIAAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    HYDROMANCERTHESPIAAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+        spells[0].info = dbcSpell.LookupEntry(ENVELOPING_WINDS);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 25;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(LIGHTNING_CLOUD);
+		spells[1].targettype = TARGET_DESTINATION;
+		spells[1].instant = true;				
+		spells[1].cooldown = 35;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(LUNG_BURST);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].cooldown = 20;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%3;
+		switch (RandomSpeach)
+		{
+		case 0:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "The depths will consume you!");
+			_unit->PlaySoundToSet(10361);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Meet your doom, surface dwellers!");
+			_unit->PlaySoundToSet(10362);
+			break;
+		case 2:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You will drown in blood!");
+			_unit->PlaySoundToSet(10363);
+			break;
+		}
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0: 
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "To the depths of oblivion with you!");
+				_unit->PlaySoundToSet(10364);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "For my Lady and Master.");
+				_unit->PlaySoundToSet(10365);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		CastTime();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Our matron will be ... The end of you");
+        _unit->PlaySoundToSet(10366);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+
+
+// Warlord Kalitresh AI
+
+#define CN_WARLORD_KALITRESH 17798
+
+#define IMPALE 34451 //24049 // 1 target Correct spell id? Maybe 34451 or ... correct
+#define HEAD_CRACK 16172
+#define WARLORDS_RAGE 36453 // DBC: 37081, 36453	// still he must be forced by Driller to cast it
+#define SPELL_REFLECTION 31534 //33961
+
+class WARLORDKALITRESHAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(WARLORDKALITRESHAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    WARLORDKALITRESHAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(IMPALE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].cooldown = 15;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(HEAD_CRACK);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].cooldown = 25;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(WARLORDS_RAGE);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].cooldown = 90;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+		spells[2].soundid = 10391;
+		spells[2].speech = "This is not nearly over!";
+
+		spells[3].info = dbcSpell.LookupEntry(SPELL_REFLECTION);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].cooldown = 20;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+        
+	} 
+
+    void OnCombatStart(Unit* mTarget)
+    {
+		CastTime();
+		int RandomSpeach;
+		sRand.randInt(1000);
+		RandomSpeach=rand()%3;
+		switch (RandomSpeach)
+		{
+		case 0: 
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your head will roll!");
+			_unit->PlaySoundToSet(10392);
+			break;
+		case 1:
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I despise all of your kind!");
+			_unit->PlaySoundToSet(10393);
+			break;
+		case 2:
+			/* Maybe an emote for "strange words"? */
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "No freaking idea :P");
+			_unit->PlaySoundToSet(10394);
+			break;
+		}
+
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%2;
+			switch (RandomSpeach)
+			{
+			case 0: 
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Squirm , Surface filth!");
+				_unit->PlaySoundToSet(10395);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Hahahahah");
+				_unit->PlaySoundToSet(10366);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+		CastTime();
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "For her exelency , For Vash...");
+        _unit->PlaySoundToSet(10397);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+	{
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+protected:
+
+	int nrspells;
+};
+
+void SetupTheSteamvault(ScriptMgr * mgr)
+{
+    mgr->register_creature_script(CN_COILFANG_ORACLE, &COILFANGORACLEAI::Create);
+    mgr->register_creature_script(CN_COILFANG_ENGINEER, &COILFANGENGINEERAI::Create);
+    mgr->register_creature_script(CN_COILFANG_WARRIOR, &COILFANGWARRIORAI::Create);
+	mgr->register_creature_script(CN_COILFANG_SIREN, &COILFANGSIRENAI::Create);
+	mgr->register_creature_script(CN_COILFANG_SORCERESS, &COILFANGSORCERESSAI::Create);
+	mgr->register_creature_script(CN_COILFANG_LEPER, &COILFANGLEPERAI::Create);
+	mgr->register_creature_script(CN_COILFANG_SLAVEMASTER, &COILFANGSLAVEMASTERAI::Create);
+	mgr->register_creature_script(CN_COILFANG_MYRMIDON, &COILFANGMYRMIDONAI::Create);
+	mgr->register_creature_script(CN_COILFANG_WATER_ELEMENTAL, &COILFANGWATERELEMENTALAI::Create);
+	mgr->register_creature_script(CN_BOG_OVERLORD, &BOGOVERLORDAI::Create);
+	mgr->register_creature_script(CN_TIDAL_SURGER, &TIDALSURGERAI::Create);
+	mgr->register_creature_script(CN_STEAM_SURGER, &STEAMSURGERAI::Create);
+	mgr->register_creature_script(CN_STEAMRIGGER_MECHANIC, &STEAMRIGGERMECHANICAI::Create);
+	mgr->register_creature_script(CN_HYDROMANCER_THESPIA, &HYDROMANCERTHESPIAAI::Create);
+	mgr->register_creature_script(CN_MEKGINEER_STEAMRIGGER, &MEKGINEERSTEAMRIGGERAI::Create);
+	mgr->register_creature_script(CN_WARLORD_KALITRESH, &WARLORDKALITRESHAI::Create);
+}
+
+
+/* TO DO: Check all spells/creatures and evenatually balance them (if needed!)
+   also add spawns correctly (no core support for now and hacky Onyxia way does
+   not work (in Onyxia also). Change target type when there will be more core
+   support. Also very imporant thing is to force spawns to heal random or target
+   you choosed. When that will work, I will add AI for mechanics who should
+   heal one of instance bosses.*/
+// Don't have infos about: Second Fragment Guardian (22891) | Dreghood Slave (17799 -
+// should they really have enrage ? [8269]), Driller should use Warlord's Rage spell
+// (31543) to force Warlord to enrage, but I need more infos about targeting target
+// you want to.
Index: src/InstanceScripts/Raid_GruulsLair.cpp
===================================================================
--- src/InstanceScripts/Raid_GruulsLair.cpp	(revision 0)
+++ src/InstanceScripts/Raid_GruulsLair.cpp	(revision 0)
@@ -0,0 +1,1051 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+/************************************************************************/
+/* Raid_GruulsLair.cpp Script											*/
+/************************************************************************/
+// Lair BruteAI
+#define CN_LAIR_BRUTE 19389
+
+#define MORTALSTRIKE	35054
+#define CLEAVE			31345
+#define CHARGE			35754
+
+class LairBruteAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(LairBruteAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    LairBruteAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+
+		spells[0].info = dbcSpell.LookupEntry(MORTALSTRIKE);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 9.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(CLEAVE);
+		spells[1].targettype = TARGET_ATTACKING;	
+		spells[1].instant = true;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(CHARGE);
+		spells[2].targettype = TARGET_ATTACKING; // Needs checking
+		spells[2].instant = true;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+	}
+	void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+	void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						target = _unit->GetAIInterface()->GetNextTarget();
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+
+protected:
+
+	int nrspells;
+};
+
+// Gronn PriestAI
+#define CN_GRONN_PRIEST 21350
+
+#define PSYCHICSCREAM	34322       //33130 - death coil
+#define RENEW			36679
+#define HEAL_GRONN_PRIEST 36678		// it's instead of PRAYER_OF_HEALING
+//#define PRAYER_OF_HEALING	33152	// couldn't find infos about it so disabled
+
+class GronnPriestAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(GronnPriestAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    GronnPriestAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+
+		spells[0].info = dbcSpell.LookupEntry(PSYCHICSCREAM);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(RENEW);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].perctrigger = 6.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(HEAL_GRONN_PRIEST);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = false;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 5000;
+
+	}
+	void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+	void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+
+protected:
+
+	int nrspells;
+};
+
+/*****************************/
+/*                           */
+/*         Boss AIs          */
+/*                           */
+/*****************************/
+
+// Kiggler The CrazedAI
+#define CN_KIGGLER_THE_CRAZED 18835
+
+#define LIGHTNING_BOLT	36152
+#define GREATER_POLYMORPH 33173
+#define ARCANE_EXPLOSION 33237
+#define	ARCANE_SHOCK	33175
+//#define HEX				36700
+//#define ARCANE_BLAST		31457	 //have none 10yd SPELL
+
+class KigglerTheCrazedAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(KigglerTheCrazedAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    KigglerTheCrazedAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+
+		spells[0].info = dbcSpell.LookupEntry(LIGHTNING_BOLT);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].perctrigger = 12.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(GREATER_POLYMORPH);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].perctrigger = 8.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(ARCANE_EXPLOSION);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].perctrigger = 12.0f;
+		spells[2].attackstoptimer = 1000; 
+
+
+		spells[3].info = dbcSpell.LookupEntry(ARCANE_SHOCK);
+		spells[3].targettype = TARGET_ATTACKING;
+		spells[3].instant = true;
+		spells[3].perctrigger = 8.0f;
+		spells[3].attackstoptimer = 1000;
+
+	}
+	void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+	void AIUpdate()
+    {
+/*
+		if(_unit->GetDistanceSq(target)<20)  <--- why do you need this??
+			_unit->CastSpell(_unit, spells[2].info, spells[2].instant);
+																			*/
+/*		
+		if(m_spellcheck[1] == true) //<^-------- Both functions crash server in this place
+			_unit->GetAIInterface()->GetNextTarget();  
+																			*/
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+
+protected:
+
+	Unit *target;
+	int nrspells;
+};
+// Blindeye The SeerAI
+#define CN_BLINDEYE_THE_SEER 18836
+
+#define PRAYER_OF_HEALING 33152
+#define GREAT_POWER_WORD_SHIELD	33147
+#define HEAL 33144
+
+class BlindeyeTheSeerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(BlindeyeTheSeerAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    BlindeyeTheSeerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+
+		spells[0].info = dbcSpell.LookupEntry(PRAYER_OF_HEALING);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = false;
+		spells[0].perctrigger = 10.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(GREAT_POWER_WORD_SHIELD);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = true;
+		spells[1].perctrigger = 5.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(HEAL);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = false;
+		spells[2].perctrigger = 5.0f;
+		spells[2].attackstoptimer = 1000;
+
+	}
+	void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+	void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+
+protected:
+
+	int nrspells;
+};
+// Olm The SummonerAI
+#define CN_OLM_THE_SUMMONER 18834
+
+#define DEATH_COIL		33130 // ?
+#define SUMMON_WILD_FEL_STALKER	33131 // Need to add AI for it to make it blizzlike anyway (it's wild felhunter and should be fel stalker?)
+#define DARK_DECAY		33129
+#define HEAL_OLM		31730	// not sure if this should be that healing spell
+
+class OlmTheSummonerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(OlmTheSummonerAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    OlmTheSummonerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+
+		spells[0].info = dbcSpell.LookupEntry(DEATH_COIL);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 7.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(SUMMON_WILD_FEL_STALKER);
+		spells[1].targettype = TARGET_SELF;
+		spells[1].instant = false;
+		spells[1].perctrigger = 2.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(DARK_DECAY);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].perctrigger = 10.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(HEAL_OLM);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = false;
+		spells[3].perctrigger = 10.0f;
+		spells[3].attackstoptimer = 1000;
+
+	}
+	void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+	void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+
+protected:
+
+	int nrspells;
+};
+// Krosh FirehandAI
+#define CN_KROSH_FIREHAND 18832
+
+#define GREAT_FIREBALL	33051
+#define BALST_WAVE		33061
+#define FIRE_WARD		37844
+//#define FIREBALL 37463
+//#define SPELLSHIELD 33054
+
+class KroshFirehandAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(KroshFirehandAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    KroshFirehandAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		FireWardCooldown=30;
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+
+		spells[0].info = dbcSpell.LookupEntry(GREAT_FIREBALL);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = false;
+		spells[0].perctrigger = 20.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(BALST_WAVE);
+		spells[1].targettype = TARGET_DESTINATION;
+		spells[1].instant = true;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(FIRE_WARD);
+		spells[2].targettype = TARGET_SELF;
+		spells[2].instant = true;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+	}
+	void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		FireWardCooldown=30;
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+		FireWardCooldown=30;
+       RemoveAIUpdateEvent();
+    }
+
+	void AIUpdate()
+    {
+		FireWardCooldown--;
+		if(!FireWardCooldown)//_unit->getAttackTarget())
+        {
+			_unit->CastSpell(_unit, spells[2].info, spells[2].instant);
+			FireWardCooldown=30;
+		}
+	/*
+		if(_unit->GetDistanceSq(target)<20) // bad idea, as long as I can see that
+			_unit->CastSpell(_unit, spells[2].info, spells[2].instant);
+																					*/
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+    }
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+
+protected:
+
+	Unit *target;
+	uint32 FireWardCooldown;
+	int nrspells;
+};
+
+// MaulgarAI
+#define CN_HIGH_KING_MAULAGR 18831
+
+#define ARCINGSMASH		38761
+#define MIGHTYBLOW		33230
+#define WHIRLWIND		33239
+#define ENRAGE			34970 // no idea about id, can be also: 34970, 37023 and others as nowhere is told which Enrage it should be
+
+class HighKingMaulgarAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(HighKingMaulgarAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    HighKingMaulgarAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+
+		spells[0].info = dbcSpell.LookupEntry(ARCINGSMASH);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].perctrigger = 15.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(MIGHTYBLOW);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].perctrigger = 10.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(WHIRLWIND);
+		spells[2].targettype = TARGET_VARIOUS; // Should attk party member with second the highest aggro in melee range
+		spells[2].instant = true;
+		spells[2].perctrigger = 9.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(ENRAGE);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].perctrigger = 5.0f;
+		spells[3].attackstoptimer = 1000;
+		spells[3].speech = "You will not defeat the hand of Gruul!";
+		spells[3].soundid = 11368;
+	}
+	void OnCombatStart(Unit* mTarget)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "<missing_word> on a real power in Outland!");
+		_unit->PlaySoundToSet(11367);
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Grull will crash you!");
+		_unit->PlaySoundToSet(11376);
+       RemoveAIUpdateEvent();
+    }
+
+	void OnTargetDied(Unit* mTarget)
+	{
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%3;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You're not so tough after all!");
+				_unit->PlaySoundToSet(11373);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Whahaha!"); // more accurate?
+				_unit->PlaySoundToSet(11374);
+				break;
+			case 2:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Maulgar is king!");
+				_unit->PlaySoundToSet(11375);
+				break;
+			}
+		}
+	}
+
+	void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+
+protected:
+
+	int nrspells;
+};
+// GruulsAI
+
+#define CN_GRUUL_THE_DRAGONKILLER 19044
+
+#define GROWTH            36300 
+#define CAVE_IN           36240 
+#define GROUND_SLAM       33525
+#define SHATTER           33671	// Should be used only when Stoned
+#define HURTFUL_STRIKE    33813 
+#define REVERBERATION     36297 
+#define STONED			  33652 
+#define GRONN_LORDS_GRASP 33572 // Should be used only after Ground Slam
+// % chances changed to let boss use normal attks too
+// Note: Maybe we should add additional spell description option to
+// define next spells.
+
+// TO DO: Find out what rest of sounds are for and add feature to random choose between
+// several spell sounds.
+
+class GruulsTheDragonkillerAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(GruulsTheDragonkillerAI);
+	SP_AI_Spell spells[8];
+	bool m_spellcheck[8];
+
+    GruulsTheDragonkillerAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		GrowthCooldown = 30;
+		nrspells = 8;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+
+		} 
+		spells[0].info = dbcSpell.LookupEntry(GROWTH);
+		spells[0].targettype = TARGET_SELF;
+		spells[0].instant = true;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(CAVE_IN);
+		spells[1].targettype = TARGET_DESTINATION;
+		spells[1].instant = true;
+		spells[1].perctrigger = 10.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(HURTFUL_STRIKE);
+		spells[2].targettype = TARGET_ATTACKING; // Should attk party member with second the highest aggro in melee range
+		spells[2].instant = true;
+		spells[2].perctrigger = 3.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(REVERBERATION);
+		spells[3].targettype = TARGET_VARIOUS;
+		spells[3].instant = true;
+		spells[3].perctrigger = 6.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(GROUND_SLAM);
+		spells[4].targettype = TARGET_DESTINATION;
+		spells[4].instant = false;
+		spells[4].perctrigger = 7.0f;
+		spells[4].attackstoptimer = 2000;
+		spells[4].speech = "Scary!"; // has 2 sounds for one spell :O
+		spells[4].soundid = 11357;
+		//spells[4].speech = ""No escape!; // has 2 sounds for one spell :O
+		//spells[4].soundid = 11356;
+
+		spells[5].info = dbcSpell.LookupEntry(SHATTER);
+		spells[5].targettype = TARGET_VARIOUS;
+		spells[5].instant = true;
+		spells[5].perctrigger = 6.0f;
+		spells[5].attackstoptimer = 1000;
+
+		spells[6].info = dbcSpell.LookupEntry(STONED);
+		spells[6].targettype = TARGET_SELF;
+		spells[6].instant = true;
+		spells[6].perctrigger = 7.0f;
+		spells[6].attackstoptimer = 1000;
+
+		spells[7].info = dbcSpell.LookupEntry(GRONN_LORDS_GRASP);
+		spells[7].targettype = TARGET_SELF; // <-- not sure to that (description tells it works like that, but should it really be casted on boss?)
+		spells[7].instant = true;
+		spells[7].perctrigger = 6.0f;
+		spells[7].attackstoptimer = 1000;
+
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Come and die!");
+		_unit->PlaySoundToSet(11355);
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%3;
+			switch (RandomSpeach)
+			{
+			case 0:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "No more!");
+				_unit->PlaySoundToSet(11360);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Unworthy!");
+				_unit->PlaySoundToSet(11361);
+				break;
+			case 2:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Die!");
+				_unit->PlaySoundToSet(11362);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        GrowthCooldown = 30;
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Wraaaa!"); // more correct please ? :P
+		_unit->PlaySoundToSet(11363);
+       RemoveAIUpdateEvent();
+       GrowthCooldown = 30;
+    }
+
+    void AIUpdate()
+    {
+		GrowthCooldown--;
+		if(!GrowthCooldown)//_unit->getAttackTarget())
+        {
+		_unit->CastSpell(_unit, spells[0].info, spells[0].instant);
+		GrowthCooldown=30;
+		}
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+                  	m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	uint32 GrowthCooldown;
+	int nrspells;
+};
+void SetupGruulsLair(ScriptMgr * mgr)
+{
+	mgr->register_creature_script(CN_LAIR_BRUTE, &LairBruteAI::Create);
+	mgr->register_creature_script(CN_GRONN_PRIEST, &GronnPriestAI::Create);
+	mgr->register_creature_script(CN_KIGGLER_THE_CRAZED, &KigglerTheCrazedAI::Create);
+	mgr->register_creature_script(CN_BLINDEYE_THE_SEER, &BlindeyeTheSeerAI::Create);
+	mgr->register_creature_script(CN_OLM_THE_SUMMONER, &OlmTheSummonerAI::Create);
+	mgr->register_creature_script(CN_KROSH_FIREHAND, &KroshFirehandAI::Create);
+	mgr->register_creature_script(CN_HIGH_KING_MAULAGR,	&HighKingMaulgarAI::Create);
+    mgr->register_creature_script(CN_GRUUL_THE_DRAGONKILLER, &GruulsTheDragonkillerAI::Create);
+}
Index: src/InstanceScripts/Raid_Karazhan.cpp
===================================================================
--- src/InstanceScripts/Raid_Karazhan.cpp	(revision 0)
+++ src/InstanceScripts/Raid_Karazhan.cpp	(revision 0)
@@ -0,0 +1,2627 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+
+/************************************************************************/
+/* Raid_Karazhan.cpp Script                                             */
+/************************************************************************/
+
+struct Coords
+{
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+/*****************************/
+/*                           */
+/*         Boss AIs          */
+/*                           */
+/*****************************/
+
+// Midnight AI
+#define CN_MIDNIGHT 16151
+
+#define CN_ATTUMEN 15550
+
+/*
+#define SUMMON_ATTUMEN 29714 // summons Attumen but wrong faction (neutral)
+#define SUMMON_MOUNTED_ATTUMEN 29799 // summons mounted Attumen; wrong faction
+#define MOUNT_ATTUMEN 29770 // broken or maybe should be called from Attumen (so also wont work because missing core support)
+#define MOUNT_ATTUMEN 29769 // broken?!
+*/
+
+class MIDNIGHTAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MIDNIGHTAI);
+
+    MIDNIGHTAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        attumen = NULL;
+        m_phase = 1;
+
+//        infoSummonAttumen = dbcSpell.LookupEntry(SUMMON_ATTUMEN);
+//        infoMountAttumen = dbcSpell.LookupEntry(MOUNT_ATTUMEN);
+   }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    { 
+        if(m_phase==2)
+        {
+            _unit->PlaySoundToSet(9173);
+	    attumen->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Well done Midnight!");
+        }
+    }
+    void AIUpdate()
+    {
+        switch(m_phase)
+        {
+        case 1:
+	    PhaseOne();
+	    break;
+        case 2:
+            PhaseTwo();
+	    break;
+        case 3:
+            break;
+        default:
+	    m_phase = 1;
+        };
+    }
+
+    void PhaseOne()
+    {
+        if(_unit->GetHealthPct() <= 91)
+        {
+            // summon Attumen
+            attumen = _unit->GetMapMgr()->GetInterface()->SpawnCreature(CN_ATTUMEN,
+                   _unit->GetPositionX(), _unit->GetPositionY(),
+                    _unit->GetPositionZ(), _unit->GetOrientation(),
+                    true, false, 0, 0);
+//            _unit->CastSpell(_unit, infoSummonAttumen, true);
+            m_phase = 2;
+        }
+    }
+
+    void PhaseTwo()
+    {
+        if(_unit->GetHealthPct() <= 25)
+        {
+            // mount Attumen
+            _unit->PlaySoundToSet(9168);
+            attumen->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, 
+                    "Come Midnight, let's disperse this petty rabble!");
+
+            attumen->SetUInt32Value(UNIT_FIELD_DISPLAYID , 16040);
+            Creature *midnight = ((Creature*) _unit);
+            midnight->Despawn(0, 0); 
+//            _unit->CastSpell(_unit, infoMountAttumen, true);
+            m_phase = 3;
+        }
+    }
+
+protected:
+    uint32 m_phase;
+    Creature *attumen;
+//    SpellEntry *infoSummonAttumen;
+//    SpellEntry *infoMountAttumen;
+};
+
+
+// Attumen AI
+
+#define SHADOW_CLEAVE 29832
+#define BERSERKER_CHARGE 26561
+#define INTANGIBLE_PRESENCE 29833
+#define ENRAGE 19953
+
+class ATTUMENAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ATTUMENAI);
+        bool m_spellcheck[3];
+        SP_AI_Spell spells[3];
+
+    ATTUMENAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        m_phase = 1;
+        nrspells = 2;
+	for(int i=0;i<3;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+	spells[0].info = dbcSpell.LookupEntry(SHADOW_CLEAVE);
+	spells[0].targettype = TARGET_ATTACKING;
+	spells[0].instant = true;
+	spells[0].cooldown = 15;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(INTANGIBLE_PRESENCE);
+	spells[1].targettype = TARGET_VARIOUS;
+	spells[1].instant = true;
+	spells[1].cooldown = 20;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+
+	spells[2].info = dbcSpell.LookupEntry(BERSERKER_CHARGE);
+	spells[2].targettype = TARGET_SELF;
+	spells[2].instant = true;
+	spells[2].cooldown = 15;
+	spells[2].perctrigger = 0.0f;
+	spells[2].attackstoptimer = 1000;
+
+        infoEnrage = dbcSpell.LookupEntry(ENRAGE);
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%3;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9167;
+                text = "Cowards! Wretches!";
+		break;
+            case 1:
+                sound = 9298;
+                text = "Who dares attack the steed of the Huntsman?";
+		break;
+            case 2:
+                sound = 9299;
+                text = "Perhaps you would rather test yourselves against a more formidable opponent?!";
+		break;
+        }
+        CastTime();
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+        CastTime();
+	_unit->PlaySoundToSet(9165);
+	_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Always knew... someday I would become... the hunted.");
+	RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9169;
+                text = "Your impurity must be cleansed.";
+		break;
+            case 1:
+                sound = 9300;
+                text = "Another trophy to add to my collection!";
+		break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void AIUpdate()
+    {
+        switch(m_phase)
+        {
+	    case 1:
+	        PhaseOne();
+	        break;
+            case 2:
+	        break;
+        default:
+                m_phase = 1;
+        };
+	float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void PhaseOne()
+    {
+        if(_unit->GetUInt32Value(UNIT_FIELD_DISPLAYID) == 16040)
+        {
+            // we've mounted so reset hp
+            static_cast<Creature*>(_unit)->RegenerateHealth();
+	    // TODO: reset aggro
+            m_phase = 2;
+        }
+        else if(_unit->GetHealthPct() <= 25)
+        {
+            _unit->CastSpell(_unit, infoEnrage, true);
+            m_phase = 2;
+            nrspells = 3;
+        }
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<3;i++)
+            spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    uint32 m_phase;
+    uint32 nrspells;
+    SpellEntry *infoEnrage;
+};
+
+// Moroes AI
+#define CN_MOROES 15687
+
+#define VANISH 31619
+#define GARROTE 37066 
+#define BLIND 34694
+#define GOUGE 36862
+#define ENRAGE 19953
+
+class MOROESAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MOROESAI);
+        bool m_spellcheck[2];
+        SP_AI_Spell spells[2];
+
+    MOROESAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        nrspells = 2;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	} 
+
+	spells[0].info = dbcSpell.LookupEntry(BLIND);
+	spells[0].targettype = TARGET_ATTACKING; // TODO: should be random target in melee range
+	spells[0].instant = true;
+	spells[0].cooldown = 20;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(GOUGE);
+	spells[1].targettype = TARGET_ATTACKING;
+	spells[1].instant = true;
+	spells[1].cooldown = 15;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+
+	infoVanish = dbcSpell.LookupEntry(VANISH);
+	infoGarrote = dbcSpell.LookupEntry(GARROTE);
+	infoEnrage = dbcSpell.LookupEntry(ENRAGE);
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+        m_enraged = false;
+        m_time_vanish = 30;
+        _unit->PlaySoundToSet(9211);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, 
+                "Hmm, unannounced visitors? Preparations must be made.");
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       CastTime();
+       _unit->PlaySoundToSet(9213);
+       _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "How terribly clumsy of me...");
+       RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%3;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9214;
+                text = "One more for dinner this evening.";
+		break;
+            case 1:
+                sound = 9314;
+                text = "Time... Never enough time.";
+		break;
+            case 2:
+                sound = 9315;
+                text = "I've gone and made a mess.";
+		break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void AIUpdate()
+    {
+        m_time_vanish--;
+        if(vanished && _unit->GetAIInterface()->GetNextTarget()) {
+            _unit->CastSpell(_unit->GetAIInterface()->GetNextTarget(), infoGarrote, true);
+            vanished = false;
+            m_time_vanish = 30;
+        }
+        else if(!m_time_vanish) {
+            CastVanish();
+        }
+        else if(!m_enraged && _unit->GetHealthPct() <= 30)
+        {
+            _unit->CastSpell(_unit, infoEnrage, true);
+            m_enraged = true;
+        }
+        else {
+	    float val = sRand.rand(100.0f);
+            SpellCast(val);
+	}
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<nrspells;i++)
+	    spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+    void CastVanish()
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9215;
+                text = "Now, where was I? Oh yes...";
+              break;
+            case 1:
+                sound = 9316;
+                text = "You rang?";
+              break;
+        }
+        _unit->CastSpell(_unit, infoVanish, true);
+        vanished = true;
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+protected:
+    bool m_enraged;
+    bool vanished;
+    uint32 nrspells;
+    uint32 m_time_vanish;
+    SpellEntry *infoGarrote;
+    SpellEntry *infoVanish;
+    SpellEntry *infoEnrage;
+};
+
+// Maiden of Virtue AI
+#define CN_MAIDEN 16457
+
+#define REPENTANCE 29511
+#define HOLY_FIRE 29522
+#define HOLY_WRATH 28883
+#define HOLY_GROUND 29512
+
+class MAIDENOFVIRTUEAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MAIDENOFVIRTUEAI);
+        bool m_spellcheck[3];
+        SP_AI_Spell spells[3];
+
+    MAIDENOFVIRTUEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        SpellEntry *infoImmunity;
+        nrspells = 2;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+        // spell buggy: should be VARIOUS but this targets the maiden?!
+	spells[0].info = dbcSpell.LookupEntry(HOLY_FIRE);
+	spells[0].targettype = TARGET_ATTACKING;
+	spells[0].instant = true;
+	spells[0].cooldown = 15;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+// emsy: removed, 100yrd range and infinite jumps
+/*	spells[1].info = dbcSpell.LookupEntry(HOLY_WRATH);
+	spells[1].targettype = TARGET_VARIOUS;
+	spells[1].instant = true;
+	spells[1].cooldown = 20;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000; */
+
+        // temporary fix for broken spell: cast holy ground every 2 secs since its triggered only once
+	spells[1].info = dbcSpell.LookupEntry(HOLY_GROUND);
+	spells[1].targettype = TARGET_SELF;
+	spells[1].instant = true;
+	spells[1].cooldown = 2;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+
+	infoRepentance = dbcSpell.LookupEntry(REPENTANCE);
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+        m_time_repentance = 25 + sRand.randInt(100)%10;
+        _unit->PlaySoundToSet(9204);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your behavior will not be tolerated!");
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+        CastTime();
+        _unit->PlaySoundToSet(9206);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Death comes. Will your conscience be clear?");
+        RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%3;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9207;
+                text = "Anh ah ah...";
+		break;
+            case 1:
+                sound = 9311;
+                text = "This is for the best.";
+		break;
+            case 2:
+                sound = 9312;
+                text = "Impure thoughts lead to profane actions.";
+		break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void AIUpdate()
+    {
+        if(!RepentanceTrigger()) {
+	    float val = sRand.rand(100.0f);
+            SpellCast(val);
+        }
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<nrspells;i++)
+	    spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+    bool RepentanceTrigger()
+    {
+        if(!m_time_repentance) {
+            uint32 sound, val = (uint32) sRand.randInt(100)%2;
+            char *text;
+            switch(val)
+            {
+                case 0:
+                    sound = 9208;
+                    text = "Your impurity must be cleansed.";
+                  break;
+                case 1:
+                    sound = 9313;
+                    text = "Cast out your corrupt thoughts";
+                  break;
+            }
+            _unit->PlaySoundToSet(sound);
+            _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+            _unit->CastSpell(_unit, infoRepentance, true);
+            m_time_repentance = 25 + sRand.randInt(100)%10;
+            return true;
+        }
+        else
+            m_time_repentance--;
+        return  false;
+    }
+
+protected:
+    uint32 nrspells;
+    uint32 m_time_repentance;
+    SpellEntry *infoRepentance;
+};
+
+// The Big Bad Wolf
+#define CN_THEBIGBADWOLF 17521
+
+#define TERRIFYING_HOWL 30752
+#define MORPH_LITTLE_RED_RIDING_HOOD 30768
+#define DEBUFF_LITTLE_RED_RIDING_HOOD 30756
+
+class THEBIGBADWOLFAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(THEBIGBADWOLFAI);
+        bool m_spellcheck[3];
+        SP_AI_Spell spells[3];
+
+    THEBIGBADWOLFAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        SpellEntry *infoImmunity;
+        nrspells = 3;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+	spells[0].info = dbcSpell.LookupEntry(TERRIFYING_HOWL);
+	spells[0].targettype = TARGET_VARIOUS;
+	spells[0].instant = true;
+	spells[0].cooldown = 30;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(MORPH_LITTLE_RED_RIDING_HOOD);
+	spells[1].targettype = TARGET_ATTACKING;
+	spells[1].instant = true;
+	spells[1].cooldown = 60;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+
+	spells[2].info = dbcSpell.LookupEntry(DEBUFF_LITTLE_RED_RIDING_HOOD);
+	spells[2].targettype = TARGET_ATTACKING;
+	spells[2].instant = true;
+	spells[2].cooldown = 60;
+	spells[2].perctrigger = 0.0f;
+	spells[2].attackstoptimer = 1000;
+        spells[2].soundid = 9278;
+        spells[2].speech = "Run away little girl, run away!";
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+        _unit->PlaySoundToSet(9276);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "The better to own you with!");
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+        CastTime();
+        _unit->PlaySoundToSet(9275);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "AArrhhh.");
+        RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    {
+        _unit->PlaySoundToSet(9277);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Mmmm... delicious.");
+    }
+
+    void AIUpdate()
+    {
+	float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<nrspells;i++)
+	    spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    uint32 nrspells;
+};
+
+// The Curator
+#define CN_THECURATOR 15691
+#define CN_ASTRALFLARE 17096
+
+#define HATEFUL_BOLT 30383
+#define EVOCATION 30254
+#define ENRAGE 19953
+#define BERSERK 26662
+
+class THECURATORAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(THECURATORAI);
+      SP_AI_Spell spellBolt;
+      bool m_spellcheck;
+
+    THECURATORAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+	m_spellcheck = false;
+	spellBolt.info = dbcSpell.LookupEntry(HATEFUL_BOLT);
+	spellBolt.instant = true;
+	spellBolt.cooldown = 15;
+
+	infoEvocation = dbcSpell.LookupEntry(EVOCATION);
+	infoEnrage = dbcSpell.LookupEntry(ENRAGE);
+	infoBerserk = dbcSpell.LookupEntry(BERSERK);
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        m_time_summon = 10;
+        m_time_berserk = 720;
+        evocation = false;
+        enrage = false;
+        berserk = false;
+        _unit->PlaySoundToSet(9183);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "The Menagerie is for guests only.");
+        RegisterAIUpdateEvent(1000);
+        CastTime();
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+        CastTime();
+        _unit->PlaySoundToSet(9184);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "This Curator is no longer op... er... ation... al.");
+        RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9186;
+                text = "Do not touch the displays.";
+                break;
+            case 1:
+                sound = 9308;
+                text = "You are not a guest.";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void AIUpdate()
+    {
+        if(!evocation)
+        {
+            if(_unit->GetManaPct() <= 10)
+            {
+                _unit->PlaySoundToSet(9186);
+                _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your request cannot be processed.");
+                _unit->CastSpell(_unit, infoEvocation, true);
+                evocation = true;
+            }
+            else if(!enrage && _unit->GetHealthPct() <= 16)
+            {
+    	        _unit->CastSpell(_unit, infoEnrage, true);
+                _unit->PlaySoundToSet(9185);
+                _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Failure to comply will result in offensive action.");
+                enrage = true;
+            }
+            else if(!TimedTrigger())
+                CastBolt();
+        }
+        else if(_unit->GetManaPct() > 90)
+            evocation = false;
+    }
+
+    void CastTime()
+    {
+	spellBolt.casttime = spellBolt.cooldown;
+    }
+
+    void CastBolt()
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    Unit *target = NULL;
+	    spellBolt.casttime--;
+	    if(spellBolt.casttime) return;
+		
+	    if (!spellBolt.casttime && m_spellcheck)
+	    {
+		spellBolt.casttime = spellBolt.cooldown;
+		target = _unit->GetAIInterface()->GetNextTarget();
+		    _unit->CastSpell(_unit, spellBolt.info, spellBolt.instant);
+    	        m_spellcheck = false;
+	        return;
+	    }
+            m_spellcheck = true;
+	}
+    }
+
+    bool TimedTrigger()
+    {
+        m_time_berserk--;
+        m_time_summon--;
+        if(!berserk && !m_time_berserk) {
+	    _unit->CastSpell(_unit, infoBerserk, true);
+            berserk = true;
+            return true;
+        }
+        else if(!enrage && !m_time_summon) {
+            uint32 sound, val = (uint32) sRand.randInt(100)%2;
+            char *text;
+            switch(val)
+            {
+                case 0:
+                    sound = 9188;
+                    text = "Gallery rules will be strictly enforced.";
+                    break;
+                case 1:
+                    sound = 9309;
+                    text = "This curator is equipped for gallery protection.";
+                    break;
+            }
+            _unit->PlaySoundToSet(sound);
+            _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+            // spawn a new flare
+            // TODO: summon on n/e/s/w positions
+            // Temporary hack to reduce mana by 10%
+            _unit->SetUInt32Value(UNIT_FIELD_POWER1,
+                _unit->GetUInt32Value(UNIT_FIELD_POWER1) - (_unit->GetUInt32Value(UNIT_FIELD_MAXPOWER1) / 10));
+            _unit->GetMapMgr()->GetInterface()->SpawnCreature(CN_ASTRALFLARE,
+                   _unit->GetPositionX(), _unit->GetPositionY(),
+                    _unit->GetPositionZ(), _unit->GetOrientation(),
+                    true, false, 0, 0);
+            m_time_summon = 10;
+            return true;
+        }
+        return  false;
+    }
+
+protected:
+    bool evocation;
+    bool enrage;
+    bool berserk;
+    uint32 m_time_summon;
+    uint32 m_time_berserk;
+    SpellEntry *infoEvocation;
+    SpellEntry *infoEnrage;
+    SpellEntry *infoBerserk;
+};
+
+// Astral Flare
+#define ASTRAL_FLARE_PASSIVE 30234
+#define ARCING_SCAR 30325
+#define ASTRAL_FLARE_VISUAL 30237
+
+class ASTRALFLAREAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ASTRALFLAREAI);
+        bool m_spellcheck[2];
+        SP_AI_Spell spells[2];
+
+    ASTRALFLAREAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        nrspells = 2;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+/*	spells[0].info = dbcSpell.LookupEntry(ASTRAL_FLARE_PASSIVE);
+	spells[0].targettype = TARGET_VARIOUS;
+	spells[0].instant = true;
+	spells[0].cooldown = 3;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+*/
+	spells[0].info = dbcSpell.LookupEntry(ARCING_SCAR);
+	spells[0].targettype = TARGET_VARIOUS;
+	spells[0].instant = true;
+	spells[0].cooldown = 1;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(ASTRAL_FLARE_VISUAL);
+	spells[1].targettype = TARGET_VARIOUS;
+	spells[1].instant = true;
+	spells[1].cooldown = 1;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+        CastTime();
+        RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+	float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<nrspells;i++)
+            spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    uint32 nrspells;
+};
+
+// Shade of Aran
+#define CN_SHADEOFARAN 16524
+
+#define FROSTBOLT 29954
+#define FIREBALL 29953
+#define ARCMISSLE 29955
+#define CHAINSOFICE 29991
+#define DRAGONSBREATH 29964
+#define CIRCULAR_BLIZZAR 29952
+#define MASSSLOW 30035
+#define MAGNETIC_PULL 29979
+#define FLAME_WREATH 29946 // detonate -> 30004
+#define AOE_COUNTERSPELL 29961
+#define AEXPLOSION 29973
+#define MASS_POLYMORPH 29963
+#define BLINK_CENTER 29967
+#define SUMMON_ELEMENTALS 29962
+#define CONJURE 29975
+#define AOE_PYROBLAST 29978
+
+class SHADEOFARANAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(SHADEOFARANAI);
+        bool m_spellcheck[6];
+        SP_AI_Spell spells[6];
+
+    SHADEOFARANAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        nrspells = 6;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+	spells[0].info = dbcSpell.LookupEntry(FROSTBOLT);
+	spells[0].targettype = TARGET_ATTACKING;
+	spells[0].instant = false;
+	spells[0].cooldown = 5;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(FIREBALL);
+	spells[1].targettype = TARGET_ATTACKING;
+	spells[1].instant = false;
+	spells[1].cooldown = 5;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+
+	spells[2].info = dbcSpell.LookupEntry(ARCMISSLE);
+	spells[2].targettype = TARGET_ATTACKING;
+	spells[2].instant = false;
+	spells[2].cooldown = 10;
+	spells[2].perctrigger = 0.0f;
+	spells[2].attackstoptimer = 1000;
+
+	spells[3].info = dbcSpell.LookupEntry(CHAINSOFICE);
+	spells[3].targettype = TARGET_ATTACKING;
+	spells[3].instant = true;
+	spells[3].cooldown = 10;
+	spells[3].perctrigger = 0.0f;
+	spells[3].attackstoptimer = 1000;
+
+	spells[4].info = dbcSpell.LookupEntry(DRAGONSBREATH);
+	spells[4].targettype = TARGET_ATTACKING;
+	spells[4].instant = true;
+	spells[4].cooldown = 10;
+	spells[4].perctrigger = 0.0f;
+	spells[4].attackstoptimer = 1000;
+
+	spells[5].info = dbcSpell.LookupEntry(AOE_COUNTERSPELL);
+	spells[5].targettype = TARGET_VARIOUS;
+	spells[5].instant = true;
+	spells[5].cooldown = 15;
+	spells[5].perctrigger = 0.0f;
+	spells[5].attackstoptimer = 1000;
+
+	info_flame_wreath = dbcSpell.LookupEntry(FLAME_WREATH);
+	info_blink_center = dbcSpell.LookupEntry(BLINK_CENTER);
+	info_massslow = dbcSpell.LookupEntry(MASSSLOW);
+	info_magnetic_pull = dbcSpell.LookupEntry(MAGNETIC_PULL);
+	info_aexplosion = dbcSpell.LookupEntry(AEXPLOSION);
+	info_blizzard = dbcSpell.LookupEntry(CIRCULAR_BLIZZAR);
+ 	info_summon_elementals = dbcSpell.LookupEntry(SUMMON_ELEMENTALS);
+	info_mass_polymorph = dbcSpell.LookupEntry(MASS_POLYMORPH);
+	info_conjure = dbcSpell.LookupEntry(CONJURE);
+	info_pyroblast = dbcSpell.LookupEntry(AOE_PYROBLAST);
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%3;
+        char *text;
+        switch(val)
+        {
+        // TODO: extra emote if Atiesh is equipped by a raid member
+        // 9249 - "Where did you get that?! Did HE send you?!"
+            case 0:
+                sound = 9241;
+                text = "Please, no more. My son... he's gone mad!";
+                break;
+            case 1:
+                sound = 9323;
+                text = "I'll not be tortured again!";
+                break;
+            case 2:
+                sound = 9324;
+                text = "Who are you? What do you want? Stay away from me!";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_SPELL);
+        RegisterAIUpdateEvent(1000);
+        m_time_enrage = 900;
+        m_time_special = 30 + (uint32) sRand.randInt(10)%5;
+        m_time_pyroblast = 0;
+        CastTime();
+        drinking = false;
+        enraged = false;
+        summoned = false;
+        explode = false;
+        slow = false;
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       CastTime();
+       _unit->PlaySoundToSet(9244);
+       _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "At last... The nightmare is.. over...");
+       RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0: {
+                sound = 9250;
+                text = "I want this nightmare to be over!";
+                } break;
+            case 1: {
+                sound = 9328;
+                text = "Torment me no more!";
+                } break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void AIUpdate()
+    {
+        if(!drinking) 
+	{
+	    if(explode)
+	    {
+                if(slow)
+                {
+                    _unit->CastSpell(_unit, info_massslow, true);
+                    slow = false;
+                }
+                else
+                {
+	            _unit->CastSpell(_unit, info_aexplosion, false);
+                    explode = false;
+                }
+	    }
+            else if(!summoned && _unit->GetHealthPct() <= 40)
+            {
+                _unit->CastSpell(_unit, info_summon_elementals, true);
+                _unit->PlaySoundToSet(9251);
+                _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I'm not finished yet! No, I have a few more tricks up me sleeve.");
+                summoned = true;
+            }
+            else if(_unit->GetManaPct() <= 20)
+            {
+                if(!m_time_pyroblast) 
+		{
+                    _unit->PlaySoundToSet(9248);
+                    _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Surely you would not deny an old man a replenishing drink? No, no I thought not.");
+                    m_time_pyroblast = 10;
+                    _unit->CastSpell(_unit, info_mass_polymorph, false);
+                }
+                else
+                {
+                    m_time_pyroblast--;
+                    // TODO: conjure spell broken :(
+                    _unit->CastSpell(_unit, info_conjure, false);
+                    drinking = true;
+                }
+            }
+            else
+                SpellTrigger();
+         }
+	 else
+	 {
+             m_time_pyroblast--;
+             if(!m_time_pyroblast)
+             {
+                 _unit->CastSpell(_unit, info_pyroblast, false);
+                 drinking = false;
+             }
+         }
+    }
+
+    void SpellTrigger()
+    {
+        m_time_enrage--;
+        m_time_special--;
+        if(!enraged && !m_time_enrage) {
+            // TODO: Enrage => Summon Shadows of Aran after 15 min
+            _unit->PlaySoundToSet(9247);
+            _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "You've wasted enough of my time. Let these games be finished!");
+            enraged = true;
+            return;
+        }
+        else if(!m_time_special)
+        {
+            CastSpecial();
+            m_time_special = 30 + (uint32) sRand.randInt(10)%5;
+            return;
+        }
+        else {
+	    float val = sRand.rand(100.0f);
+            SpellCast(val);
+        }
+    }
+
+    void EmoteBlizzard()
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9246;
+                text = "I'll freeze you all!";
+                break;
+            case 1:
+                sound = 9327;
+                text = "Back to the cold dark with you!";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void EmoteWreath()
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9245;
+                text = "I'll show you this beaten dog still has some teeth!";
+                break;
+            case 1:
+                sound = 9326;
+                text = "Burn you hellish fiends!";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void EmoteExplosion()
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9242;
+                text = "Yes, yes, my son is quite powerful... but I have powers of my own!";
+                break;
+            case 1:
+                sound = 9325;
+                text = "I am not some simple jester! I am Nielas Aran!";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void CastSpecial()
+    {
+        uint32 val = (uint32) sRand.randInt(100)%3;
+        switch(val)
+        {
+            case 0:
+                EmoteExplosion();
+		_unit->CastSpell(_unit, info_blink_center, true);
+		_unit->CastSpell(_unit, info_magnetic_pull, true);
+                explode = true;
+                slow = true;
+                break;
+            case 1:
+                EmoteBlizzard();
+		_unit->CastSpell(_unit, info_blizzard, true);
+                break;
+            case 2:
+                EmoteWreath();
+		_unit->CastSpell(_unit, info_flame_wreath, true);
+                break;
+	}
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<nrspells;i++)
+            spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    bool drinking;
+    bool enraged;
+    bool summoned;
+    bool explode;
+    bool slow;
+    uint32 nrspells;
+    uint32 m_time_enrage;
+    uint32 m_time_special;
+    uint32 m_time_pyroblast;
+    SpellEntry *info_flame_wreath;
+    SpellEntry *info_aexplosion;
+    SpellEntry *info_blizzard; 
+    SpellEntry *info_magnetic_pull;
+    SpellEntry *info_blink_center;
+    SpellEntry *info_massslow;
+    SpellEntry *info_conjure;
+    SpellEntry *info_summon_elementals;
+    SpellEntry *info_pyroblast;
+    SpellEntry *info_mass_polymorph;
+};
+
+// Terestian Illhoof
+#define CN_ILLHOOF 15688
+
+#define SHADOW_BOLT 19729
+#define SUMMON_DEMONCHAINS 30120 // maybe there's some Sacrifice id?!
+#define SUMMON_KIL_REK 30066
+//#define ENRAGE ?????
+// TODO: couldnt find Demonic-Portal spell
+
+class ILLHOOFAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(ILLHOOFAI);
+        bool m_spellcheck[2];
+        SP_AI_Spell spells[2];
+
+    ILLHOOFAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        nrspells = 2;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+	spells[0].info = dbcSpell.LookupEntry(SHADOW_BOLT);
+	spells[0].targettype = TARGET_ATTACKING;
+	spells[0].instant = true;
+	spells[0].cooldown = 5;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(SUMMON_DEMONCHAINS);
+	spells[1].targettype = TARGET_VARIOUS;
+	spells[1].instant = true;
+	spells[1].cooldown = 20;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+        _unit->PlaySoundToSet(9260);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Ah, you're just in time. The rituals are about to begin.");
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       CastTime();
+       _unit->PlaySoundToSet(9262);
+       _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "My life, is yours. Oh great one.");
+       RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9264;
+                text = "Your blood will anoint my circle.";
+                break;
+            case 1:
+                sound = 9329;
+                text = "The great one will be pleased.";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void AIUpdate()
+    {
+	float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void SummonImp()
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9265;
+                text = "Come, you dwellers in the dark. Rally to my call!";
+                break;
+            case 1:
+                sound = 9331;
+                text = "Gather, my pets. There is plenty for all.";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void SacrificePlayer()
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9263;
+                text = "Please, accept this humble offering, oh great one.";
+                break;
+            case 1:
+                sound = 9330;
+                text = "Let the sacrifice serve his testament to my fealty.";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<2;i++)
+            spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    uint32 nrspells;
+};
+
+// Kil'Rek
+#define CN_KIL_REK 17229
+
+#define AMPLIFY_FLAMES 30053
+#define BROKEN_PACT 30065
+
+class KILREKAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(KILREKAI);
+        bool m_spellcheck[2];
+        SP_AI_Spell spells[2];
+
+    KILREKAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        nrspells = 2;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+	spells[0].info = dbcSpell.LookupEntry(AMPLIFY_FLAMES);
+	spells[0].targettype = TARGET_ATTACKING;
+	spells[0].instant = true;
+	spells[0].cooldown = 5;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(BROKEN_PACT);
+	spells[1].targettype = TARGET_ATTACKING;
+	spells[1].instant = true;
+	spells[1].cooldown = 5;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+        CastTime();
+        RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+	float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<nrspells;i++)
+            spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    uint32 nrspells;
+};
+
+// Prince Malchezaar
+#define CN_MALCHEZAAR 15690
+#define CN_INFERNAL 89 // not shure if correct id
+#define CN_MALCHEZAARS_AXES 17650
+
+#define ENFEEBLE 30843
+#define SHADOWNOVA 30852
+#define SW_PAIN 30854
+#define THRASH_PASSIVE 12787 // should self-buff prince with 3391
+#define SUNDER_ARMOR 25225
+#define CLEAVE 15663
+#define AMPLIFY_DAMAGE 12738 //Axe's use this spell; maybe wrong spell => test 39095
+#define HELLFIRE 39132 // Infernals cast this once every 3 seconds
+#define SUMMON_INFERNAL ????? // WTF is this spells id?!
+
+#define SUMMON_AXES 30891
+#define WIELD_AXES 30857
+
+/* Emotes:
+SPECIAL? - 9223 - 9320
+AXETOSS2? - 9317
+*/
+
+class MALCHEZAARAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(MALCHEZAARAI);
+        bool m_spellcheck[5];
+        SP_AI_Spell spells[5];
+
+    MALCHEZAARAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        info_thrash = dbcSpell.LookupEntry(THRASH_PASSIVE);
+        info_shadownova = dbcSpell.LookupEntry(SHADOWNOVA);
+        info_enfeeble = dbcSpell.LookupEntry(ENFEEBLE);
+        info_sw_pain = dbcSpell.LookupEntry(SW_PAIN);
+        info_cleave = dbcSpell.LookupEntry(CLEAVE);
+        info_sunder_armor = dbcSpell.LookupEntry(SUNDER_ARMOR);
+
+        info_wield_axes = dbcSpell.LookupEntry(WIELD_AXES);
+        info_summon_axes = dbcSpell.LookupEntry(SUMMON_AXES);
+    }
+
+  void SetupSpells()
+    {
+        m_phase = 1;
+        nrspells = 4;
+        m_time_infernal = 45;
+
+	for(int i=0;i<5;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+	spells[0].info = info_thrash;
+	spells[0].targettype = TARGET_ATTACKING;
+	spells[0].instant = true;
+	spells[0].cooldown = 10;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = info_enfeeble;
+	spells[1].targettype = TARGET_VARIOUS;
+	spells[1].instant = true;
+	spells[1].cooldown = 25;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+
+	spells[2].info = info_shadownova;
+	spells[2].targettype = TARGET_VARIOUS;
+	spells[2].instant = false;
+	spells[2].cooldown = 25;
+	spells[2].perctrigger = 0.0f;
+	spells[2].attackstoptimer = 1000;
+
+	spells[3].info = info_sw_pain;
+	spells[3].targettype = TARGET_ATTACKING;
+	spells[3].instant = true;
+	spells[3].cooldown = 15;
+	spells[3].perctrigger = 0.0f;
+	spells[3].attackstoptimer = 1000;
+
+        spells[4].info = info_cleave;
+	spells[4].targettype = TARGET_ATTACKING;
+	spells[4].instant = true;
+	spells[4].cooldown = 6;
+	spells[3].perctrigger = 0.0f;
+	spells[3].attackstoptimer = 1000;
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+	SetupSpells();
+        _unit->PlaySoundToSet(9218);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Madness has brought you here to me. I shall be your undoing.");
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+       CastTime();
+       _unit->PlaySoundToSet(9221);
+       _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "I refuse to concede defeat. I am a prince of the Eredar! I am...");
+       RemoveAIUpdateEvent();
+    }
+
+    void OnTargetDied(Unit* mTarget)
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%3;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9222;
+                text = "You are, but a plaything, unfit even to amuse.";
+                break;
+            case 1:
+                sound = 9318;
+                text = "Your greed, your foolishness has brought you to this end.";
+                break;
+            case 2:
+                sound = 9319;
+                text = "Surely you did not think you could win.";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+    }
+
+    void AIUpdate()
+    {
+        switch(m_phase)
+        {
+            case 1:
+	        PhaseOne();
+		break;
+            case 2:
+	        PhaseTwo();
+		break;
+	    case 3: {
+	            float val = sRand.rand(100.0f);
+		    SpellCast(val);
+	        } break;
+	    default:
+	        m_phase = 1;
+        };
+
+        m_time_infernal--;
+        if(!m_time_infernal) {
+	    SummonInfernal();
+            if(m_phase==3)
+	        m_time_infernal = 20;
+            else
+                m_time_infernal = 45;
+        }
+    }
+
+    void PhaseOne()
+    {
+        if(_unit->GetHealthPct() <= 60)
+        {
+            _unit->PlaySoundToSet(9220);
+            _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Time is the fire in which you'll burn!");
+            spells[3].info = info_sunder_armor;
+	    spells[3].targettype = TARGET_ATTACKING;
+	    spells[3].instant = true;
+	    spells[3].cooldown = 10;
+            spells[3].casttime = 10;
+
+            // equip axes...not shure if this spells works :>
+            _unit->CastSpell(_unit, info_wield_axes, true);
+            
+            m_phase = 2;
+            nrspells = 5;
+        }
+	else {
+	    float val = sRand.rand(100.0f);
+            SpellCast(val);
+        }
+    }
+
+    void PhaseTwo()
+    {
+        if(_unit->GetHealthPct() <= 30)
+        {
+            _unit->PlaySoundToSet(9321);
+            _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "How can you hope to withstand against such overwhelming power?");            m_phase = 2;
+	    spells[1].info = info_sw_pain;
+	    spells[1].targettype = TARGET_ATTACKING;
+	    spells[1].instant = true;
+	    spells[1].cooldown = 15;
+            spells[1].casttime = 15;
+            // summon axes...not shure if this spells works :>
+            _unit->CastSpell(_unit, info_summon_axes, true);
+            m_phase = 3;
+            nrspells = 3;
+        }
+	else {
+	    float val = sRand.rand(100.0f);
+            SpellCast(val);
+        }
+    }
+
+    void SummonInfernal()
+    {
+        uint32 sound, val = (uint32) sRand.randInt(100)%2;
+        char *text;
+        switch(val)
+        {
+            case 0:
+                sound = 9322;
+                text = "You face not Malchezaar alone, but the legions I command!";
+                break;
+            case 1:
+                sound = 9224;
+                text = "All realities, all dimensions are open to me!";
+                break;
+        }
+        _unit->PlaySoundToSet(sound);
+        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, text);
+        // TODO: Spawn Infernal
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<5;i++)
+            spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    uint32 m_phase;
+    uint32 nrspells;
+    uint32 m_time_infernal;
+    SpellEntry *info_wield_axes;
+    SpellEntry *info_summon_axes;
+    SpellEntry *info_thrash;
+    SpellEntry *info_enfeeble;
+    SpellEntry *info_shadownova;
+    SpellEntry *info_sw_pain;
+    SpellEntry *info_cleave;
+    SpellEntry *info_sunder_armor;
+};
+
+// Netherspite
+#define CN_NETHERSPITE 15689
+
+#define NETHERBURN 30523
+#define VOIDZONE 30533
+#define NETHERBREATH 36631
+#define BERSERK 26662
+#define NETHERBURN_AURA 30522
+// TODO: Perservance, Serenity and Dominance
+
+class NETHERSPITEAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(NETHERSPITEAI);
+        bool m_spellcheck[4];
+        SP_AI_Spell spells[4];
+
+    NETHERSPITEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        nrspells = 4;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+	spells[0].info = dbcSpell.LookupEntry(NETHERBURN);
+	spells[0].targettype = TARGET_ATTACKING;
+	spells[0].instant = true;
+	spells[0].cooldown = 5;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(VOIDZONE);
+	spells[1].targettype = TARGET_DESTINATION;
+	spells[1].instant = false;
+	spells[1].cooldown = 15;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+
+	spells[2].info = dbcSpell.LookupEntry(NETHERBREATH);
+	spells[2].targettype = TARGET_ATTACKING;
+	spells[2].instant = false;
+	spells[2].cooldown = 5;
+	spells[2].perctrigger = 0.0f;
+	spells[2].attackstoptimer = 1000;
+
+	spells[3].info = dbcSpell.LookupEntry(BERSERK);
+	spells[3].targettype = TARGET_SELF;
+	spells[3].instant = true;
+	spells[3].cooldown = 540;
+	spells[3].perctrigger = 0.0f;
+	spells[3].attackstoptimer = 1000;
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+        CastTime();
+        RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+        float val = sRand.rand(100.0f);
+        SpellCast(val);
+    }
+
+    void CastTime()
+    {
+	for(int i=0;i<nrspells;i++)
+            spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    uint32 nrspells;
+};
+
+// Nightbane
+#define CN_NIGHTBANE 17225
+#define CN_RESTLESS_SKELETON 17261 // not needed if spell works
+
+#define WALK 0
+#define RUN 256
+#define FLY 768
+
+// ground spells
+#define BELLOWING_ROAR 36922
+#define CHARRED_EARTH 30129 //Also 30209 (Target Charred Earth) triggers this
+#undef CLEAVE
+#define CLEAVE 31043 // fixme: correct spell?!
+#define SMOLDERING_BREATH 39385
+#define TAIL_SWEEP 25653 // TODO: how to use this spell???
+#define DISTRACTING_ASH 30280
+
+// air spells
+#define DISTRACTING_ASH_FLY 30130 // all guides say ground spell but animation is flying?!
+#define RAIN_OF_BONES 37091 // Spell bugged: should debuff with 37098
+#define SMOKING_BLAST 37057
+#define FIREBALL_BARRAGE 30282
+#define SUMMON_BONE_SKELETONS 30170
+
+static Coords coords[] =
+{
+    { 0, 0, 0, 0 },
+    { -11173.719727, -1863.993164, 130.390396, 5.343079 }, // casting point
+    { -11125.542969, -1926.884644, 139.349365, 3.982360 },
+    { -11166.404297, -1950.729736, 114.714726, 1.537812 },
+    { -11167.497070, -1922.315918, 91.473755, 1.390549 } // landing point
+};
+
+class NIGHTBANEAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(NIGHTBANEAI);
+        bool m_spellcheck[5];
+        SP_AI_Spell spells[5];
+
+    NIGHTBANEAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+        _unit->GetAIInterface()->setMoveType(4);
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(1, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(2, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(3, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(4, 0, FLY));
+
+        nrspells = 5;
+	for(int i=0;i<nrspells;i++)
+	{
+		m_spellcheck[i] = false;
+	}
+
+        info_tail_sweep = dbcSpell.LookupEntry(TAIL_SWEEP);
+        info_distracting_ash = dbcSpell.LookupEntry(DISTRACTING_ASH);
+	info_rain_of_bones = dbcSpell.LookupEntry(RAIN_OF_BONES);
+        info_smoking_blast = dbcSpell.LookupEntry(SMOKING_BLAST);
+        info_summon_skeletons = dbcSpell.LookupEntry(SUMMON_BONE_SKELETONS);
+        info_fireball_barrage = dbcSpell.LookupEntry(FIREBALL_BARRAGE);
+
+	spells[0].info =  dbcSpell.LookupEntry(BELLOWING_ROAR);
+	spells[0].targettype = TARGET_VARIOUS;
+	spells[0].instant = false;
+	spells[0].cooldown = 10;
+	spells[0].perctrigger = 0.0f;
+	spells[0].attackstoptimer = 1000;
+
+	spells[1].info = dbcSpell.LookupEntry(CHARRED_EARTH);
+	spells[1].targettype = TARGET_ATTACKING;
+	spells[1].instant = false;
+	spells[1].cooldown = 8;
+	spells[1].perctrigger = 0.0f;
+	spells[1].attackstoptimer = 1000;
+
+	spells[2].info = dbcSpell.LookupEntry(SMOLDERING_BREATH);
+	spells[2].targettype = TARGET_ATTACKING;
+	spells[2].instant = false;
+	spells[2].cooldown = 7;
+	spells[2].perctrigger = 0.0f;
+	spells[2].attackstoptimer = 1000;
+
+	spells[3].info = dbcSpell.LookupEntry(CLEAVE);
+	spells[3].targettype = TARGET_ATTACKING;
+	spells[3].instant = false;
+	spells[3].cooldown = 7;
+	spells[3].perctrigger = 0.0f;
+	spells[3].attackstoptimer = 1000;
+
+	spells[4].info = dbcSpell.LookupEntry(DISTRACTING_ASH);
+	spells[4].targettype = TARGET_ATTACKING;
+	spells[4].instant = false;
+	spells[4].cooldown = 20;
+	spells[4].perctrigger = 0.0f;
+	spells[4].attackstoptimer = 1000;
+    }
+
+    void OnCombatStart(Unit* mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+        m_phase = 0;
+        m_time_hover = 0;
+        m_currentWP = 4;
+        RegisterAIUpdateEvent(1000);
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        CastTime();
+        _unit->GetAIInterface()->setMoveType(0);
+        _unit->GetAIInterface()->setWaypointToMove(0);
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        _unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+        _unit->GetAIInterface()->m_moveFly = false;
+        _unit->GetAIInterface()->m_canMove = true;
+        RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+        CastTime();
+        RemoveAIUpdateEvent();
+    }
+
+    void OnReachWP(uint32 iWaypointId, bool bForwards)
+    {
+        switch(iWaypointId)
+        {
+        case 1:
+            {
+                _unit->GetAIInterface()->m_canMove = false;
+                _unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+                _unit->GetAIInterface()->setCurrentAgent(AGENT_SPELL);
+                //_unit->m_pacified--;
+                _unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+                _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+                _unit->GetAIInterface()->setWaypointToMove(0);
+                WorldPacket data(SMSG_MOVE_SET_HOVER, 13);
+                data << _unit->GetNewGUID();
+                data << uint32(0);
+                _unit->SendMessageToSet(&data, false);
+                m_currentWP = 1;
+            }break;
+        case 4:
+            {
+                _unit->GetAIInterface()->SetAllowedToEnterCombat(true);
+                _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+                _unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+                _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+                _unit->GetAIInterface()->setWaypointToMove(0);
+                /*_unit->m_pacified--;
+                if(_unit->m_pacified > 0)
+                    _unit->m_pacified--;*/
+                WorldPacket data(SMSG_MOVE_UNSET_HOVER, 13);
+                data << _unit->GetNewGUID();
+                data << uint32(0);
+                _unit->SendMessageToSet(&data, false);
+                Land();
+                m_currentWP = 4;
+            }break;
+        default:
+            {
+                iWaypointId++;
+                _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+                _unit->GetAIInterface()->setWaypointToMove(iWaypointId);
+            }break;
+        };
+    }
+
+    void AIUpdate()
+    {
+        if(m_phase%2)
+	{
+            if(m_time_hover)
+            {
+		if(m_currentWP == 1)
+		{
+                    m_time_hover--;
+                    Unit *target = _unit->GetAIInterface()->GetNextTarget();
+	            if(target && m_time_hover < 17)
+                        _unit->CastSpell(target, info_smoking_blast, true);
+                    else if(target) {
+		        _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), info_rain_of_bones, true);
+		        _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), info_summon_skeletons, true);
+                    }
+                    // TODO: cast fireball barrage if a player gets out of range
+                    // _unit->CastSpell(target, info_fireball_barrage, true);
+                }
+            }
+            else
+	    {
+                if(_unit->GetCurrentSpell() != NULL)
+                    _unit->GetCurrentSpell()->cancel();
+                _unit->GetAIInterface()->m_canMove = true;
+                _unit->GetAIInterface()->SetAllowedToEnterCombat(false);
+                //_unit->m_pacified++;
+                _unit->GetAIInterface()->StopMovement(0);
+                _unit->GetAIInterface()->SetAIState(STATE_SCRIPTMOVE);
+                _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+                _unit->GetAIInterface()->setWaypointToMove(2);
+	        m_phase++;
+            }
+        }
+        else if((m_phase == 0 && _unit->GetHealthPct() <= 75) 
+                || (m_phase == 2 && _unit->GetHealthPct() <= 50) 
+                    || (m_phase == 4 && _unit->GetHealthPct() <= 25))
+	{
+            if(_unit->GetCurrentSpell() != NULL)
+                _unit->GetCurrentSpell()->cancel();
+
+            _unit->GetAIInterface()->SetAllowedToEnterCombat(false);
+            //_unit->m_pacified++;            
+            _unit->GetAIInterface()->StopMovement(0);
+            _unit->GetAIInterface()->SetAIState(STATE_SCRIPTMOVE);
+            _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+            _unit->GetAIInterface()->setWaypointToMove(1);
+            Fly();
+	    m_phase++;
+	    m_time_hover = 17;
+        }
+        else if(m_currentWP == 4)
+        {
+            float val = sRand.rand(100.0f);
+	    SpellCast(val);
+            // TODO: cast tail-sweep if any player gets behind us
+        }
+    }
+
+    inline WayPoint* CreateWaypoint(int id, uint32 waittime, uint32 flags)
+    {
+        //WayPoint* wp = new WayPoint;
+        //WayPoint * wp = _unit->GetMapMgr()->GetInterface()->CreateWaypoint();
+        //WayPoint * wp = sStructFactory.CreateWaypoint();
+        WayPoint * wp = _unit->CreateWaypointStruct();
+        wp->id = id;
+        wp->x = coords[id].x;
+        wp->y = coords[id].y;
+        wp->z = coords[id].z;
+        wp->o = coords[id].o;
+        wp->waittime = waittime;
+        wp->flags = flags;
+        wp->forwardemoteoneshot = 0;
+        wp->forwardemoteid = 0;
+        wp->backwardemoteoneshot = 0;
+        wp->backwardemoteid = 0;
+        wp->forwardskinid = 0;
+        wp->backwardskinid = 0;
+        return wp;
+    }
+
+    void Fly()
+    {
+        _unit->Emote(EMOTE_ONESHOT_LIFTOFF);
+        //Do we need hover really? Check it :D
+        WorldPacket data(SMSG_MOVE_SET_HOVER, 13);
+        data << _unit->GetNewGUID();
+        data << uint32(0);
+        _unit->SendMessageToSet(&data, false);
+        _unit->GetAIInterface()->m_moveFly = true;
+    }
+
+    void Land()
+    {
+        _unit->Emote(EMOTE_ONESHOT_LAND);
+        //Do we need hover really? Check it :D
+        WorldPacket data(SMSG_MOVE_UNSET_HOVER, 13);
+        data << _unit->GetNewGUID();
+        data << uint32(0);
+        _unit->SendMessageToSet(&data, false);
+        _unit->GetAIInterface()->m_moveFly = false;
+    }
+
+
+    void CastTime()
+    {
+	for(int i=0;i<nrspells;i++)
+            spells[i].casttime = spells[i].cooldown;
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+	    float comulativeperc = 0;
+	    Unit *target = NULL;
+	    for(int i=0;i<nrspells;i++)
+	    {
+	        spells[i].casttime--;
+		
+		if (m_spellcheck[i])
+		{
+		    spells[i].casttime = spells[i].cooldown;
+		    target = _unit->GetAIInterface()->GetNextTarget();
+		    switch(spells[i].targettype)
+		    {
+		        case TARGET_SELF:
+		        case TARGET_VARIOUS:
+			    _unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+		        case TARGET_ATTACKING:
+			    _unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+		        case TARGET_DESTINATION:
+			    _unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+		    }
+
+		    if (spells[i].speech != "")
+		    {
+		        _unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+			_unit->PlaySoundToSet(spells[i].soundid); 
+		    }
+
+		    m_spellcheck[i] = false;
+		    return;
+		}
+
+		if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+		{
+		    _unit->setAttackTimer(spells[i].attackstoptimer, false);
+		    m_spellcheck[i] = true;
+		}
+		comulativeperc += spells[i].perctrigger;
+            }
+	}
+    }
+
+protected:
+    uint32 nrspells;
+    uint32 m_phase;
+    uint32 m_time_hover;
+    uint32 m_currentWP;
+    SpellEntry *info_smoking_blast;
+    SpellEntry *info_summon_skeletons;
+    SpellEntry *info_fireball_barrage;
+    SpellEntry *info_rain_of_bones;
+    SpellEntry *info_distracting_ash;
+    SpellEntry *info_tail_sweep;
+};
+
+void SetupKarazhan(ScriptMgr * mgr)
+{
+    mgr->register_creature_script(CN_MIDNIGHT, &MIDNIGHTAI::Create);
+    mgr->register_creature_script(CN_ATTUMEN, &ATTUMENAI::Create);
+    mgr->register_creature_script(CN_MOROES, &MOROESAI::Create);
+    mgr->register_creature_script(CN_MAIDEN, &MAIDENOFVIRTUEAI::Create);
+    mgr->register_creature_script(CN_THEBIGBADWOLF, &THEBIGBADWOLFAI::Create);
+    mgr->register_creature_script(CN_THECURATOR, &THECURATORAI::Create);
+    mgr->register_creature_script(CN_ASTRALFLARE, &ASTRALFLAREAI::Create);
+    mgr->register_creature_script(CN_SHADEOFARAN, &SHADEOFARANAI::Create);
+    mgr->register_creature_script(CN_ILLHOOF, &ILLHOOFAI::Create);
+    mgr->register_creature_script(CN_KIL_REK, &KILREKAI::Create);
+    mgr->register_creature_script(CN_MALCHEZAAR, &MALCHEZAARAI::Create);
+    mgr->register_creature_script(CN_NETHERSPITE, &NETHERSPITEAI::Create);
+    mgr->register_creature_script(CN_NIGHTBANE, &NIGHTBANEAI::Create);
+}
Index: src/InstanceScripts/Raid_TheEye.cpp
===================================================================
--- src/InstanceScripts/Raid_TheEye.cpp	(revision 0)
+++ src/InstanceScripts/Raid_TheEye.cpp	(revision 0)
@@ -0,0 +1,1104 @@
+#include "StdAfx.h"
+#include "Setup.h"
+
+/************************************************************************/
+/* Raid_TheEye.cpp Script												*/
+/************************************************************************/
+
+
+
+/****************/
+/*    Bosses    */
+/****************/
+
+// Void Reaver AI
+
+#define CN_VOID_REAVER 19516
+
+#define POUNDING 34164
+#define ARCANE_ORB 34190
+#define KNOCK_AWAY 36512 // maybe wrong id (maybe should be: 21737 ? ), but works
+#define ENRAGE 36992 // Needs checking (as it can be wrong [or maybe IS wrong])
+
+//TO DO: Add rest of the sounds (no idea to which action they should be used)
+
+class VOIDREAVERAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(VOIDREAVERAI);
+	SP_AI_Spell spells[4];
+	bool m_spellcheck[4];
+
+    VOIDREAVERAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		nrspells = 4;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(POUNDING);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = true;
+		spells[0].perctrigger = 16.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(ARCANE_ORB);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].perctrigger = 9.0f;
+		spells[1].attackstoptimer = 2000;
+
+		spells[2].info = dbcSpell.LookupEntry(KNOCK_AWAY);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].perctrigger = 7.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(ENRAGE);
+		spells[3].targettype = TARGET_SELF;
+		spells[3].instant = true;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+	} 
+
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Alert, you are marked for extermination!");
+		_unit->PlaySoundToSet(11213);
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%3;
+			switch (RandomSpeach)
+			{
+			case 0: 
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Extermination, successful.");
+				_unit->PlaySoundToSet(11215);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Imbecile life form, no longer functional.");
+				_unit->PlaySoundToSet(11216);
+				break;
+			case 2:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Threat neutralized.");
+				_unit->PlaySoundToSet(11217);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Systems... shutting... down...");
+        _unit->PlaySoundToSet(11214);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		Timer = Timer + 1;
+
+		if (Timer == 200) // Need correct attackspeed in DB to change it to correct value
+		{
+			_unit->CastSpell(_unit, spells[3].info, spells[3].instant);
+		}
+
+		else
+		{
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+	int Timer;
+};
+/*
+// High Astromancer Solarian AI
+
+
+#define CN_HIGH_ASTROMANCER_SOLARIAN 18805
+//Phase 1 spells
+#define ARCANE_MISSILES 39414 // Should have random targeting
+#define WRATH_OF_THE_ASTROMANCER 33045 // Needs random function
+#define MARK_OF_SOLARIAN 33023 // not sure... but should be used on random target
+//Phase 2 spells
+// Just to define portal summoning + summoning creatures + creatures AI
+// Add sounds to creature summoning events
+//Phase 3 spells
+#define VOID_BOLTS 39329 // RANDOM target, but because of lack of feature ATTACKING
+#define FEAR 38154 // probably wrong id; maybe one of these are correct: 31970, 31358 (?)
+
+// TO DO: Rewrite it to phase style.
+
+class HIGHASTROMANCERSOLARIANAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(HIGHASTROMANCERSOLARIANAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    HIGHASTROMANCERSOLARIANAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		m_phase = 1;
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+        spells[0].info = dbcSpell.LookupEntry(ARCANE_MISSILES);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(WRATH_OF_THE_ASTROMANCER);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 2000;
+
+		spells[2].info = dbcSpell.LookupEntry(MARK_OF_SOLARIAN);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].perctrigger = 10.0f;
+		spells[2].attackstoptimer = 1000;
+	} 
+
+    void OnCombatStart(Unit* mTarget)
+    {
+		m_phase = 1;
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Whatever, Sindorai!");
+		_unit->PlaySoundToSet(11134);
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%3;
+			switch (RandomSpeach)
+			{
+			case 0: 
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your soul belongs to the xxxx!");
+				_unit->PlaySoundToSet(11136);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "By the blood of the high born!");
+				_unit->PlaySoundToSet(11137);
+				break;
+			case 2:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "For the sun well!");
+				_unit->PlaySoundToSet(11138);
+				break;
+			}
+		}
+
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Died... W00T?!");
+        _unit->PlaySoundToSet(11135);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		float val = sRand.rand(100.0f);
+        SpellCast(val);
+		if (_unit->GetHealthPct() > 65)
+		if (_unit->GetHealthPct() <= 65)
+		if (_unit->GetHealthPct() <= 20)
+    }
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+};
+*/
+
+
+// High Astromancer Solarian AI
+// First try to make it in phase system. For now not enough luck (as I want to update spell list
+// when next phase has just started.
+
+#define CN_HIGH_ASTROMANCER_SOLARIAN 18805
+//Phase 1 spells
+#define ARCANE_MISSILES 39414 // Should have random targeting
+#define WRATH_OF_THE_ASTROMANCER 33045 // Needs random function
+#define MARK_OF_SOLARIAN 33023 // not sure... but should be used on random target
+//Phase 2 spells
+// Just to define portal summoning + summoning creatures + creatures AI
+// Add sounds to creature summoning events
+//Phase 3 spells
+#define VOID_BOLTS 39329 // RANDOM target, but because of lack of feature ATTACKING
+#define FEAR 38154 // probably wrong id; maybe one of these are correct: 31970, 31358 (?)
+
+// TO DO: Rewrite it to phase style.
+
+class HIGHASTROMANCERSOLARIANAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(HIGHASTROMANCERSOLARIANAI);
+	SP_AI_Spell spells[3];
+	bool m_spellcheck[3];
+
+    HIGHASTROMANCERSOLARIANAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		//m_phase = 1;
+		//if (m_phase == 1)
+		if (_unit->GetHealthPct() > 90 || _unit->GetHealthPct() <= 50)
+		{
+			nrspells = 3;
+			for(int i=0;i<nrspells;i++)
+			{
+				m_spellcheck[i] = false;
+			}
+			spells[0].info = dbcSpell.LookupEntry(ARCANE_MISSILES);
+			spells[0].targettype = TARGET_ATTACKING;
+			spells[0].instant = true;
+			spells[0].perctrigger = 8.0f;
+			spells[0].attackstoptimer = 1000;
+
+			spells[1].info = dbcSpell.LookupEntry(WRATH_OF_THE_ASTROMANCER);
+			spells[1].targettype = TARGET_ATTACKING;
+			spells[1].instant = true;
+			spells[1].perctrigger = 15.0f;
+			spells[1].attackstoptimer = 2000;
+
+			spells[2].info = dbcSpell.LookupEntry(MARK_OF_SOLARIAN);
+			spells[2].targettype = TARGET_ATTACKING;
+			spells[2].instant = true;
+			spells[2].perctrigger = 10.0f;
+			spells[2].attackstoptimer = 1000;
+		}
+	
+		//if (m_phase == 2)
+		if (_unit->GetHealthPct() <= 90 && _unit->GetHealthPct() > 50)
+		{
+			nrspells = 0;
+			for(int i=0;i<nrspells;i++)
+			{
+				m_spellcheck[i] = false;
+			}
+		}
+/*
+		if (m_phase == 3)
+		{
+			nrspells = 0;
+			for(int i=0;i<nrspells;i++)
+			{
+				m_spellcheck[i] = false;
+			}
+		}*/
+	} 
+
+    void OnCombatStart(Unit* mTarget)
+    {
+		m_phase = 1;
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Whatever, Sindorai!");
+		_unit->PlaySoundToSet(11134);
+        RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+
+	void OnTargetDied(Unit* mTarget)
+    {
+		if (_unit->GetHealthPct() > 0)	// Hack to prevent double yelling (OnDied and OnTargetDied when creature is dying)
+		{
+			int RandomSpeach;
+			sRand.randInt(1000);
+			RandomSpeach=rand()%3;
+			switch (RandomSpeach)
+			{
+			case 0: 
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Your soul belongs to the xxxx!");
+				_unit->PlaySoundToSet(11136);
+				break;
+			case 1:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "By the blood of the high born!");
+				_unit->PlaySoundToSet(11137);
+				break;
+			case 2:
+				_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "For the sun well!");
+				_unit->PlaySoundToSet(11138);
+				break;
+			}
+		}
+    }
+
+    void OnCombatStop(Unit *mTarget)
+    {
+        _unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        _unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        RemoveAIUpdateEvent();
+    }
+
+	void OnDied(Unit * mKiller)
+    {
+		m_phase = 1;
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Died... W00T?!");
+        _unit->PlaySoundToSet(11135);
+       RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {/*
+		if (_unit->GetHealthPct() <= 90 && _unit->GetHealthPct() > 50)
+		{
+			PhaseTwo();
+		}
+		
+		if (_unit->GetHealthPct() > 90 && _unit->GetHealthPct() < 50)
+		{
+			PhaseOne();
+		}
+
+		float val = sRand.rand(100.0f);
+		SpellCast(val);*/
+		/*
+		if(_unit->GetHealthPct() <= 95)
+		{
+			m_phase = 2;
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}
+
+		if(_unit->GetHealthPct() <= 50 || _unit->GetHealthPct() >95)
+		{
+			m_phase = 1;
+			float val = sRand.rand(100.0f);
+			SpellCast(val);
+		}*/
+		float val = sRand.rand(100.0f);
+		SpellCast(val);
+    }
+
+	void PhaseOne()
+	{
+		nrspells = 3;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+		spells[0].info = dbcSpell.LookupEntry(ARCANE_MISSILES);
+		spells[0].targettype = TARGET_ATTACKING;
+		spells[0].instant = true;
+		spells[0].perctrigger = 8.0f;
+		spells[0].attackstoptimer = 1000;
+
+		spells[1].info = dbcSpell.LookupEntry(WRATH_OF_THE_ASTROMANCER);
+		spells[1].targettype = TARGET_ATTACKING;
+		spells[1].instant = true;
+		spells[1].perctrigger = 15.0f;
+		spells[1].attackstoptimer = 2000;
+
+		spells[2].info = dbcSpell.LookupEntry(MARK_OF_SOLARIAN);
+		spells[2].targettype = TARGET_ATTACKING;
+		spells[2].instant = true;
+		spells[2].perctrigger = 10.0f;
+		spells[2].attackstoptimer = 1000;
+	}
+
+	void PhaseTwo()
+	{
+		nrspells = 0;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+	}
+
+
+    void SpellCast(float val)
+    {
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				if(!spells[i].perctrigger) continue;
+				
+				if(m_spellcheck[i])
+				{
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if(val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger))
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+        }
+    }
+protected:
+
+	int nrspells;
+	int m_phase;
+};
+
+
+
+
+
+
+
+// Al'ar AI
+
+#define WALK 0
+#define RUN 256
+#define FLY 768
+
+#define CN_ALAR 19514
+
+// Phase1 spells
+#define FLAME_BUFFET 34121	// casted only when there is no player in melee range!
+#define FLAME_QUILLS 34316	// it flies to a high point in a center of room and use this on players located on platform	// also can be many others (Idk even if this spell works =S)
+#define SUMMON_PHOENIX_ADDS 18814	// Summons 3 phoenixs
+
+// Phase2 spells
+#define FLAME_PATCH 35383	// 35383, 35380;
+#define METEOR 35181		// but shouldn't be instant imho
+#define EMBER_BLAST 34133	// used when one of adds has low health
+/*#define MELT_ARMOR		// maybe they are used, but not sure
+#define RANDOM_CHARGE*/
+
+// Other spells
+#define REBIRTH 34342
+
+struct Coords
+{
+    float x;
+    float y;
+    float z;
+    float o;
+};
+
+static Coords fly[] = 
+{
+	{ 0, 0, 0, 0 },
+	{ 337.864868, 65.702301, 33.171944, 1.329919 },	// fly 1 to ...
+	{ 391.245148, 35.472462, 36.886353, 0.822089 },
+	{ 392.959869, -34.031734, 33.630096, 3.342431 },
+	{ 321.277008, -70.101540, 43.650482, 3.844443 },
+    { 256.202911, -1.549352, 44.718426, 0.069512 },	// ... fly 5
+	{ 342.090088, 55.661064, 27.638260, 0.739368},	// attack/tank positions from phase 1 from here to ...
+	{ 392.815369, 31.636963, 25.414761, 0.551340 },
+	{ 388.397308, -38.834595, 22.335297, 5.702067 },
+	{ 333.922229, -60.645069, 24.484278, 1.454599 },	// ... to here
+	{ 328.103455, -0.192393, 52.216309, 4.188326 },	// fire quills cast position	// EMOTE_STATE_WHIRLWIND = 382,
+	{ 326.225647, 2.381837, -2.389485, 4.877070 }	// center of the room which is used in phase 2
+};
+
+
+
+class AlarAI : public CreatureAIScript
+{
+public:
+    ADD_CREATURE_FACTORY_FUNCTION(AlarAI);
+	SP_AI_Spell spells[7];
+	bool m_spellcheck[7];
+
+    AlarAI(Creature* pCreature) : CreatureAIScript(pCreature)
+    {
+		/************************ Waypoint Place ************************/
+
+        m_entry = pCreature->GetEntry();
+
+		_unit->GetAIInterface()->addWayPoint(CreateWaypoint(1, 0, FLY));
+		_unit->GetAIInterface()->addWayPoint(CreateWaypoint(2, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(3, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(4, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(5, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(6, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(7, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(8, 0, FLY));
+        _unit->GetAIInterface()->addWayPoint(CreateWaypoint(9, 0, FLY));
+		_unit->GetAIInterface()->addWayPoint(CreateWaypoint(10, 0, FLY));
+		_unit->GetAIInterface()->addWayPoint(CreateWaypoint(11, 0, FLY));
+
+		/************************** Spells ****************************/
+
+		nrspells = 7;
+		for(int i=0;i<nrspells;i++)
+		{
+			m_spellcheck[i] = false;
+		}
+
+        spells[0].info = dbcSpell.LookupEntry(FLAME_BUFFET);
+		spells[0].targettype = TARGET_VARIOUS;
+		spells[0].instant = false;
+		spells[0].cooldown = -1;
+		spells[0].perctrigger = 0.0f;
+		spells[0].attackstoptimer = 1000;
+
+        spells[1].info = dbcSpell.LookupEntry(FLAME_QUILLS);
+		spells[1].targettype = TARGET_VARIOUS;
+		spells[1].instant = true;
+		spells[1].cooldown = -1;
+		spells[1].perctrigger = 0.0f;
+		spells[1].attackstoptimer = 1000;
+
+		spells[2].info = dbcSpell.LookupEntry(SUMMON_PHOENIX_ADDS);
+		spells[2].targettype = TARGET_VARIOUS;
+		spells[2].instant = true;
+		spells[2].cooldown = -1;
+		spells[2].perctrigger = 0.0f;
+		spells[2].attackstoptimer = 1000;
+
+		spells[3].info = dbcSpell.LookupEntry(FLAME_PATCH);
+		spells[3].targettype = TARGET_VARIOUS;
+		spells[3].instant = true;
+		spells[3].cooldown = -1;
+		spells[3].perctrigger = 0.0f;
+		spells[3].attackstoptimer = 1000;
+
+		spells[4].info = dbcSpell.LookupEntry(METEOR);
+		spells[4].targettype = TARGET_ATTACKING;
+		spells[4].instant = true;	// =(
+		spells[4].cooldown = -1;
+		spells[4].perctrigger = 0.0f;
+		spells[4].attackstoptimer = 1000;
+
+		spells[5].info = dbcSpell.LookupEntry(EMBER_BLAST);
+		spells[5].targettype = TARGET_VARIOUS;
+		spells[5].instant = true;
+		spells[5].cooldown = -1;
+		spells[5].perctrigger = 0.0f;
+		spells[5].attackstoptimer = 1000;
+
+		spells[6].info = dbcSpell.LookupEntry(REBIRTH);
+		spells[6].targettype = TARGET_SELF;
+		spells[6].instant = false;
+		spells[6].cooldown = -1;
+		spells[6].perctrigger = 0.0f;
+		spells[6].attackstoptimer = 1000;
+
+		/******************* Additional Settings *******************/
+
+		Phase = 0;
+		FlameQuills = false;
+		Meteor = false;
+		PositionChange=rand()%8+15;
+		PhoenixSummon=rand()%6+17;
+		_unit->GetAIInterface()->m_moveFly = true;
+        _unit->GetAIInterface()->StopMovement(0);
+        _unit->GetAIInterface()->SetAIState(STATE_SCRIPTMOVE);
+		_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+		_unit->GetAIInterface()->setWaypointToMove(1);
+		RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));
+    }
+    
+    void OnCombatStart(Unit* mTarget)
+    {
+		_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Phase 1 Test!");
+		_unit->PlaySoundToSet(11243);
+		_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+		_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+		CastTime();
+		Phase = 1;
+		FlameQuills = false;
+		Meteor = false;
+		PositionChange=rand()%8+15;	// 30-45sec /*** if attack time 1000 (%15+31) ***/
+		PhoenixSummon=rand()%6+17;	// 34-44sec /*** if attack time 1000 (%11+34) ***/
+		FlyWay=rand()%2;
+		switch (FlyWay)
+		{
+		case 0:	// Clock like
+			{
+				_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+				_unit->GetAIInterface()->setWaypointToMove(6);
+			}break;
+
+		case 1:	// hmm... other?
+			{
+				_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+				_unit->GetAIInterface()->setWaypointToMove(9);
+			}break;
+		}
+		//RegisterAIUpdateEvent(_unit->GetUInt32Value(UNIT_FIELD_BASEATTACKTIME));	// Taken from here to add more abilities to code
+    }
+
+	void CastTime()
+	{
+		for(int i=0;i<nrspells;i++)
+			spells[i].casttime = spells[i].cooldown;
+	}
+
+    void OnCombatStop(Unit *mTarget)
+    {
+		Phase = 0;
+		FlameQuills = false;
+		Meteor = false;
+		PhoenixSummon=rand()%6+17;
+		PositionChange=rand()%8+15;
+		CastTime();
+        _unit->GetAIInterface()->StopMovement(0);
+        _unit->GetAIInterface()->SetAIState(STATE_SCRIPTMOVE);
+		_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+		_unit->GetAIInterface()->setWaypointToMove(1);
+        //_unit->GetAIInterface()->setCurrentAgent(AGENT_NULL);
+        //_unit->GetAIInterface()->SetAIState(STATE_IDLE);
+        //RemoveAIUpdateEvent();
+    }
+
+    void OnDied(Unit * mKiller)
+    {
+		Phase = 0;
+		FlameQuills = false;
+		Meteor = false;
+		PositionChange=rand()%8+15;
+		PhoenixSummon=rand()%6+17;
+		CastTime();
+       //RemoveAIUpdateEvent();
+    }
+
+    void AIUpdate()
+    {
+		if (FlameQuills == true)
+		{
+			QuillsCount++;
+			if (QuillsCount == 9)
+			{
+				FlameQuills = false;
+				switch (FlyWay)
+				{
+				case 0:	// Clock like
+					{
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+						_unit->GetAIInterface()->setWaypointToMove(6);
+					}break;
+		
+				case 1:	// hmm... other?
+					{
+						_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+						_unit->GetAIInterface()->setWaypointToMove(9);
+					}break;
+				}
+			}
+			_unit->CastSpell(_unit, spells[1].info, spells[1].instant);
+		}
+
+		if (Meteor == true)
+		{
+		}
+		
+		else 
+		{
+			switch (Phase)
+			{
+			case 0: return;
+			case 1: 
+				{
+					PhaseOne();
+				}break;
+			case 2:
+				{
+					PhaseTwo();
+				}break;
+			default:
+				{
+					Phase = 0;
+				};
+			};
+		}
+		//float val = sRand.rand(100.0f);
+		//SpellCast(val);
+    }
+
+    void PhaseOne()
+    {
+		PositionChange--;
+		PhoenixSummon--;
+
+		if (_unit->GetHealthPct() == 0)
+		{
+			Phase = 2;
+			_unit->CastSpell(_unit, spells[6].info, spells[6].instant);
+		}
+
+		if (!PhoenixSummon--)
+		{
+			_unit->CastSpell(_unit, spells[2].info, spells[2].instant);
+			PhoenixSummon=rand()%6+17;
+		}
+
+		if (!PositionChange)
+		{
+			_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			_unit->GetAIInterface()->setWaypointToMove(NextWP);
+			PositionChange=rand()%8+17;	// added 4 sec fit time + time needed to move to next pos.
+		}
+
+		else
+		{
+			uint32 val = sRand.randInt(100);
+
+			if (val > 0 && val < 5)	// Flame Quills wp here!
+			{
+				_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+				_unit->GetAIInterface()->setWaypointToMove(10);
+			}
+		}
+    }
+
+	void PhaseTwo()
+	{
+
+	}
+
+	void SpellCast(float val)
+	{
+        if(_unit->GetCurrentSpell() == NULL && _unit->GetAIInterface()->GetNextTarget())
+        {
+			float comulativeperc = 0;
+		    Unit *target = NULL;
+			for(int i=0;i<nrspells;i++)
+			{
+				spells[i].casttime--;
+				
+				if (m_spellcheck[i])
+				{					
+					spells[i].casttime = spells[i].cooldown;
+					target = _unit->GetAIInterface()->GetNextTarget();
+					switch(spells[i].targettype)
+					{
+						case TARGET_SELF:
+						case TARGET_VARIOUS:
+							_unit->CastSpell(_unit, spells[i].info, spells[i].instant); break;
+						case TARGET_ATTACKING:
+							_unit->CastSpell(target, spells[i].info, spells[i].instant); break;
+						case TARGET_DESTINATION:
+							_unit->CastSpellAoF(target->GetPositionX(),target->GetPositionY(),target->GetPositionZ(), spells[i].info, spells[i].instant); break;
+					}
+
+					if (spells[i].speech != "")
+					{
+						_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, spells[i].speech.c_str());
+						_unit->PlaySoundToSet(spells[i].soundid); 
+					}
+
+					m_spellcheck[i] = false;
+					return;
+				}
+
+				if ((val > comulativeperc && val <= (comulativeperc + spells[i].perctrigger)) || !spells[i].casttime)
+				{
+					_unit->setAttackTimer(spells[i].attackstoptimer, false);
+					m_spellcheck[i] = true;
+				}
+				comulativeperc += spells[i].perctrigger;
+			}
+		}
+	}
+
+    void OnReachWP(uint32 iWaypointId, bool bForwards)
+    {
+		if (Phase == 1)
+		{
+			_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			_unit->GetAIInterface()->setWaypointToMove(6);
+			_unit->SendChatMessage(CHAT_MSG_MONSTER_YELL, LANG_UNIVERSAL, "Phase 1 Test!");
+			_unit->PlaySoundToSet(11243);
+		}
+
+		switch(iWaypointId)
+		{
+			case 1:	// First fly point
+				{
+					_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+					_unit->GetAIInterface()->setWaypointToMove(2);
+				}break;
+
+			case 2:
+				{
+					_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+					_unit->GetAIInterface()->setWaypointToMove(3);
+				}break;
+
+			case 3:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+					_unit->GetAIInterface()->setWaypointToMove(4);
+			    }break;
+
+			case 4:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(5);
+			    }break;
+
+			case 5:
+			    {
+			        _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_WANTEDWP);
+			        _unit->GetAIInterface()->setWaypointToMove(1);	// Last fly point (flyback to point 1 - reset)
+			    }break;
+
+			case 6:
+			    {
+					_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+					_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+					_unit->GetAIInterface()->m_canMove = false;
+					switch (FlyWay)
+					{
+					case 0:
+						{
+							NextWP = 7;
+						}break;
+
+					case 1:
+						{	
+							NextWP = 9;
+						}break;
+					}
+				}break;
+				
+			case 7:
+			    {
+					_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+					_unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+					_unit->GetAIInterface()->m_canMove = false;
+					switch (FlyWay)
+					{
+					case 0:
+						{
+							NextWP = 8;
+						}break;
+
+					case 1:
+						{	
+							NextWP = 6;
+						}break;
+					}
+			    }break;
+		
+			case 8:
+		    {
+				_unit->GetAIInterface()->m_canMove = false;
+				_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+                _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+				switch (FlyWay)
+				{
+				case 0:
+					{
+						NextWP = 9;
+					}break;
+	
+				case 1:
+					{	
+						NextWP = 7;
+					}break;
+				}
+		    }break;
+
+			case 9:
+		    {
+				_unit->GetAIInterface()->m_canMove = false;
+				_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+                _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+				switch (FlyWay)
+				{
+				case 0:
+					{
+						NextWP = 6;
+					}break;
+
+				case 1:
+					{	
+						NextWP = 8;
+					}break;
+				}
+			}break;
+
+			case 10:
+		    {
+				_unit->GetAIInterface()->SetAIState(STATE_SCRIPTIDLE);
+                _unit->GetAIInterface()->setMoveType(MOVEMENTTYPE_DONTMOVEWP);
+				if (Phase == 1)
+				{
+					FlameQuills = true;
+					QuillsCount = 0;
+				}
+
+				if (Phase == 2)
+				{
+					Meteor = true;
+				}
+
+			}break;
+		}
+    }
+
+    inline WayPoint* CreateWaypoint(int id, uint32 waittime, uint32 flags)
+    {
+        WayPoint * wp = _unit->CreateWaypointStruct();
+        wp->id = id;
+        wp->x = fly[id].x;
+        wp->y = fly[id].y;
+        wp->z = fly[id].z;
+        wp->o = fly[id].o;
+        wp->waittime = waittime;
+        wp->flags = flags;
+        wp->forwardemoteoneshot = 0;
+        wp->forwardemoteid = 0;
+        wp->backwardemoteoneshot = 0;
+        wp->backwardemoteid = 0;
+        wp->forwardskinid = 0;
+        wp->backwardskinid = 0;
+        return wp;
+    }
+
+protected:
+
+	bool FlameQuills;
+	uint32 QuillsCount;
+	bool Meteor;
+	int PositionChange;
+	int PhoenixSummon;
+	uint32 NextWP;
+    uint32 m_entry;
+    uint32 FlyWay;
+	uint32 Phase;
+	int nrspells;
+};
+
+
+void SetupTheEye(ScriptMgr * mgr)
+{
+	mgr->register_creature_script(CN_VOID_REAVER, &VOIDREAVERAI::Create);
+	mgr->register_creature_script(CN_HIGH_ASTROMANCER_SOLARIAN, &HIGHASTROMANCERSOLARIANAI::Create);
+	mgr->register_creature_script(CN_ALAR, &AlarAI::Create);
+}
Index: src/InstanceScripts/Setup.cpp
===================================================================
--- src/InstanceScripts/Setup.cpp	(revision 1976)
+++ src/InstanceScripts/Setup.cpp	(working copy)
@@ -8,12 +8,21 @@
 
 extern "C" SCRIPT_DECL void _exp_script_register(ScriptMgr* mgr)	// Comment any script to disable it
 {
-    SetupDeadmines(mgr);
-    SetupMoltenCore(mgr);
+	SetupDeadmines(mgr);
+	SetupMoltenCore(mgr);
 	SetupZulGurub(mgr);
 	SetupBlackwingLair(mgr);
 	SetupNaxxramas(mgr);
 	SetupOnyxiasLair(mgr);
+	SetupKarazhan(mgr);
+	SetupGruulsLair(mgr);
+	SetupBloodFurnace(mgr);
+	SetupHellfireRamparts(mgr);
+	SetupSethekkHalls(mgr);
+	SetupTheMechanar(mgr);
+	SetupTheSteamvault(mgr);
+	SetupArcatraz(mgr);
+	SetupTheEye(mgr);
 }
 
 #ifdef WIN32
Index: src/InstanceScripts/Setup.h
===================================================================
--- src/InstanceScripts/Setup.h	(revision 1976)
+++ src/InstanceScripts/Setup.h	(working copy)
@@ -28,6 +28,7 @@
 void SetupBlackTemple(ScriptMgr * mgr);
 void SetupArcatraz(ScriptMgr * mgr);
 void SetupTheMechanar(ScriptMgr * mgr);
+void SetupKarazhan(ScriptMgr * mgr);
 
 struct SP_AI_Spell{
 	SpellEntry *info; // spell info
Index: src/SpellHandlers/ItemSpells_1.cpp
===================================================================
--- src/SpellHandlers/ItemSpells_1.cpp	(revision 1976)
+++ src/SpellHandlers/ItemSpells_1.cpp	(working copy)
@@ -48,7 +48,7 @@
 {
 	if(!pSpell->p_caster) return true;
 
-	uint32 chance = sRand.randInt(2);
+	uint32 chance = sRand.randInt(3);
 
 	switch(chance)
 	{
Index: src/SpellHandlers/PaladinSpells.cpp
===================================================================
--- src/SpellHandlers/PaladinSpells.cpp	(revision 1976)
+++ src/SpellHandlers/PaladinSpells.cpp	(working copy)
@@ -116,6 +116,20 @@
     return true;
 }
 
+bool HammerOfWrath(uint32 i, Spell* pSpell)
+{
+    uint32 uSpellId = pSpell->m_spellInfo->Id;
+    uint32 base_dmg = pSpell->damage;
+    Unit * target = pSpell->GetUnitTarget();
+    if(!target || !pSpell->u_caster) return true;
+    if(target->GetHealthPct() > 20)
+    {
+        pSpell->SendCastResult(SPELL_FAILED_BAD_TARGETS);
+        return true;
+    }
+	return true;
+}
+
 void SetupPaladinSpells(ScriptMgr * mgr)
 {
     mgr->register_dummy_aura(20154, &HandleDummyAura);
@@ -127,4 +141,8 @@
     mgr->register_dummy_aura(20292, &HandleDummyAura);
     mgr->register_dummy_aura(20293, &HandleDummyAura);
     mgr->register_dummy_aura(27155, &HandleDummyAura);
+    mgr->register_dummy_spell(24275, &HammerOfWrath);  /// rank 1
+    mgr->register_dummy_spell(24274, &HammerOfWrath);  /// rank 2
+    mgr->register_dummy_spell(24239, &HammerOfWrath);  /// rank 3
+    mgr->register_dummy_spell(27180, &HammerOfWrath);  /// rank 4
 }
