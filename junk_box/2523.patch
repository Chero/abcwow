Index: game/Arenas.cpp
===================================================================
--- game/Arenas.cpp	(revision 2522)
+++ game/Arenas.cpp	(working copy)
@@ -337,12 +337,11 @@
 			//                   (PB - PA)/400
 			//              1 + 10
 
-			long double power = ( averageRating[j] - averageRating[i] ) / 400.0;
-
-			long double divisor = pow(((long double)(10.0)), power);
+			double power = (int)(averageRating[j] - averageRating[i]) / 400.0f;
+			double divisor = pow(((double)(10.0)), power);
 			divisor += 1.0;
 
-			long double winChance = 1.0 / divisor;
+			double winChance = 1.0 / divisor;
 
 			for(set<Player*>::iterator itr = m_players[i].begin(); itr != m_players[i].end(); ++itr)
 			{
@@ -364,8 +363,8 @@
 						// K is the maximum possible change
 						// Through investigation, K was estimated to be 30
 						// When used in chess, Elo uses K = 32 ... maybe this would be better? :/
-						long double multiplier = (outcome ? 1.0 : 0.0) - winChance;
-						long double deltaRating = 30.0 * multiplier;
+						double multiplier = (outcome ? 1.0 : 0.0) - winChance;
+						double deltaRating = 30.0 * multiplier;
 						if ( deltaRating < 0 && (-1.0 * deltaRating) > t->m_stat_rating )
 							t->m_stat_rating = 0;
 						else
Index: game/BattlegroundMgr.cpp
===================================================================
--- game/BattlegroundMgr.cpp	(revision 2522)
+++ game/BattlegroundMgr.cpp	(working copy)
@@ -250,8 +250,10 @@
 					{
 						plr = *tempPlayerVec[0].begin();
 						tempPlayerVec[0].pop_front();
+						plr->m_bgTeam=team;
 						arena->AddPlayer(plr, team);
 						ErasePlayerFromList(plr->GetGUIDLow(), &m_queuedPlayers[i][j]);
+						team = arena->GetFreeTeam();
 					}
 				}
 				else
@@ -385,15 +387,17 @@
 
 			Arena * ar = ((Arena*)CreateInstance(i,LEVEL_GROUP_70));
 			GroupMembersSet::iterator itx;
-			int32 team;
 			ar->rated_match=true;
 
 			for(itx = group1->GetSubGroup(0)->GetGroupMembersBegin(); itx != group1->GetSubGroup(0)->GetGroupMembersEnd(); ++itx)
 			{
 				if(itx->player)
 				{
-					if( (team = ar->GetFreeTeam()) != -1 )
-                        ar->AddPlayer(itx->player, team);
+					if(ar->HasFreeSlots(0))
+					{
+						itx->player->m_bgTeam = 0;
+						ar->AddPlayer(itx->player, 0);
+					}
 				}
 			}
 
@@ -401,8 +405,11 @@
 			{
 				if(itx->player)
 				{
-					if( (team = ar->GetFreeTeam()) != -1 )
-						ar->AddPlayer(itx->player, team);
+					if(ar->HasFreeSlots(1))
+					{
+						itx->player->m_bgTeam = 1;
+                        ar->AddPlayer(itx->player, 1);
+					}
 				}
 			}
 		}
@@ -728,7 +735,6 @@
 		return;
 	}
 
-	plr->SetTeam(plr->m_bgTeam);
 	WorldPacket data(SMSG_BATTLEGROUND_PLAYER_JOINED, 8);
 	data << plr->GetGUID();
 	DistributePacketToAll(&data);
@@ -990,7 +996,7 @@
 			data << uint8(0xC);
 			data << uint32(6);
 			data << uint16(0x1F90);
-			data << uint32(11);
+			data << InstanceID;
 			data << uint8(RatedMatch);		// 1 = rated match
 		}
 		else
@@ -1042,9 +1048,6 @@
 	/*if(plr->GetGroup() == m_groups[plr->m_bgTeam])
 		plr->GetGroup()->RemovePlayer(plr->m_playerInfo, plr, true);*/
 
-	// reset team
-	plr->ResetTeam();
-
 	/* revive the player if he is dead */
 	if(!plr->isAlive())
 	{
Index: game/Creature.cpp
===================================================================
--- game/Creature.cpp	(revision 2522)
+++ game/Creature.cpp	(working copy)
@@ -831,7 +831,7 @@
 	//SetUInt32Value(UNIT_FIELD_MAXHEALTH, (mode ? long2int32(proto->Health * 1.5)  : proto->Health));
 	uint32 health = proto->MinHealth + RandomUInt(proto->MaxHealth - proto->MinHealth);
 	if(mode)
-		health = long2int32(double(health) * 1.5);
+		health = long2int32(double(health) * 2.0f);
 	SetUInt32Value(UNIT_FIELD_HEALTH, health);
 	SetUInt32Value(UNIT_FIELD_MAXHEALTH, health);
 	SetUInt32Value(UNIT_FIELD_BASE_HEALTH, health);
@@ -855,11 +855,11 @@
 		ModUInt32Value(UNIT_FIELD_LEVEL, info->lvl_mod_a);
 
 	for(uint32 i = 0; i < 7; ++i)
-		SetUInt32Value(UNIT_FIELD_RESISTANCES+i,proto->Resistances[i]);
+		SetUInt32Value(UNIT_FIELD_RESISTANCES+i,(mode ? (uint32)(proto->Resistances[i]*1.5f)  : proto->Resistances[i]));
 
 	SetUInt32Value(UNIT_FIELD_BASEATTACKTIME,proto->AttackTime);
-	SetFloatValue(UNIT_FIELD_MINDAMAGE, (mode ? proto->MinDamage * 1.5f  : proto->MinDamage));
-	SetFloatValue(UNIT_FIELD_MAXDAMAGE, (mode ? proto->MaxDamage * 1.5f  : proto->MaxDamage));
+	SetFloatValue(UNIT_FIELD_MINDAMAGE, (mode ? proto->MinDamage * 2.0f  : proto->MinDamage));
+	SetFloatValue(UNIT_FIELD_MAXDAMAGE, (mode ? proto->MaxDamage * 2.0f  : proto->MaxDamage));
 
 	SetUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,proto->RangedAttackTime);
 	SetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE,proto->RangedMinDamage);
Index: game/DayWatcherThread.cpp
===================================================================
--- game/DayWatcherThread.cpp	(revision 2522)
+++ game/DayWatcherThread.cpp	(working copy)
@@ -178,7 +178,8 @@
 	Player * plr;
 	uint32 guid, arenapoints, orig_arenapoints;
 	ArenaTeam * team;
-	long double X, Y;
+	uint32 arenapointsPerTeam[3] = {0};
+	double X, Y;
 	if(result)
 	{
 		do
@@ -188,6 +189,9 @@
 			arenapoints = f[1].GetUInt32();
 			orig_arenapoints = arenapoints;
 
+			for(uint32 i = 0; i < 3; ++i)
+				arenapointsPerTeam[i] = 0;
+
 			/* are we in any arena teams? */
 			for(uint32 i = 0; i < 3; ++i)			// 3 arena team types
 			{
@@ -200,7 +204,7 @@
 
 					/* we're in an arena team of this type! */
 					/* Source: http://www.wowwiki.com/Arena_point */
-					X = (long double)team->m_stat_rating;
+					X = (double)team->m_stat_rating;
 					if(X <= 510.0)	// "if X<=510"
 						continue;		// no change
 					else if(X > 510.0 && X <= 1500.0)		// "if 510 < X <= 1500"
@@ -215,11 +219,11 @@
 						//                   -0.00412*X
 						//    1+1639.28*2.71828
 
-						long double power = ((-0.00412) * X);
+						double power = ((-0.00412) * X);
 						//if(power < 1.0)
 						//	power = 1.0;
 
-						long double divisor = pow(((long double)(2.71828)), power);						
+						double divisor = pow(((double)(2.71828)), power);						
 						divisor *= 1639.28;
 						divisor += 1.0;
 						//if(divisor < 1.0)
@@ -246,10 +250,13 @@
 					}
 					
 					if(Y > 1.0)
-						arenapoints += long2int32(double(ceil(Y)));
+						arenapointsPerTeam[i] += long2int32(double(ceil(Y)));
 				}
 			}
 
+			arenapointsPerTeam[0] = max(arenapointsPerTeam[0],arenapointsPerTeam[1]);
+			arenapoints += max(arenapointsPerTeam[0],arenapointsPerTeam[2]);
+
 			if(orig_arenapoints != arenapoints)
 			{
 				plr = objmgr.GetPlayer(guid);
Index: game/GameObject.cpp
===================================================================
--- game/GameObject.cpp	(revision 2522)
+++ game/GameObject.cpp	(working copy)
@@ -385,7 +385,7 @@
                         //herbalism and mining;
                         if(pLock->lockmisc[i] == LOCKTYPE_MINING || pLock->lockmisc[i] == LOCKTYPE_HERBALISM)
                         {
-                            mines_remaining = GetInfo()->sound4 + RandomUInt(GetInfo()->sound5 - GetInfo()->sound4);
+                           CalcMineRemaining(true);
                         }
                     }
                 }
Index: game/GameObject.h
===================================================================
--- game/GameObject.h	(revision 2522)
+++ game/GameObject.h	(working copy)
@@ -225,8 +225,13 @@
 	void OnRemoveInRangeObject(Object* pObj);
 	void RemoveFromWorld(bool free_guid);
 
-	inline bool CanMine(){return mines_remaining != 1 && mines_remaining > 0;}
+	inline bool CanMine(){return (mines_remaining > 0);}
 	inline void UseMine(){ if(mines_remaining) mines_remaining--;}
+	void CalcMineRemaining(bool force)
+	{
+		if(force || !mines_remaining)
+			mines_remaining = GetInfo()->sound4 + RandomUInt(GetInfo()->sound5 - GetInfo()->sound4) - 1;
+	}
     bool HasLoot();
 	MapCell * m_respawnCell;
 
Index: game/Item.cpp
===================================================================
--- game/Item.cpp	(revision 2522)
+++ game/Item.cpp	(working copy)
@@ -700,6 +700,7 @@
 						TS.procChance = Entry->min[c];
 					Log.Debug("Enchant","Setting procChance to %u%%.", TS.procChance);
 					TS.deleted = false;
+					TS.ProcType = (GetProto()->Class == ITEM_CLASS_WEAPON)? 1 : 2;
 					TS.spellId = Entry->spell[c];
 					m_owner->m_procSpells.push_back(TS);
 				}
Index: game/ItemHandler.cpp
===================================================================
--- game/ItemHandler.cpp	(revision 2522)
+++ game/ItemHandler.cpp	(working copy)
@@ -709,7 +709,7 @@
 	data << itemProto->ItemSet;
 	data << itemProto->MaxDurability;
 	data << itemProto->ZoneNameID;
-	data << itemProto->Field114;
+	data << itemProto->MapID;
 	data << itemProto->BagFamily;
 	data << itemProto->ToolCategory;
 	data << itemProto->Sockets[0].SocketColor ;
@@ -1025,7 +1025,7 @@
 		return;
 	}
 
-	if((error = _player->GetItemInterface()->CanAffordItem(it,amount*itemd.amount,itemd.amount)))
+	if((error = _player->GetItemInterface()->CanAffordItem(it,amount*itemd.amount,itemd.amount,unit->m_faction->Faction)))
 	{
 		SendBuyFailed(srcguid, itemd.itemid, error);
 		return;
@@ -1111,7 +1111,7 @@
 		SendPacket(&data);*/
 	}
 
-	_player->GetItemInterface()->BuyItem(it,amount*itemd.amount,itemd.amount);
+	_player->GetItemInterface()->BuyItem(it,amount*itemd.amount,itemd.amount,unit->m_faction->Faction);
 
 	WorldPacket data(SMSG_BUY_ITEM, 12);
 	data << uint64(srcguid);
@@ -1174,7 +1174,7 @@
 		return;
 	}
 
-   if((error = _player->GetItemInterface()->CanAffordItem(it,amount*item.amount,item.amount)))
+   if((error = _player->GetItemInterface()->CanAffordItem(it,amount*item.amount,item.amount,unit->m_faction->Faction)))
    {
       SendBuyFailed(srcguid, itemid, error);
       return;
@@ -1238,7 +1238,7 @@
 	 data << uint32(itemid) << uint32(amount*item.amount);
 	 SendPacket( &data );
 		
-	 _player->GetItemInterface()->BuyItem(it,amount*item.amount,item.amount);
+	 _player->GetItemInterface()->BuyItem(it,amount*item.amount,item.amount,unit->m_faction->Faction);
 }
 
 void WorldSession::HandleListInventoryOpcode( WorldPacket & recv_data )
@@ -1289,7 +1289,11 @@
 				data << curItem->ItemId;
 				data << curItem->DisplayInfoID;
 				data << (int32)(-1); //we dont suport this kind of buy, make them infinite
-				data << GetBuyPriceForItem(curItem, abs(itr->amount), abs(itr->amount));
+
+				uint32 price = GetBuyPriceForItem(curItem, abs(itr->amount), abs(itr->amount));
+				price = float2int32(_player->GetReputationPriceDiscount(unit->m_faction->Faction)*price);
+
+				data << price;
 				data << uint32(0x00);
 				data << (int16)itr->amount;
 				data << uint16(0x00);
Index: game/ItemInterface.cpp
===================================================================
--- game/ItemInterface.cpp	(revision 2522)
+++ game/ItemInterface.cpp	(working copy)
@@ -1322,7 +1322,13 @@
 
 	if((slot < INVENTORY_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET) || (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET))
 	{
-		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat())
+		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat()
+			&& proto->InventoryType != INVTYPE_WEAPON && proto->InventoryType != INVTYPE_WEAPONMAINHAND
+			&& proto->InventoryType != INVTYPE_RANGED && proto->InventoryType != INVTYPE_WEAPONOFFHAND
+			&& proto->InventoryType != INVTYPE_SHIELD && proto->InventoryType != INVTYPE_2HWEAPON
+			&& proto->InventoryType != INVTYPE_AMMO && proto->InventoryType != INVTYPE_THROWN
+			&& proto->InventoryType != INVTYPE_RANGEDRIGHT
+			)
 			return INV_ERR_CANT_DO_IN_COMBAT;
 
 		if(proto->Flags & ITEM_FLAG_UNIQUE_EQUIP && IsEquipped(proto->ItemId))
@@ -1743,11 +1749,12 @@
 	return (int8)NULL;
 }
 
-void ItemInterface::BuyItem(ItemPrototype *item, uint32 total_amount,uint32 vendorcount)
+void ItemInterface::BuyItem(ItemPrototype *item, uint32 total_amount,uint32 vendorcount, uint32 seller_faction)
 {
 	if(item->BuyPrice)
 	{
 		int32 itemprice = GetBuyPriceForItem(item, total_amount, vendorcount);
+		itemprice = float2int32(m_pOwner->GetReputationPriceDiscount(seller_faction)*itemprice);
 		m_pOwner->ModUInt32Value(PLAYER_FIELD_COINAGE, -itemprice);
 	}
 	if(item->ItemExtendedCost)
@@ -1779,7 +1786,7 @@
 
 }
 
-int8 ItemInterface::CanAffordItem(ItemPrototype *item,uint32 total_amount,uint32 vendorcount)
+int8 ItemInterface::CanAffordItem(ItemPrototype *item,uint32 total_amount,uint32 vendorcount, uint32 seller_faction)
 {
 	if(item->ItemExtendedCost)
 	{
@@ -1804,6 +1811,8 @@
 	if(item->BuyPrice)
 	{
 		int32 price = GetBuyPriceForItem(item, total_amount, vendorcount);
+		price = float2int32(m_pOwner->GetReputationPriceDiscount(seller_faction)*price);
+
 		if((int32)m_pOwner->GetUInt32Value(PLAYER_FIELD_COINAGE) < price)
 		{
 			return INV_ERR_NOT_ENOUGH_MONEY;
@@ -2704,51 +2713,28 @@
 	return false;
 }
 
-/**********************************
-* DESCRIPTION:
-* Prevents items bound to a
-* specific area ID to leave the 
-* zone. Actually, it deletes it.
-* Very similar structure to
-* ItemInterface::GetItemCount()
-**********************************/
 
-void ItemInterface::CheckAreaItems()
-{
-	/* Being debugged by Supalosa - at the moment it doesn't seem to actually seem to 'find' the items...
-	sLog.outString( "Checking player %s for zone-specific items:" , GetOwner()->GetNameString());
-	// Check equipment and backpack first (not inventory)
-	for( uint32 i = EQUIPMENT_SLOT_START ; i < EQUIPMENT_SLOT_END ; i++ )
-	{
-		Item *item = GetInventoryItem( i );
-		if( item )
-		{
-			// Field114 = MapID
-			if( item->GetProto()->Field114 != 0 && item->GetProto()->Field114 != GetOwner()->GetMapId() )
-			{
-				sLog.outString( "    Found %s in slot %u, removing." , item->GetProto()->Name1 , i );
-				SafeFullRemoveItemByGuid(item->GetGUID());
-				
-			}
+ void ItemInterface::CheckAreaItems()
+ {
+	for(uint32 x = EQUIPMENT_SLOT_START; x < INVENTORY_SLOT_ITEM_END; ++x)
+ 	{
+		if (m_pItems[x]!= NULL)
+ 		{
+			if(IsBagSlot(x) && m_pItems[x]->IsContainer())
+ 			{
+				Container * bag = (Container*)m_pItems[x];
 
-		}
-	}
-	// Check inventory
-	for( uint32 j = INVENTORY_SLOT_BAG_START ; j < INVENTORY_SLOT_BAG_END ; j++ )
-	{
-		Container *item = ((Container*)GetInventoryItem( j )); // This will be a container.
-		if( item && item->GetTypeId() == TYPEID_CONTAINER )
-		{
-			for( uint32 h = 0 ; h < item->GetProto()->ContainerSlots ; h++ )
+				for(uint32 i = 0; i < bag->GetProto()->ContainerSlots; i++)
+ 				{
+					if (bag->GetItem(i) != NULL && bag->GetItem(i)->GetProto() && bag->GetItem(i)->GetProto()->MapID && bag->GetItem(i)->GetProto()->MapID != GetOwner()->GetMapId())
+						bag->SafeFullRemoveItemFromSlot(i);
+ 				}
+ 			}
+			else
 			{
-				Item *innerItem = item->GetItem(h);
-				if( innerItem && innerItem->GetProto()->Field114 != 0 && innerItem->GetProto()->Field114 != GetOwner()->GetMapId() )
-				{
-					sLog.outString( "    Found %s in bag %u, slot %u, removing." , item->GetProto()->Name1 , j , h );
-					SafeFullRemoveItemByGuid(item->GetGUID());
-				}
+				if(m_pItems[x]->GetProto() && m_pItems[x]->GetProto()->MapID && m_pItems[x]->GetProto()->MapID != GetOwner()->GetMapId() )
+					SafeFullRemoveItemFromSlot(INVENTORY_SLOT_NOT_SET, x);
 			}
-		}
-	}
-	*/
-}
+ 		}
+ 	}
+ }
Index: game/ItemInterface.h
===================================================================
--- game/ItemInterface.h	(revision 2522)
+++ game/ItemInterface.h	(working copy)
@@ -79,7 +79,7 @@
 	uint32 GetItemCount(uint32 itemid, bool IncBank = false);
 	uint32 RemoveItemAmt(uint32 id, uint32 amt);
 	void RemoveAllConjured();
-	void BuyItem(ItemPrototype *item, uint32 total_amount,uint32 vendorcount);
+	void BuyItem(ItemPrototype *item, uint32 total_amount,uint32 vendorcount, uint32 seller_faction);
 
 	uint32 CalculateFreeSlots(ItemPrototype *proto);
 	void ReduceItemDurability();
@@ -99,7 +99,7 @@
 
 	int8 CanEquipItemInSlot(int8 DstInvSlot, int8 slot, ItemPrototype* item, bool ignore_combat = false);
 	int8 CanReceiveItem(ItemPrototype * item, uint32 amount);
-	int8 CanAffordItem(ItemPrototype * item,uint32 total_amount,uint32 vendorcount);
+	int8 CanAffordItem(ItemPrototype * item,uint32 total_amount,uint32 vendorcount, uint32 seller_faction);
 	int8 GetItemSlotByType(uint32 type);
 	Item* GetItemByGUID(uint64 itemGuid);
 
Index: game/ItemPrototype.h
===================================================================
--- game/ItemPrototype.h	(revision 2522)
+++ game/ItemPrototype.h	(working copy)
@@ -545,7 +545,7 @@
 	uint32 ItemSet;
 	uint32 MaxDurability;
 	uint32 ZoneNameID;
-	uint32 Field114; // ... MapID says I
+	uint32 MapID;
 	uint32 BagFamily;
 	uint32 ToolCategory;
 	SocketInfo Sockets[3];
Index: game/Level2.cpp
===================================================================
--- game/Level2.cpp	(revision 2522)
+++ game/Level2.cpp	(working copy)
@@ -256,7 +256,7 @@
 		uint32 guidlow = GUID_LOPART(guid);
 
 		std::stringstream ss;
-		ss << "DELETE FROM vendors WHERE vendorGuid = " << guidlow << " AND itemGuid = " << itemguid << '\0';
+		ss << "DELETE FROM vendors WHERE `entry` = " << guidlow << " AND `item` = " << itemguid << '\0';
 		WorldDatabase.Execute( ss.str().c_str() );
 
 		pCreature->RemoveVendorItem(itemguid);
@@ -999,7 +999,7 @@
 	}
 
 	std::stringstream qry;
-	qry << "INSERT INTO ai_agents set entryId = '" << target->GetUInt32Value(OBJECT_FIELD_ENTRY) << "', AI_AGENT = '" << atoi(agent) << "', procEvent = '" << atoi(procEvent)<< "', procChance = '" << atoi(procChance)<< "', procCount = '" << atoi(procCount)<< "', spellId = '" << atoi(spellId)<< "', spellType = '" << atoi(spellType)<< "', spelltargetType = '" << atoi(spelltargetType)<< "', spellCooldown = '" << atoi(spellCooldown)<< "', floatMisc1 = '" << atof(floatMisc1)<< "', Misc2  ='" << atoi(Misc2)<< "'";
+	qry << "INSERT INTO ai_agents set `entry` = '" << target->GetUInt32Value(OBJECT_FIELD_ENTRY) << "', `type` = '" << atoi(agent) << "', `event` = '" << atoi(procEvent)<< "', `chance` = '" << atoi(procChance)<< "', `maxcount` = '" << atoi(procCount)<< "', `spell` = '" << atoi(spellId)<< "', `spelltype` = '" << atoi(spellType)<< "', `targettype` = '" << atoi(spelltargetType)<< "', `cooldown` = '" << atoi(spellCooldown)<< "', floatMisc1 = '" << atof(floatMisc1)<< "', Misc2  ='" << atoi(Misc2)<< "'";
 	WorldDatabase.Execute( qry.str().c_str( ) );
 
 	AI_Spell * sp = new AI_Spell;
Index: game/Level3.cpp
===================================================================
--- game/Level3.cpp	(revision 2522)
+++ game/Level3.cpp	(working copy)
@@ -2251,7 +2251,7 @@
 
 bool ChatHandler::HandleAIAgentDebugBegin(const char * args, WorldSession * m_session)
 {
-	QueryResult * result = WorldDatabase.Query("SELECT DISTINCT spell FROM ai_agents");
+	QueryResult * result = WorldDatabase.Query("SELECT DISTINCT spellId FROM ai_agents");
 	if(!result) return false;
 
 	do 
@@ -2264,7 +2264,7 @@
 
 	for(list<SpellEntry*>::iterator itr = aiagent_spells.begin(); itr != aiagent_spells.end(); ++itr)
 	{
-		result = WorldDatabase.Query("SELECT * FROM ai_agents WHERE spell = %u", (*itr)->Id);
+		result = WorldDatabase.Query("SELECT * FROM ai_agents WHERE `spell` = %u", (*itr)->Id);
 		ASSERT(result);
 		spell_thingo t;
 		t.type = result->Fetch()[6].GetUInt32();
Index: game/MailSystem.cpp
===================================================================
--- game/MailSystem.cpp	(revision 2522)
+++ game/MailSystem.cpp	(working copy)
@@ -518,9 +518,10 @@
 
 		// deleted_flag prevents it from being shown in the mail list.
 		message->deleted_flag = 1;
+		message->read_flag = 1;
 
 		// update in sql
-		CharacterDatabase.WaitExecute("UPDATE mailbox SET deleted_flag = 1 WHERE message_id = %u", message_id);
+		CharacterDatabase.WaitExecute("UPDATE mailbox SET deleted_flag = 1, read_flag = 1 WHERE message_id = %u", message_id);
 	}
 	else
 	{
Index: game/Map.cpp
===================================================================
--- game/Map.cpp	(revision 2522)
+++ game/Map.cpp	(working copy)
@@ -130,7 +130,7 @@
 	set<string>::iterator tableiterator;
 	for(tableiterator=ExtraMapCreatureTables.begin(); tableiterator!=ExtraMapCreatureTables.end();++tableiterator)
 	{
-		result = WorldDatabase.Query("SELECT * FROM %s WHERE Map = %u",(*tableiterator).c_str(),this->_mapId);
+		result = WorldDatabase.Query("SELECT * FROM %s WHERE map = %u",(*tableiterator).c_str(),this->_mapId);
 		if(result)
 		{
 			do{
Index: game/MiscHandler.cpp
===================================================================
--- game/MiscHandler.cpp	(revision 2522)
+++ game/MiscHandler.cpp	(working copy)
@@ -463,17 +463,8 @@
                                     }
                                     else
                                     {
-                                        uint32 DespawnTime = 0;
-
-			                            if(sQuestMgr.GetGameObjectLootQuest(pGO->GetEntry()))
-				                            DespawnTime = 120000;	   // 5 min for quest GO,
-			                            else
-			                            {
-				                            DespawnTime = 900000;	   // 15 for else
-			                            }
-
-
-			                            pGO->Despawn(DespawnTime);
+                                        pGO->CalcMineRemaining(true);
+			                            pGO->Despawn(900000);
 										return;
                                     }
                                 }
Index: game/ObjectMgr.cpp
===================================================================
--- game/ObjectMgr.cpp	(revision 2522)
+++ game/ObjectMgr.cpp	(working copy)
@@ -1402,7 +1402,7 @@
 		result2 = WorldDatabase.Query("SELECT * FROM trainer_spells where entry='%u'",entry);
 		if(!result2)
 		{
-			Log.Error("LoadTrainers", "Trainer with no spells, entry %u.", entry);
+			Log.Debug("LoadTrainers", "Trainer with no spells, entry %u.", entry);
 			delete [] tr->UIMessage;
 			delete tr;
 			continue;
@@ -1417,7 +1417,7 @@
 				SpellEntry *spellInfo = dbcSpell.LookupEntryForced(CastSpellID );
 				if(!spellInfo)
 				{
-					Log.Error("LoadTrainers", "Trainer %u with non-existant spell %u.", entry, CastSpellID);
+					Log.Debug("LoadTrainers", "Trainer %u with non-existant spell %u.", entry, CastSpellID);
 					continue; //omg a bad spell !
 				}
 
@@ -1443,7 +1443,7 @@
 
 				if(ts.pRealSpell == NULL)
 				{
-					Log.Error("LoadTrainers", "Trainer %u contains spell %u which doesn't teach.", entry, CastSpellID);
+					Log.Debug("LoadTrainers", "Trainer %u contains spell %u which doesn't teach.", entry, CastSpellID);
 				}
 				else
 				{
@@ -2456,9 +2456,13 @@
 			replimit = i->mob_rep_reward;
 		}
 
-		if(!value || (replimit && pPlayer->GetStanding(i->faction[team]) >= replimit))
+		if(!value)
 			continue;
 
+		if (pPlayer->iInstanceType != MODE_HEROIC)
+			if(replimit && pPlayer->GetStanding(i->faction[team]) >= replimit)
+				continue;
+
 		//value *= sWorld.getRate(RATE_KILLREPUTATION);
 		value = float2int32(float(value) * sWorld.getRate(RATE_KILLREPUTATION));
 		pPlayer->ModStanding(i->faction[team], value);
Index: game/Player.cpp
===================================================================
--- game/Player.cpp	(revision 2522)
+++ game/Player.cpp	(working copy)
@@ -3112,10 +3112,9 @@
 
 	SetUInt32Value(UNIT_FIELD_HEALTH, load_health);
 	SetUInt32Value(UNIT_FIELD_POWER1, load_mana);
-	/* Being debugged by Supalosa
-	if( !GetSession()->HasGMPermissions() ) // Removed map check thingy - /me is an idiot. GM characters are allowed to take items out of the instance though :)
-	GetItemInterface()->CheckAreaItems(); // Removes items like Devastation when you leave their Field114 (MapID)
-	*/
+
+	if( !GetSession()->HasGMPermissions() )
+		GetItemInterface()->CheckAreaItems(); 
 }
 
 void Player::ResetHeartbeatCoords()
@@ -3405,6 +3404,7 @@
 				ts.caster=this->GetGUID();
 				ts.procFlags=PROC_ON_MELEE_ATTACK;
 				ts.deleted = false;
+				ts.ProcType = (item->GetProto()->Class == ITEM_CLASS_WEAPON)? 1 : 2;
 				this->m_procSpells.push_front(ts);			
 			}
 		}
@@ -5085,17 +5085,15 @@
 					data2 << guid;
 					data2 << x;
 					data2 << uint32(iter->item.itemproto->ItemId);
+
 					data2 << uint32(0);
-					if(!iter->iRandomProperty)
-					{
-						if(iter->iRandomSuffix)
-							data << uint32(-int32(iter->iRandomSuffix->id));
-						else
-							data2 << uint32(0);
-					}
-					else
+					data2 << uint32(factor);
+					if(iter->iRandomProperty)
 						data2 << uint32(iter->iRandomProperty->ID);
-
+					else if(iter->iRandomSuffix)
+						data2 << uint32(ipid);
+ 					else
+						data2 << uint32(0);
 					data2 << uint32(60000); // countdown
 				}
 
@@ -5257,6 +5255,22 @@
 	}
 }
 
+void Player::removeDeletedSpellByHashName(uint32 hash)
+{
+	SpellSet::iterator it,iter;
+	
+	for(iter= mDeletedSpells.begin();iter != mDeletedSpells.end();)
+	{
+		it = iter++;
+		uint32 SpellID = *it;
+		SpellEntry *e = dbcSpell.LookupEntry(SpellID);
+		if(e->NameHash == hash)
+		{
+			mDeletedSpells.erase(it);
+		}
+	}
+}
+
 void Player::removeSpellByHashName(uint32 hash)
 {
 	SpellSet::iterator it,iter;
@@ -5509,11 +5523,14 @@
 							//remove higher ranks of this spell too (like earth shield lvl 1 is talent and the rest is thought from trainer) 
 							SpellEntry *spellInfo2;
 							spellInfo2 = dbcSpell.LookupEntry( spellInfo->EffectTriggerSpell[k] );
-							if(spellInfo2)
-								removeSpellByHashName(spellInfo2->NameHash);
-						}
+							if(spellInfo2) {
+ 								removeSpellByHashName(spellInfo2->NameHash);
+								removeDeletedSpellByHashName(spellInfo2->NameHash);
+							}
+ 						}
 					//remove them all in 1 shot
 					removeSpellByHashName(spellInfo->NameHash);
+					removeDeletedSpellByHashName(spellInfo->NameHash);
 				}
 			}
 			else
Index: game/Player.h
===================================================================
--- game/Player.h	(revision 2522)
+++ game/Player.h	(working copy)
@@ -857,6 +857,7 @@
 	void smsg_InitialSpells();
 	void addSpell(uint32 spell_idy);
 	void removeSpellByHashName(uint32 hash);
+	void removeDeletedSpellByHashName(uint32 hash);
 	bool removeSpell(uint32 SpellID, bool MoveToDeleted, bool SupercededSpell, uint32 SupercededSpellID);
 
     // PLEASE DO NOT INLINE!
@@ -913,6 +914,7 @@
 	void                Reputation_OnKilledUnit(Unit * pUnit, bool InnerLoop);
 	void                Reputation_OnTalk(FactionDBC * dbc);
 	static Standing     GetReputationRankFromStanding(int32 Standing_);
+	float			    GetReputationPriceDiscount(uint32 seller_faction);
 	
     /************************************************************************/
     /* Factions                                                             */
Index: game/RecallCommands.cpp
===================================================================
--- game/RecallCommands.cpp	(revision 2522)
+++ game/RecallCommands.cpp	(working copy)
@@ -55,7 +55,7 @@
 	if(!*args)
 		return false;
 	
-	QueryResult *result = WorldDatabase.Query( "SELECT locname FROM recall" );
+	QueryResult *result = WorldDatabase.Query( "SELECT name FROM recall" );
 	if(!result)
 		return false;
 	do
@@ -76,7 +76,7 @@
 	
 	string rc_locname = string(args);
 
-	ss << "INSERT INTO recall (locname, mapid, positionX, positionY, positionZ) VALUES ('"
+	ss << "INSERT INTO recall (name, mapid, positionX, positionY, positionZ) VALUES ('"
 	<< WorldDatabase.EscapeString(rc_locname).c_str() << "' , "
 	<< plr->GetMapId() << ", "
 	<< plr->GetPositionX() << ", " 
@@ -98,7 +98,7 @@
 	   if(!*args)
 		return false;
 
-	QueryResult *result = WorldDatabase.Query( "SELECT id,locname FROM recall" );
+	QueryResult *result = WorldDatabase.Query( "SELECT id,name FROM recall" );
 	if(!result)
 		return false;
 
@@ -127,7 +127,7 @@
 
 bool ChatHandler::HandleRecallListCommand(const char* args, WorldSession *m_session)
 {
-	QueryResult *result = WorldDatabase.Query( "SELECT id,locname FROM recall ORDER BY locname" );
+	QueryResult *result = WorldDatabase.Query( "SELECT id,name FROM recall ORDER BY name" );
 	if(!result)
 		return false;
 	std::string recout;
Index: game/ReputationHandler.cpp
===================================================================
--- game/ReputationHandler.cpp	(revision 2522)
+++ game/ReputationHandler.cpp	(working copy)
@@ -41,6 +41,27 @@
 	return STANDING_EXALTED;
 }
 
+float Player::GetReputationPriceDiscount(uint32 seller_faction)
+{
+	Standing standing = GetReputationRankFromStanding(this->GetStanding(seller_faction));
+	switch(standing)
+	{
+		case FRIENDLY:
+			return 0.95f;
+		break;
+		case HONORED:
+			return 0.90f;
+		break;
+		case REVERED:
+			return 0.85f;
+		break;
+		case EXALTED:
+			return 0.80f;
+		break;
+	}
+	return 1.0f;
+}
+
 inline void SetFlagAtWar(uint8 & flag)
 {
 	if(flag & FACTION_FLAG_AT_WAR)
Index: game/Spell.cpp
===================================================================
--- game/Spell.cpp	(revision 2522)
+++ game/Spell.cpp	(working copy)
@@ -2133,7 +2133,14 @@
 	}
 
 	if(m_spellInfo->powerType==POWER_TYPE_HEALTH)
-		cost -= m_spellInfo->baseLevel;//FIX for life tap	
+	{
+		// For Life Tap don't do repeat damage process
+		if (m_spellInfo->NameHash == 0x0807C866) return true;
+
+		// The caster doesnt have enough health to use this spell...stop casting
+		if (u_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= (uint32)cost) 
+			return false;
+	}
 	else if(u_caster)
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
@@ -3043,6 +3050,11 @@
 
 	if(i_caster) // if the caster is an item
 	{
+		if( i_caster->GetProto()->ZoneNameID && i_caster->GetProto()->ZoneNameID != i_caster->GetZoneId() ) 
+			return SPELL_FAILED_NOT_HERE;
+		if( i_caster->GetProto()->MapID && i_caster->GetProto()->MapID != i_caster->GetMapId() )
+			return SPELL_FAILED_NOT_HERE;
+
 		// *** ITEM CHARGES CHECK - Partha ***
 		if( i_caster->GetProto()->Spells[0].Charges != 0 && ((int32)i_caster->GetUInt32Value(ITEM_FIELD_SPELL_CHARGES)) == 0 )
 			return SPELL_FAILED_NO_CHARGES_REMAIN; // Item has no charges left
Index: game/SpellAuras.cpp
===================================================================
--- game/SpellAuras.cpp	(revision 2522)
+++ game/SpellAuras.cpp	(working copy)
@@ -564,6 +564,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.ProcType = 0;
 			m_target->m_procSpells.push_front(pts);
 		}
 		else
@@ -1347,6 +1348,7 @@
 			pts.procFlags = GetSpellProto()->procFlags;
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
+			pts.ProcType = 0;
 			pts.deleted = false;
 			m_target->m_procSpells.push_front(pts);
 			}
@@ -1720,6 +1722,7 @@
 				pts.procCharges = GetSpellProto()->procCharges;
 				pts.LastTrigger = 0;
 				pts.deleted = false;
+				pts.ProcType = 0;
 				m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1914,6 +1917,7 @@
 
 		if(p_target)
 		{
+			static_cast<Player*>(m_target)->EventAttackStop();
 			// this is a hackfix to stop player from moving -> see AIInterface::_UpdateMovement() Fear AI for more info
 			WorldPacket data1(9);
 			data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
@@ -3523,6 +3527,7 @@
 		pts.procCharges = GetSpellProto()->procCharges;
 		pts.LastTrigger = 0;
 		pts.deleted = false;
+		pts.ProcType = 0;
 
 		if(m_spellProto->NameHash == 0xE4573D4A)
 		{
Index: game/SpellAuras.h
===================================================================
--- game/SpellAuras.h	(revision 2522)
+++ game/SpellAuras.h	(working copy)
@@ -304,7 +304,7 @@
 //    SpellEntry *ospinfo;
 //    SpellEntry *spinfo;
     uint32 LastTrigger;
-	uint32 ProcType; //0=talents/spells 1=weapon 2=armor  TODO: implement.
+	uint32 ProcType; //0=talents/spells 1=weapon 2=armor
     bool deleted;
 };
 
Index: game/SpellEffects.cpp
===================================================================
--- game/SpellEffects.cpp	(revision 2522)
+++ game/SpellEffects.cpp	(working copy)
@@ -520,6 +520,7 @@
 
 		uint32 damage = m_spellInfo->EffectBasePoints[i]+1;
 		uint32 man = (damage *(100+playerTarget->m_lifetapbonus))/100;
+		if (p_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= damage) return;
 		p_caster->DealDamage(playerTarget,damage,0,0,spellId);
 		playerTarget->ModUInt32Value(UNIT_FIELD_POWER1,man);
 		if(playerTarget->GetUInt32Value(UNIT_FIELD_POWER1) > playerTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1))
@@ -1089,6 +1090,7 @@
 			ILotP.procFlags = PROC_ON_CRIT_ATTACK | PROC_TAGRGET_SELF;
 			ILotP.deleted = false;
 			ILotP.caster = u_caster->GetGUID();
+			ILotP.ProcType = 0;
 			ILotP.LastTrigger = 0;
 			u_caster->m_procSpells.push_back(ILotP);
 		}
@@ -2308,6 +2310,77 @@
 		playerTarget->addSpell(spellToLearn);
 		//smth is wrong here, first we add this spell to player then we may cast it on player...
 		SpellEntry *spellinfo = dbcSpell.LookupEntry(spellToLearn);
+		//remove specializations
+		switch(spellinfo->Id)
+		{
+		case 26801: //Shadoweave Tailoring
+			playerTarget->removeSpell(26798,false,false,0); //Mooncloth Tailoring
+			playerTarget->removeSpell(26797,false,false,0); //Spellfire Tailoring
+			break;
+		case 26798: // Mooncloth Tailoring
+			playerTarget->removeSpell(26801,false,false,0); //Shadoweave Tailoring
+			playerTarget->removeSpell(26797,false,false,0); //Spellfire Tailoring
+			break;
+		case 26797: //Spellfire Tailoring
+			playerTarget->removeSpell(26801,false,false,0); //Shadoweave Tailoring
+			playerTarget->removeSpell(26798,false,false,0); //Mooncloth Tailoring
+			break;
+		case 10656: //Dragonscale Leatherworking
+			playerTarget->removeSpell(10658,false,false,0); //Elemental Leatherworking
+			playerTarget->removeSpell(10660,false,false,0); //Tribal Leatherworking
+			break;
+		case 10658: //Elemental Leatherworking
+			playerTarget->removeSpell(10656,false,false,0); //Dragonscale Leatherworking
+			playerTarget->removeSpell(10660,false,false,0); //Tribal Leatherworking
+			break;
+		case 10660: //Tribal Leatherworking
+			playerTarget->removeSpell(10656,false,false,0); //Dragonscale Leatherworking
+			playerTarget->removeSpell(10658,false,false,0); //Elemental Leatherworking
+			break;
+		case 28677: //Elixir Master
+			playerTarget->removeSpell(28675,false,false,0); //Potion Master
+			playerTarget->removeSpell(28672,false,false,0); //Transmutation Maste
+			break;
+		case 28675: //Potion Master
+			playerTarget->removeSpell(28677,false,false,0); //Elixir Master
+			playerTarget->removeSpell(28672,false,false,0); //Transmutation Maste
+			break;
+		case 28672: //Transmutation Master
+			playerTarget->removeSpell(28675,false,false,0); //Potion Master
+			playerTarget->removeSpell(28677,false,false,0); //Elixir Master
+			break;
+		case 20219: //Gnomish Engineer
+			playerTarget->removeSpell(20222,false,false,0); //Goblin Engineer
+			break;
+		case 20222: //Goblin Engineer
+			playerTarget->removeSpell(20219,false,false,0); //Gnomish Engineer
+			break;
+		case 9788: //Armorsmith
+			playerTarget->removeSpell(9787,false,false,0); //Weaponsmith
+			playerTarget->removeSpell(17039,false,false,0); //Master Swordsmith
+			playerTarget->removeSpell(17040,false,false,0); //Master Hammersmith
+			playerTarget->removeSpell(17041,false,false,0); //Master Axesmith
+			break;
+		case 9787: //Weaponsmith
+			playerTarget->removeSpell(9788,false,false,0); //Armorsmith
+			break;
+		case 17041: //Master Axesmith
+			playerTarget->removeSpell(9788,false,false,0); //Armorsmith
+			playerTarget->removeSpell(17040,false,false,0); //Master Hammersmith
+			playerTarget->removeSpell(17039,false,false,0); //Master Swordsmith
+			break;
+		case 17040: //Master Hammersmith
+			playerTarget->removeSpell(9788,false,false,0); //Armorsmith
+			playerTarget->removeSpell(17039,false,false,0); //Master Swordsmith
+			playerTarget->removeSpell(17041,false,false,0); //Master Axesmith
+			break;
+		case 17039: //Master Swordsmith
+			playerTarget->removeSpell(9788,false,false,0); //Armorsmith
+			playerTarget->removeSpell(17040,false,false,0); //Master Hammersmith
+			playerTarget->removeSpell(17041,false,false,0); //Master Axesmith
+			break;
+		}
+
 		for(uint32 i=0;i<3;i++)
 			if(spellinfo->Effect[i] == SPELL_EFFECT_WEAPON ||
 			   spellinfo->Effect[i] == SPELL_EFFECT_PROFICIENCY ||
Index: game/Unit.cpp
===================================================================
--- game/Unit.cpp	(revision 2522)
+++ game/Unit.cpp	(working copy)
@@ -403,6 +403,7 @@
 
 	//Get Highest Level Player, Calc Xp and give it to each group member
 	Player *pHighLvlPlayer = NULL;
+	Player *pHighLvlPlayerNot70 = NULL;
 	Player *pGroupGuy = NULL;
 	  int active_player_count=0;
 	Player *active_player_list[MAX_GROUP_SIZE_RAID];//since group is small we can afford to do this ratehr then recheck again the whole active player set
@@ -444,13 +445,16 @@
 				active_player_list[active_player_count]=pGroupGuy;
 				active_player_count++;
 				total_level += pGroupGuy->getLevel();
-				if(pHighLvlPlayer)
-				{
-					if(pGroupGuy->getLevel() > pHighLvlPlayer->getLevel())
-						pHighLvlPlayer = pGroupGuy;
-				}
-				else 
-					pHighLvlPlayer = pGroupGuy;
+				if(pHighLvlPlayerNot70)
+ 				{
+					if(pGroupGuy->getLevel() < 70)
+					{
+						if (pGroupGuy->getLevel() > pHighLvlPlayerNot70->getLevel())
+							pHighLvlPlayerNot70 = pGroupGuy;
+					}
+ 				}
+				else if(pGroupGuy->getLevel() < 70)
+					pHighLvlPlayerNot70 = pGroupGuy;
 			}
 		}
 	}
@@ -475,12 +479,17 @@
 		}
 		else if(pGroup->GetGroupType() == GROUP_TYPE_RAID)
 			xp_mod=0.5f;
-		if(pHighLvlPlayer == 0) pHighLvlPlayer = pGroup->GetLeader();
+		if(pHighLvlPlayerNot70 == 0 || !pHighLvlPlayerNot70) pHighLvlPlayerNot70 = pGroup->GetLeader();
 
-		xp = CalculateXpToGive(pVictim, pHighLvlPlayer);
+		xp = CalculateXpToGive(pVictim, pHighLvlPlayerNot70);
 		//i'm not sure about this formula is correct or not. Maybe some brackets are wrong placed ?
 		for(int i=0;i<active_player_count;i++)
-			active_player_list[i]->GiveXP( float2int32(((xp*active_player_list[i]->getLevel()) / total_level)*xp_mod), pVictim->GetGUID(), true );
+		{
+			if (active_player_list[i]->getLevel() < 70)
+				active_player_list[i]->GiveXP( float2int32(((xp*active_player_list[i]->getLevel()) / total_level)*xp_mod), pVictim->GetGUID(), true );
+			else
+				active_player_list[i]->GiveXP( 0, pVictim->GetGUID(), true );
+		}
 	}
 		/* old code start before 2007 04 22
 		GroupMembersSet::iterator itr;
@@ -527,7 +536,6 @@
 	bool can_delete = !bProcInUse; //if this is a nested proc then we should have this set to TRUE by the father proc
 	bProcInUse = true; //locking the proc list
 
-	std::list<uint32> remove;
 	std::list<struct ProcTriggerSpell>::iterator itr,itr2;
 	for( itr = m_procSpells.begin();itr != m_procSpells.end();)  // Proc Trigger Spells for Victim
 	{
@@ -654,6 +662,20 @@
 				//these are player talents. Fuckem they pull the emu speed down 
 				if(IsPlayer())
 				{
+					if (itr2->ProcType == 1 && static_cast<Player*>(this)->IsInFeralForm()) 
+					{
+						switch (static_cast<Player*>(this)->GetShapeShift())
+						{
+							case FORM_CAT:	
+							case FORM_BEAR: 
+							case FORM_DIREBEAR:
+								continue;
+								break;
+							default:
+								break;
+						}
+					}
+
 					uint32 talentlevel=0;
 					switch(origId)
 					{
Index: game/WorldCreator.cpp
===================================================================
--- game/WorldCreator.cpp	(revision 2522)
+++ game/WorldCreator.cpp	(working copy)
@@ -48,7 +48,7 @@
 		m_InstanceHigh = 1;
 
 	// load each map we have in the database.
-	result = WorldDatabase.Query("SELECT DISTINCT Map FROM creature_spawns");
+	result = WorldDatabase.Query("SELECT DISTINCT map FROM creature_spawns");
 	if(result)
 	{
 		do 
Index: game/WorldSession.cpp
===================================================================
--- game/WorldSession.cpp	(revision 2522)
+++ game/WorldSession.cpp	(working copy)
@@ -255,9 +255,15 @@
 		}
 
 		if(_player->GetTeam() == 1)
-			sWorld.HordePlayers--;
-		else
-			sWorld.AlliancePlayers--;
+		{
+			if(sWorld.HordePlayers)
+				sWorld.HordePlayers--;
+		}
+ 		else
+		{
+			if(sWorld.AlliancePlayers)
+				sWorld.AlliancePlayers--;
+		}
 
 		if(_player->m_bg)
 			_player->m_bg->RemovePlayer(_player, true);
Index: realmserver/Structures.h
===================================================================
--- realmserver/Structures.h	(revision 2522)
+++ realmserver/Structures.h	(working copy)
@@ -143,7 +143,7 @@
 	uint32 ItemSet;
 	uint32 MaxDurability;
 	uint32 ZoneNameID;
-	uint32 Field114;
+	uint32 MapID;
 	uint32 BagFamily;
 	uint32 ToolCategory;
 	SocketInfo Sockets[3];
