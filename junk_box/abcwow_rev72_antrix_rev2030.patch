Index: ascent.conf
===================================================================
--- ascent.conf	(revision 2030)
+++ ascent.conf	(working copy)
@@ -125,6 +125,16 @@
 #        across channels.
 #        Default: 0
 #
+#    PvP Faction Limitation
+#        This directive controls whether you can create both Alliance and Horde chars in one account on a PvP server.
+#        If the limitation is "1", you can't. Set to "0" to be able to create both.
+#        Default: 1
+#
+#    Friend Faction Limitation
+#        This directive controls whether you can add friends from both Alliance and Horde.
+#        If the limitation is "1", you can't. Set to "0" to be able to add both.
+#        Default: 1
+#
 #    Compression Threshold
 #        This directive controls the limit when update packets will be compressed using deflate.
 #        For lower-bandwidth servers use a lower value at the cost of cpu time.
@@ -179,6 +189,8 @@
         LevelCap = "60"
         Expansion1LevelCap = "70"
         SeperateChatChannels = "0"
+		PvpFactionLimitation = "1"
+		FriendFactionLimitation = "1"
         CompressionThreshold = "1000"
         QueueUpdateInterval = "5000"
         KickAFKPlayers = "0"
Index: game/AIInterface.cpp
===================================================================
--- game/AIInterface.cpp	(revision 2030)
+++ game/AIInterface.cpp	(working copy)
@@ -67,6 +67,7 @@
 	UnitToFear = NULL;
 	firstLeaveCombat = true;
 	m_outOfCombatRange = 2500;
+	m_outOfComabtInstanceMod = 1;
 
 	tauntedBy = NULL;
 	isTaunted = false;
@@ -90,7 +91,7 @@
 	m_AIState_backup = m_AIState;
 	UnitToFollow_backup = NULL;
 	m_isGuard = false;
-//	m_fastMove = false;
+	castingspell = NULL;
 }
 
 void AIInterface::Init(Unit *un, AIType at, MovementType mt)
@@ -636,6 +637,8 @@
 	AssistTargetSet::iterator i;
 	TargetMap::iterator itr;
 
+	if(m_outOfComabtInstanceMod == 1 && m_Unit->GetMapMgr()->GetMapInfo() && m_Unit->GetMapMgr()->GetMapInfo()->type != INSTANCE_NULL) m_outOfComabtInstanceMod = 16;
+
 	// Find new Assist Targets and remove old ones
 	if(m_AIState == STATE_FLEEING)
 	{
@@ -654,7 +657,7 @@
 		//modified for vs2005 compatibility
 		for(i = m_assistTargets.begin(); i != m_assistTargets.end(); ++i)
 		{
-			if(m_Unit->GetDistanceSq((*i)) > 2500.0f/*50.0f*/ || !(*i)->isAlive() || !(*i)->CombatStatus.IsInCombat())
+			if(m_Unit->GetDistanceSq((*i)) > (2500.0f*m_outOfComabtInstanceMod) || !(*i)->isAlive() || !(*i)->CombatStatus.IsInCombat())
 			{
 				tokill.push_back(*i);
 			}
@@ -737,11 +740,13 @@
 
 	uint16 agent = m_aiCurrentAgent;
 
+	if(m_outOfComabtInstanceMod == 1 && m_Unit->GetMapMgr()->GetMapInfo() && m_Unit->GetMapMgr()->GetMapInfo()->type != INSTANCE_NULL) m_outOfComabtInstanceMod = 16;
+
 	// If creature is very far from spawn point return to spawnpoint
 	// If at instance dont return -- this is wrong ... instance creatures always returns to spawnpoint, dunno how do you got this ideia. 
 
 	if(	m_AIType != AITYPE_PET 
-		&& (m_outOfCombatRange && m_Unit->GetDistanceSq(m_returnX,m_returnY,m_returnZ) > m_outOfCombatRange) 
+		&& (m_outOfCombatRange && m_Unit->GetDistanceSq(m_returnX,m_returnY,m_returnZ) > (m_outOfCombatRange*m_outOfComabtInstanceMod)) 
 		&& m_AIState != STATE_EVADE
 		&& m_AIState != STATE_SCRIPTMOVE)
 	{
Index: game/AIInterface.h
===================================================================
--- game/AIInterface.h	(revision 2030)
+++ game/AIInterface.h	(working copy)
@@ -395,6 +395,7 @@
 	bool m_hasFleed;
 	bool m_hasCalledForHelp;
 	uint32 m_outOfCombatRange;
+	uint32 m_outOfComabtInstanceMod;
 
 	Unit *m_Unit;
 	Unit *m_PetOwner;
Index: game/AreaTrigger.cpp
===================================================================
--- game/AreaTrigger.cpp	(revision 2030)
+++ game/AreaTrigger.cpp	(working copy)
@@ -193,6 +193,29 @@
 					return;
 				}
 
+				if((GetPlayer()->iInstanceType == MODE_HEROIC) && pMapinfo && (pMapinfo->heroic_keyid_1 || pMapinfo->heroic_keyid_2) && (!_player->GetItemInterface()->GetItemCount(pMapinfo->heroic_keyid_1, false) && (!_player->GetItemInterface()->GetItemCount(pMapinfo->heroic_keyid_2, false)))) 
+				{
+					ItemPrototype *itemProto = ItemPrototypeStorage.LookupEntry(pMapinfo->heroic_keyid_1);
+					if(itemProto)
+					{
+						std::string outStr = "Heroic Difficulty requires the ";
+						outStr.append(itemProto->Name1);
+						outStr += ".";
+						WorldPacket msg(10 + outStr.length());
+						msg.Initialize(SMSG_AREA_TRIGGER_MESSAGE);
+						msg << uint32(0) << outStr ; 
+						SendPacket(&msg);
+					}
+					else
+					{
+						WorldPacket msg(68); 
+						msg.Initialize(SMSG_AREA_TRIGGER_MESSAGE); 
+						msg << uint32(0) << "You do not have the required attunement to enter this instance."; 
+						SendPacket(&msg);
+					}
+					return; 
+				} 
+
 				if(!GetPlayer()->isAlive())
 				{
 					pCorpse = objmgr.GetCorpseByOwner(GetPlayer()->GetGUIDLow());
Index: game/Arenas.cpp
===================================================================
--- game/Arenas.cpp	(revision 2030)
+++ game/Arenas.cpp	(working copy)
@@ -59,22 +59,31 @@
 {
 	/* cast arena readyness buff */
 	if(plr->isDead())
-	{
 		plr->ResurrectPlayer();
-		plr->SetUInt32Value(UNIT_FIELD_HEALTH, plr->GetUInt32Value(UNIT_FIELD_MAXHEALTH));
-		plr->SetUInt32Value(UNIT_FIELD_POWER1, plr->GetUInt32Value(UNIT_FIELD_MAXPOWER1));
-		plr->SetUInt32Value(UNIT_FIELD_POWER4, plr->GetUInt32Value(UNIT_FIELD_MAXPOWER4));
-		sEventMgr.AddEvent(plr, &Player::FullHPMP, EVENT_PLAYER_UPDATE, 500, 1, 0);
-	}
-	else
-	{
-		plr->SetUInt32Value(UNIT_FIELD_HEALTH, plr->GetUInt32Value(UNIT_FIELD_MAXHEALTH));
-		plr->SetUInt32Value(UNIT_FIELD_POWER1, plr->GetUInt32Value(UNIT_FIELD_MAXPOWER1));
-		plr->SetUInt32Value(UNIT_FIELD_POWER4, plr->GetUInt32Value(UNIT_FIELD_MAXPOWER4));
-		sEventMgr.AddEvent(plr, &Player::FullHPMP, EVENT_PLAYER_UPDATE, 500, 1, 0);
-	}
 
+	plr->SetUInt32Value(UNIT_FIELD_HEALTH, plr->GetUInt32Value(UNIT_FIELD_MAXHEALTH));
+	plr->SetUInt32Value(UNIT_FIELD_POWER1, plr->GetUInt32Value(UNIT_FIELD_MAXPOWER1));
+	plr->SetUInt32Value(UNIT_FIELD_POWER4, plr->GetUInt32Value(UNIT_FIELD_MAXPOWER4));
+	sEventMgr.AddEvent(plr, &Player::FullHPMP, EVENT_PLAYER_UPDATE, 500, 1, 0);
+
 	plr->m_deathVision = true;
+
+	for(uint32 x=0;x<MAX_AURAS;x++)
+    {
+        if(plr->m_auras[x])
+        {
+			if(plr->m_auras[x] && !plr->m_auras[x]->GetSpellProto()->DurationIndex && plr->m_auras[x]->GetSpellProto()->Flags4 & CAN_PERSIST_AND_CASTED_WHILE_DEAD)
+                continue;
+            else
+	        {
+		        plr->m_auras[x]->Remove();
+	        }
+        }
+    }
+
+	plr->GetItemInterface()->RemoveAllConjured();
+	plr->ResetAllCooldowns();
+
 	plr->CastSpell(plr, ARENA_PREPARATION, true);
 	UpdatePlayerCounts();
 
@@ -480,7 +489,7 @@
 
 void Player::FullHPMP()
 {
-	SetUInt32Value(UNIT_FIELD_HEALTH, m_uint32Values[UNIT_FIELD_MAXHEALTH]);
-	SetUInt32Value(UNIT_FIELD_POWER1, m_uint32Values[UNIT_FIELD_MAXPOWER1]);
-	SetUInt32Value(UNIT_FIELD_POWER4, m_uint32Values[UNIT_FIELD_MAXPOWER4]);
+	SetUInt32Value(UNIT_FIELD_HEALTH, GetUInt32Value(UNIT_FIELD_MAXHEALTH));
+	SetUInt32Value(UNIT_FIELD_POWER1, GetUInt32Value(UNIT_FIELD_MAXPOWER1));
+	SetUInt32Value(UNIT_FIELD_POWER4, GetUInt32Value(UNIT_FIELD_MAXPOWER4));
 }
Index: game/Arenas.h
===================================================================
--- game/Arenas.h	(revision 2030)
+++ game/Arenas.h	(working copy)
@@ -59,12 +59,13 @@
 
 	int32 GetFreeTeam()
 	{
+		if(m_started) return -1;
+
 		size_t c0 = m_players[0].size() + m_pendPlayers[0].size();
 		size_t c1 = m_players[1].size() + m_pendPlayers[1].size();
-		if(m_started) return -1;
 
 		// Check if there is free room, if yes, return team with less members
-		return ((c0 + c1 >= m_playerCountPerTeam * 2) ? -1 : (c0 > c1));
+		return ((c0 + c1 >= m_playerCountPerTeam * 2) ? -1 : ((c0 > c1)?1:0));
 
 		/* We shouldn't reach here. */
 	}
Index: game/BattlegroundMgr.cpp
===================================================================
--- game/BattlegroundMgr.cpp	(revision 2030)
+++ game/BattlegroundMgr.cpp	(working copy)
@@ -233,6 +233,7 @@
 						tempPlayerVec[0].pop_front();
 						arena->AddPlayer(plr, team);
 						ErasePlayerFromList(plr->GetGUIDLow(), &m_queuedPlayers[i][j]);
+						team = arena->GetFreeTeam();
 					}
 				}
 				else
@@ -359,15 +360,14 @@
 
 			Arena * ar = ((Arena*)CreateInstance(i,LEVEL_GROUP_70));
 			GroupMembersSet::iterator itx;
-			int32 team;
 			ar->rated_match=true;
 
 			for(itx = group1->GetSubGroup(0)->GetGroupMembersBegin(); itx != group1->GetSubGroup(0)->GetGroupMembersEnd(); ++itx)
 			{
 				if(itx->player)
 				{
-					if( (team = ar->GetFreeTeam()) != -1 )
-                        ar->AddPlayer(itx->player, team);
+					if(ar->HasFreeSlots(0))
+                        ar->AddPlayer(itx->player, 0);
 				}
 			}
 
@@ -375,8 +375,8 @@
 			{
 				if(itx->player)
 				{
-					if( (team = ar->GetFreeTeam()) != -1 )
-						ar->AddPlayer(itx->player, team);
+					if(ar->HasFreeSlots(1))
+						ar->AddPlayer(itx->player, 1);
 				}
 			}
 		}
@@ -657,6 +657,8 @@
 {
 	m_mainLock.Acquire();
 
+	plr->m_bgTeam = team;
+
 	/* This is called when the player is added, not when they port. So, they're essentially still queued, but not inside the bg yet */
 	m_pendPlayers[team].insert(plr->GetGUIDLow());
 
@@ -771,7 +773,7 @@
 	{
 		/* arenas follow a different procedure. */
 		static const uint32 arena_map_ids[3] = { 559, 562, 572 };
-		uint32 mapid = /*arena_map_ids[sRand.randInt(3)]*/562;
+		uint32 mapid = arena_map_ids[sRand.randInt(3)];
 		uint32 players_per_side;
         if(sWorldCreator.CreateInstance(mapid, 0, &mgr) == false || !mgr)
 		{
@@ -963,7 +965,7 @@
 			data << uint8(0xC);
 			data << uint32(6);
 			data << uint16(0x1F90);
-			data << uint32(11);
+			data << InstanceID;
 			data << uint8(RatedMatch);		// 1 = rated match
 		}
 		else
@@ -1401,4 +1403,4 @@
 bool CBattleground::CanPlayerJoin(Player * plr)
 {
 	return HasFreeSlots(plr->m_bgTeam);
-}
\ No newline at end of file
+}
Index: game/CharacterHandler.cpp
===================================================================
--- game/CharacterHandler.cpp	(revision 2030)
+++ game/CharacterHandler.cpp	(working copy)
@@ -26,6 +26,8 @@
 {
 	static const char * bannedCharacters = "\t\v\b\f\a\n\r\\\"\'\? <>[](){}_=+-|/!@#$%^&*~`.,0123456789\0";
 	const char * p;
+	if(stricmp(name, "Console") == 0)
+		return false;
 	for(size_t i = 0; i < nlen; ++i)
 	{
 		p = bannedCharacters;
@@ -73,6 +75,7 @@
 		uint64 guid;
 		uint8 Class;
 		uint32 bytes2;
+		uint32 flags;
 		Field *fields;
 		do
 		{
@@ -80,6 +83,7 @@
 			guid = fields[0].GetUInt32();
 			bytes2 = fields[6].GetUInt32();
 			Class = fields[3].GetUInt8();			
+			flags = fields[18].GetUInt32();
 
 			/* build character enum, w0000t :p */
 			data << fields[0].GetUInt64();		// guid
@@ -141,9 +145,12 @@
 					proto = ItemPrototypeStorage.LookupEntry(res->Fetch()[1].GetUInt32());
 					if(proto)
 					{
+						// slot0 = head, slot14 = cloak
 						slot = res->Fetch()[0].GetUInt32();
-						items[slot].displayid = proto->DisplayInfoID;
-						items[slot].invtype = proto->InventoryType;
+						if(!(slot == 0 && (flags & (uint32)PLAYER_FLAG_NOHELM) != 0) && !(slot == 14 && (flags & (uint32)PLAYER_FLAG_NOCLOAK) != 0)) {
+							items[slot].displayid = proto->DisplayInfoID;
+							items[slot].invtype = proto->InventoryType;
+						}
 					}
 				} while(res->NextRow());
 				delete res;
@@ -166,7 +173,7 @@
 void WorldSession::HandleCharEnumOpcode( WorldPacket & recv_data )
 {	
 	AsyncQuery * q = new AsyncQuery( new SQLClassCallbackP1<World, uint32>(World::getSingletonPtr(), &World::CharacterEnumProc, GetAccountId()) );
-	q->AddQuery("SELECT guid, level, race, class, gender, bytes, bytes2, guildid, name, positionX, positionY, positionZ, mapId, zoneId, banned, restState, deathstate, forced_rename_pending FROM characters WHERE acct=%u ORDER BY guid", GetAccountId());
+	q->AddQuery("SELECT guid, level, race, class, gender, bytes, bytes2, guildid, name, positionX, positionY, positionZ, mapId, zoneId, banned, restState, deathstate, forced_rename_pending, player_flags FROM characters WHERE acct=%u ORDER BY guid", GetAccountId());
 	CharacterDatabase.QueueAsyncQuery(q);
 }
 
@@ -259,7 +266,7 @@
 
 	//Same Faction limitation only applies to PVP and RPPVP realms :)
 	uint32 realmType = sLogonCommHandler.GetRealmType();
-	if(!HasGMPermissions() && (realmType==REALMTYPE_PVP||realmType==REALMTYPE_RPPVP))
+	if(!HasGMPermissions() && (realmType==REALMTYPE_PVP||realmType==REALMTYPE_RPPVP) && sWorld.PvpFactionLimitation)
 	{
 		if(
 			((pNewChar->GetTeam()== 0) && (_side == 2))||
Index: game/Chat.cpp
===================================================================
--- game/Chat.cpp	(revision 2030)
+++ game/Chat.cpp	(working copy)
@@ -533,6 +533,7 @@
 		{ "recall",		'q', NULL,									 "",				 recallCommandTable, 0, 0, 0},
 		{ "guild",		'm', NULL,									 "",				 GuildCommandTable, 0, 0, 0},
 		{ "getpos"	  ,  'd', &ChatHandler::HandleGetPosCommand,		"",							   NULL, 0, 0, 0},
+		{ "clearcooldowns", 'm', &ChatHandler::HandleClearCooldownsCommand, "Clears all cooldowns for your class.", NULL, 0, 0, 0 },
 		{ "removeauras",   'm', &ChatHandler::HandleRemoveAurasCommand,   "Removes all auras from target",  NULL, 0, 0, 0},
 		{ "paralyze",	  'b', &ChatHandler::HandleParalyzeCommand,	  "Roots/Paralyzes the target.",	NULL, 0, 0, 0 },
 		{ "unparalyze",	'b', &ChatHandler::HandleUnParalyzeCommand,	"Unroots/Unparalyzes the target.",NULL, 0, 0, 0 },
Index: game/Chat.h
===================================================================
--- game/Chat.h	(revision 2030)
+++ game/Chat.h	(working copy)
@@ -336,6 +336,7 @@
 	bool HandleMonsterSayCommand(const char* args, WorldSession *m_session);
 	bool HandleMonsterYellCommand(const char* args, WorldSession* m_session);
 	bool HandleNpcComeCommand(const char* args, WorldSession* m_session);
+	bool HandleClearCooldownsCommand(const char* args, WorldSession *m_session);
 	bool HandleBattlegroundCommand(const char* args, WorldSession *m_session);
 	bool HandleSetWorldStateCommand(const char* args, WorldSession *m_session);
 	bool HandlePlaySoundCommand(const char* args, WorldSession *m_session);
Index: game/Container.cpp
===================================================================
--- game/Container.cpp	(revision 2030)
+++ game/Container.cpp	(working copy)
@@ -299,7 +299,7 @@
 
 	for(uint32 i = 0; i < m_itemProto->ContainerSlots; i++)
 	{
-		if (m_Slot[i])
+		if (m_Slot[i] && !((m_Slot[i]->GetProto()->Flags)& 2) )
 		{
 			m_Slot[i]->SaveToDB(slot, i, first);
 		}
Index: game/Creature.cpp
===================================================================
--- game/Creature.cpp	(revision 2030)
+++ game/Creature.cpp	(working copy)
@@ -832,15 +832,15 @@
 		ModUInt32Value(UNIT_FIELD_LEVEL, info->lvl_mod_a);
 
 	for(uint32 i = 0; i < 7; ++i)
-		SetUInt32Value(UNIT_FIELD_RESISTANCES+i,proto->Resistances[i]);
+		SetUInt32Value(UNIT_FIELD_RESISTANCES+i,(mode ? proto->Resistances[i]*1.5  : proto->Resistances[i]));
 
 	SetUInt32Value(UNIT_FIELD_BASEATTACKTIME,proto->AttackTime);
 	SetFloatValue(UNIT_FIELD_MINDAMAGE, (mode ? proto->MinDamage * 1.5  : proto->MinDamage));
 	SetFloatValue(UNIT_FIELD_MAXDAMAGE, (mode ? proto->MaxDamage * 1.5  : proto->MaxDamage));
 
 	SetUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,proto->RangedAttackTime);
-	SetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE,proto->RangedMinDamage);
-	SetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE,proto->RangedMaxDamage);
+	SetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE,(mode ? proto->RangedMinDamage * 1.5  : proto->RangedMinDamage));
+	SetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE,(mode ? proto->RangedMaxDamage * 1.5  : proto->RangedMaxDamage));
 
 	SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY, proto->Item1SlotDisplay);
 	SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_DISPLAY_01, proto->Item2SlotDisplay);
Index: game/DayWatcherThread.cpp
===================================================================
--- game/DayWatcherThread.cpp	(revision 2030)
+++ game/DayWatcherThread.cpp	(working copy)
@@ -204,37 +204,39 @@
 						continue;		// no change
 					else if(X > 510.0 && X <= 1500.0)		// "if 510 < X <= 1500"
 					{
-						Y = (0.38 * X) - 194.0;
+						Y = (0.22 * X) + 14.0;
 					}
 					else			// "if X > 1500"
 					{
-						// how nice of wowwiki. they prevent a divide by zero for us.
-						//              1426.79
+						// http://eu.wowarmory.com/arena-calculator.xml
+						//              1511.26
 						//   ---------------------------
-						//                 -0.00386405X
-						//         1+918.836
+						//                   -0.00412*X
+						//    1+1639.28*2.71828
 
-						long double power = ((-0.00386405) * X);
+						long double power = ((-0.00412) * X);
 						//if(power < 1.0)
 						//	power = 1.0;
 
-						long double divisor = pow(((long double)(918.836)), power);						
+						long double divisor = pow(((long double)(2.71828)), power);						
+						divisor *= 1639.28;
 						divisor += 1.0;
 						//if(divisor < 1.0)
 						//	divisor = 1.0;
 
-						Y = 1426.79 / divisor;
+						Y = 1511.26 / divisor;
 					}
 
 					// 2v2 teams only earn 70% (Was 60% until 13th March 07) of the arena points, 3v3 teams get 80%, while 5v5 teams get 100% of the arena points.
+					// 2v2 - 76%, 3v3 - 88% as of patch 2.2
 					if(team->m_type == ARENA_TEAM_TYPE_2V2)
 					{
-						Y *= 0.70;
+						Y *= 0.76;
 						Y *= sWorld.getRate(RATE_ARENAPOINTMULTIPLIER2X);
 					}
 					else if(team->m_type == ARENA_TEAM_TYPE_3V3)
 					{
-						Y *= 0.80;
+						Y *= 0.88;
 						Y *= sWorld.getRate(RATE_ARENAPOINTMULTIPLIER3X);
 					}
 					else
@@ -335,3 +337,4 @@
 	m_dirty = true;
 }
 
+
Index: game/GameObject.cpp
===================================================================
--- game/GameObject.cpp	(revision 2030)
+++ game/GameObject.cpp	(working copy)
@@ -512,7 +512,7 @@
 	//Open loot on success, otherwise FISH_ESCAPED.
 	if(Rand(((player->_GetSkillLineCurrent(SKILL_FISHING,true)-minskill)*100)/maxskill))
 	{			  
-		lootmgr.FillProfessionLoot(&lootmgr.FishingLoot,&loot,zone);
+		lootmgr.FillFishingLoot(&loot,zone);
 		player->SendLoot(GetGUID(),3);
 		EndFishing(player, false);
 	}
Index: game/Group.cpp
===================================================================
--- game/Group.cpp	(revision 2030)
+++ game/Group.cpp	(working copy)
@@ -321,7 +321,7 @@
 						/*check the reciever id against all group members*/
 						if(itr2->player_info->guid == SoulStoneGiver) removeSoulStone = false;
 
-						data << itr2->player_info->name << itr2->player_info->guid;
+						data << itr2->player_info->name << itr2->player_info->guid << uint32(0);
 						if(itr2->player)
 							data << uint8(1);
 						else
Index: game/HonorHandler.cpp
===================================================================
--- game/HonorHandler.cpp	(revision 2030)
+++ game/HonorHandler.cpp	(working copy)
@@ -97,6 +97,8 @@
 		return;
     if(pVictim && pVictim->IsPlayer() && static_cast<Player*>(pVictim)->m_bgTeam == pPlayer->m_bgTeam)
         return;
+	if(pPlayer->GetTeam() == static_cast<Player*>(pVictim)->GetTeam())
+		return;
 
 	// Calculate points
 	int32 Points = CalculateHonorPointsForKill(pPlayer, pVictim);
@@ -182,7 +184,7 @@
 	// Why are we multiplying by 10.. ho well
 	pPlayer->SetUInt32Value(PLAYER_FIELD_KILLS, pPlayer->m_killsToday);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_TODAY_CONTRIBUTION, pPlayer->m_honorToday);
-	pPlayer->SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, pPlayer->m_killsYesterday | ( (pPlayer->m_honorYesterday * 10) << 16));
+	pPlayer->SetUInt32Value(PLAYER_FIELD_YESTERDAY_CONTRIBUTION, pPlayer->m_killsYesterday /*| ( (pPlayer->m_honorYesterday * 10) << 16)*/);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORBALE_KILLS, pPlayer->m_killsLifetime);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_HONOR_CURRENCY, pPlayer->m_honorPoints);
 	pPlayer->SetUInt32Value(PLAYER_FIELD_ARENA_CURRENCY, pPlayer->m_arenaPoints);
Index: game/Item.cpp
===================================================================
--- game/Item.cpp	(revision 2030)
+++ game/Item.cpp	(working copy)
@@ -677,16 +677,48 @@
 					TS.origId = 0;
 					TS.procFlags = PROC_ON_MELEE_ATTACK;
 					TS.procCharges = 0;
-					/* This needs to be modified based on the attack speed of the weapon.
-					 * Secondly, need to assign some static chance for instant attacks (ss,
-					 * gouge, etc.) */
-					if (!Entry->min[c] && GetProto()->Class == 2) {
-						uint32 speed = GetProto()->Delay;
-						TS.procChance = (uint32)((1.0*(float)speed)/600.0);
-					} else
+					if(!Entry->min[c])
+					{
+						//Crusader 20007
+						//Unholy Weapon 20006
+						//Lifestealing 20004
+						//Icy Weapon 20005
+						//Mongoose  28093
+						//Fiery Weapon 13897
+						float weapspeed = 1.0f;
+						if ((Entry->spell[c] >= 20004 && Entry->spell[c] <= 20007) || Entry->spell[c] == 28093 || Entry->spell[c] == 13897)
+						{
+							Item * itm = m_owner->GetItemInterface()->GetInventoryItem(EQUIPMENT_SLOT_MAINHAND);
+							if(itm)
+								weapspeed = itm->GetProto()->Delay / 1000;
+						}
+	
+						float base_proc = 5.0f;
+						switch(Entry->spell[c])
+						{
+							case 28093:
+							case 20007:
+								base_proc = 1.82f;
+							break;
+							case 13897:
+							case 20005:
+							case 20004:
+							case 20006:
+								base_proc = 7.87f;
+							break;
+							default: break;
+						}
+						
+						TS.procChance = (uint32)float(base_proc * weapspeed + 0.5);
+
+					}
+					else
+					{
 						TS.procChance = Entry->min[c];
-					Log.Debug("Enchant","Setting procChance to %u%%.", TS.procChance);
+					}
+
 					TS.deleted = false;
+					TS.from_weapon = (GetProto()->Class == ITEM_CLASS_WEAPON)? true : false;
 					TS.spellId = Entry->spell[c];
 					m_owner->m_procSpells.push_back(TS);
 				}
@@ -1046,7 +1078,7 @@
 	};
 
 	double value;
-	if(m_itemProto->Class == ITEM_CLASS_ARMOR && m_itemProto->Quality > ITEM_QUALITY_NORMAL_WHITE)
+	if(m_itemProto->Class == ITEM_CLASS_ARMOR && m_itemProto->Quality > ITEM_QUALITY_UNCOMMON_GREEN)
 		value = SuffixMods[m_itemProto->InventoryType] * 1.24;
 	else
 		value = SuffixMods[m_itemProto->InventoryType];
Index: game/ItemInterface.cpp
===================================================================
--- game/ItemInterface.cpp	(revision 2030)
+++ game/ItemInterface.cpp	(working copy)
@@ -962,7 +962,31 @@
 	return 0;
 }
 
+void ItemInterface::RemoveAllConjured()
+{
+	for(uint32 x = INVENTORY_SLOT_BAG_START; x < INVENTORY_SLOT_ITEM_END; ++x)
+	{
+		if (m_pItems[x]!= NULL)
+		{
+			if(IsBagSlot(x) && m_pItems[x]->IsContainer())
+			{
+				Container * bag = (Container*)m_pItems[x];
 
+				for(uint32 i = 0; i < bag->GetProto()->ContainerSlots; i++)
+				{
+					if (bag->GetItem(i) != NULL && bag->GetItem(i)->GetProto() && (bag->GetItem(i)->GetProto()->Flags)& 2)
+						bag->SafeFullRemoveItemFromSlot(i);
+				}
+			}
+			else
+			{
+				if(m_pItems[x]->GetProto() && (m_pItems[x]->GetProto()->Flags)& 2 )
+					SafeFullRemoveItemFromSlot(INVENTORY_SLOT_NOT_SET, x);
+			}
+		}
+	}
+}
+
 //-------------------------------------------------------------------//
 //Description: Gets slot number by itemid, banks not included
 //-------------------------------------------------------------------//
@@ -1232,7 +1256,13 @@
 
 	if((slot < INVENTORY_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET) || (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END && DstInvSlot == INVENTORY_SLOT_NOT_SET))
 	{
-		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat())
+		if (!ignore_combat && m_pOwner->CombatStatus.IsInCombat()
+			&& proto->InventoryType != INVTYPE_WEAPON && proto->InventoryType != INVTYPE_WEAPONMAINHAND
+			&& proto->InventoryType != INVTYPE_RANGED && proto->InventoryType != INVTYPE_WEAPONOFFHAND
+			&& proto->InventoryType != INVTYPE_SHIELD && proto->InventoryType != INVTYPE_2HWEAPON
+			&& proto->InventoryType != INVTYPE_AMMO && proto->InventoryType != INVTYPE_THROWN
+			&& proto->InventoryType != INVTYPE_RANGEDRIGHT
+			)
 			return INV_ERR_CANT_DO_IN_COMBAT;
 
 		// Check to see if we have the correct race
Index: game/ItemInterface.h
===================================================================
--- game/ItemInterface.h	(revision 2030)
+++ game/ItemInterface.h	(working copy)
@@ -76,7 +76,9 @@
 	Item* FindItemLessMax(uint32 itemid, uint32 cnt, bool IncBank);
 	uint32 GetItemCount(uint32 itemid, bool IncBank = false);
 	uint32 RemoveItemAmt(uint32 id, uint32 amt);
+	void RemoveAllConjured();
 	void BuyItem(ItemPrototype *item, uint32 amt);
+	
 
 	uint32 CalculateFreeSlots(ItemPrototype *proto);
 	void ReduceItemDurability();
Index: game/Level3.cpp
===================================================================
--- game/Level3.cpp	(revision 2030)
+++ game/Level3.cpp	(working copy)
@@ -274,6 +274,93 @@
 	return true;	
 }
 
+bool ChatHandler::HandleClearCooldownsCommand(const char *args, WorldSession *m_session)
+{
+	uint64 guid = m_session->GetPlayer()->GetSelection();
+	Player *plr = getSelectedChar(m_session, true);
+	
+	if(!plr)
+	{
+		plr = m_session->GetPlayer();
+		SystemMessage(m_session, "Auto-targeting self.");
+	}
+	if(!plr) return false;
+
+	if(plr->getClass()==WARRIOR)
+	{
+		plr->ClearCooldownsOnLine(26, guid);
+		plr->ClearCooldownsOnLine(256, guid);
+		plr->ClearCooldownsOnLine(257 , guid);
+		BlueSystemMessage(m_session, "Cleared all Warrior cooldowns.");
+		return true;
+	}
+	if(plr->getClass()==PALADIN)
+	{
+		plr->ClearCooldownsOnLine(594, guid);
+		plr->ClearCooldownsOnLine(267, guid);
+		plr->ClearCooldownsOnLine(184, guid);
+		BlueSystemMessage(m_session, "Cleared all Paladin cooldowns.");
+		return true;
+	}
+	if(plr->getClass()==HUNTER)
+	{
+		plr->ClearCooldownsOnLine(50, guid);
+		plr->ClearCooldownsOnLine(51, guid);
+		plr->ClearCooldownsOnLine(163, guid);
+		BlueSystemMessage(m_session, "Cleared all Hunter cooldowns.");
+		return true;
+	}
+	if(plr->getClass()==ROGUE)
+	{
+		plr->ClearCooldownsOnLine(253, guid);
+		plr->ClearCooldownsOnLine(38, guid);
+		plr->ClearCooldownsOnLine(39, guid);
+		BlueSystemMessage(m_session, "Cleared all Rogue cooldowns.");
+		return true;
+	}
+	if(plr->getClass()==PRIEST)
+	{
+		plr->ClearCooldownsOnLine(56, guid);
+		plr->ClearCooldownsOnLine(78, guid);
+		plr->ClearCooldownsOnLine(613, guid);
+		BlueSystemMessage(m_session, "Cleared all Priest cooldowns.");
+		return true;
+	}
+	if(plr->getClass()==SHAMAN)
+	{
+		plr->ClearCooldownsOnLine(373, guid);
+		plr->ClearCooldownsOnLine(374, guid);
+		plr->ClearCooldownsOnLine(375, guid);
+		BlueSystemMessage(m_session, "Cleared all Shaman cooldowns.");
+		return true;
+	}
+	if(plr->getClass()==MAGE)
+	{
+		plr->ClearCooldownsOnLine(6, guid);
+		plr->ClearCooldownsOnLine(8, guid);
+		plr->ClearCooldownsOnLine(237, guid);
+		BlueSystemMessage(m_session, "Cleared all Mage cooldowns.");
+		return true;
+	}
+	if(plr->getClass()==WARLOCK)
+	{
+		plr->ClearCooldownsOnLine(355, guid);
+		plr->ClearCooldownsOnLine(354, guid);
+		plr->ClearCooldownsOnLine(593, guid);
+		BlueSystemMessage(m_session, "Cleared all Warlock cooldowns.");
+		return true;
+	}
+	if(plr->getClass()==DRUID)
+	{
+		plr->ClearCooldownsOnLine(573, guid);
+		plr->ClearCooldownsOnLine(574, guid);
+		plr->ClearCooldownsOnLine(134, guid);
+		BlueSystemMessage(m_session, "Cleared all Druid cooldowns.");
+		return true;
+	}
+	return true;
+}
+
 bool ChatHandler::HandleLearnCommand(const char* args, WorldSession *m_session)
 {
 	if (!*args)
@@ -3090,7 +3177,6 @@
 	return true;
 }
 
-
 bool ChatHandler::HandleCreateArenaTeamCommands(const char * args, WorldSession * m_session)
 {
 	uint32 arena_team_type;
Index: game/LogonCommClient.cpp
===================================================================
--- game/LogonCommClient.cpp	(revision 2030)
+++ game/LogonCommClient.cpp	(working copy)
@@ -332,7 +332,7 @@
 
 		uncompressed.clear();
 	}	
-	sLog.outString("Took %u msec to build character mapping list for realm %u", getMSTime() - t, realm_id);
+	sLog.outColor(TGREEN, "\n        >> Took %u msec to build character mapping list for realm %u", (getMSTime() - t), realm_id);
 }
 
 void LogonCommClientSocket::CompressAndSend(ByteBuffer & uncompressed)
Index: game/LootMgr.cpp
===================================================================
--- game/LootMgr.cpp	(revision 2030)
+++ game/LootMgr.cpp	(working copy)
@@ -265,6 +265,7 @@
 			t.chance_2 = fields[4].GetFloat();
 			t.mincount = fields[5].GetUInt32();
 			t.maxcount = fields[6].GetUInt32();
+			t.ffa_loot = fields[7].GetUInt32();
 		}
 		else
 		{
@@ -330,6 +331,7 @@
 					list.items[ind].chance2 = itr2->chance_2;
 					list.items[ind].mincount = itr2->mincount;
 					list.items[ind].maxcount = itr2->maxcount;
+					list.items[ind].ffa_loot = itr2->ffa_loot;
 
 					if(LootTable == &GOLoot)
 					{
@@ -395,6 +397,8 @@
 			itm.iItemsCount = count;
 			itm.roll = NULL;
 			itm.passed = false;
+			itm.ffa_loot = list->items[x].ffa_loot;
+			itm.has_looted.clear();
 			
 			if (itemproto->Quality > 1 && itemproto->ContainerSlots==0)
 			{
@@ -435,6 +439,26 @@
 	else PushLoot(&tab->second,loot, heroic);
 }
 
+void LootMgr::FillFishingLoot(Loot * loot,uint32 loot_id)
+{
+	loot->items.clear();
+	loot->gold = 0;
+
+	LootStore::iterator tab = FishingLoot.find(loot_id);
+	if( FishingLoot.end() == tab) return;
+	else PushLoot(&tab->second, loot, false);
+}
+
+void LootMgr::FillSkinningLoot(Loot * loot,uint32 loot_id)
+{
+	loot->items.clear();
+	loot->gold = 0;
+
+	LootStore::iterator tab = SkinningLoot.find(loot_id);
+	if( SkinningLoot.end() == tab)return;
+	else PushLoot(&tab->second, loot, false);
+}
+
 void LootMgr::FillPickpocketingLoot(Loot * loot,uint32 loot_id)
 {
  loot->items.clear ();
@@ -445,54 +469,6 @@
  else PushLoot(&tab->second,loot,false);
 }
 
-//Puts 1 item always, no random properties
-void LootMgr::FillProfessionLoot(LootStore * store,Loot * loot,uint32 loot_id)
-{
-	loot->items.clear ();
-	loot->gold =0;
-	
-	LootStore::iterator tab =store->find(loot_id);
-	if( store->end()==tab)return;
-	StoreLootList *list=&(tab->second);
-	
-	// TODO: fix infinite loop with ' while(true) '
-	while(true)
-	for(uint32 x =0,pass=0; x<list->count; x++,pass++)
-	{
-		if(list->items[x].item.itemproto)// this check is needed until loot DB is fixed
-		{
-//			ItemPrototype *itemproto = ItemPrototypeStorage.LookupEntry(list->items[x].item.itemid);
-			if(Rand(list->items[x].chance))// || itemproto->Class == ITEM_CLASS_QUEST)
-			{
-				__LootItem itm;
-				itm.item =list->items[x].item;
-				itm.iItemsCount=1;
-				itm.passed = false;
-				itm.roll = 0;
-				/*if(itemproto->MaxCount>1)
-				{
-					uint32 c=1 + sRand.randInt(itemproto->MaxCount);
-					if(Rand(float(100.0/c)))
-						itm.iItemsCount=c;
-				
-				}*/
-				
-				itm.iRandomProperty=NULL;
-				itm.iRandomSuffix=NULL;
-			  
-				loot->items.push_back(itm);
-				return;
-			}	
-		}
-		
-		if(pass>100)
-		{
-			sLog.outError("WARNING: Loot %u has too low chances",loot_id);
-			return;		
-		}
-	}	
-}
-
 bool LootMgr::CanGODrop(uint32 LootId,uint32 itemid)
 {
 	LootStore::iterator tab =GOLoot.find(LootId);
@@ -564,55 +540,28 @@
 
 	WorldPacket data(34);
 
-	/* grab any player */
-	Player * gplr = NULL;
 	for(std::map<uint64, uint32>::iterator itr = NeedRolls.begin(); itr != NeedRolls.end(); ++itr)
 	{
-		gplr = _mgr->GetPlayer((uint32)itr->first);
-		if(gplr) break;
-	}
-	
-	if(!gplr)
-	{
-		for(std::map<uint64, uint32>::iterator itr = GreedRolls.begin(); itr != GreedRolls.end(); ++itr)
-		{
-			gplr = _mgr->GetPlayer((uint32)itr->first);
-			if(gplr) break;
-		}
-	}
-
-	for(std::map<uint64, uint32>::iterator itr = NeedRolls.begin(); itr != NeedRolls.end(); ++itr)
-	{
 		if(itr->second > highest)
 		{
 			highest = itr->second;
 			player = itr->first;
 			hightype = NEED;
 		}
-
-		data.Initialize(SMSG_LOOT_ROLL);
-		data << _guid << _slotid << itr->first;
-		data << _itemid << _itemunk1 << _itemunk2;
-		data << uint8(itr->second) << uint8(NEED);
-		if(gplr && gplr->GetGroup())
-			gplr->GetGroup()->SendPacketToAll(&data);
 	}
 
-	for(std::map<uint64, uint32>::iterator itr = GreedRolls.begin(); itr != GreedRolls.end(); ++itr)
+	if(!highest)
 	{
-		if(!highest && itr->second > highest)
+		for(std::map<uint64, uint32>::iterator itr = GreedRolls.begin(); itr != GreedRolls.end(); ++itr)
 		{
-			highest = itr->second;
-			player = itr->first;
-			hightype = GREED;
-		}
+			if(itr->second > highest)
+			{
+				highest = itr->second;
+				player = itr->first;
+				hightype = GREED;
+			}
 
-		data.Initialize(SMSG_LOOT_ROLL);
-		data << _guid << _slotid << itr->first;
-		data << _itemid << _itemunk1 << _itemunk2;
-		data << uint8(itr->second) << uint8(GREED);
-		if(gplr && gplr->GetGroup())
-			gplr->GetGroup()->SendPacketToAll(&data);
+		}
 	}
 
 	Loot * pLoot = 0;
@@ -752,14 +701,6 @@
 	if(NeedRolls.find(player->GetGUID()) != NeedRolls.end() || GreedRolls.find(player->GetGUID()) != GreedRolls.end())
 		return; // dont allow cheaters
 
-	std::map<uint64, uint32>* rmap = 0;
-	
-	if(choice == NEED) {
-		rmap = &NeedRolls;
-	} else if(choice == GREED) {
-		rmap = &GreedRolls;
-	}
-
 	int roll = sRand.randInt(99)+1;
 	// create packet
 	WorldPacket data(34);
@@ -767,14 +708,15 @@
 	data << _guid << _slotid << player->GetGUID();
 	data << _itemid << _itemunk1 << _itemunk2;
 
-	if(rmap)
+	if(choice == NEED) {
+		NeedRolls.insert( std::make_pair(player->GetGUID(), roll) );
+		data << uint8(roll) << uint8(NEED);
+	} 
+	else if(choice == GREED)
 	{
-		rmap->insert ( std::make_pair(player->GetGUID(), roll) );
-		if(choice == GREED)
-			data << uint8(0xF9) << uint8(0x00);
-		else
-			data << uint8(0xC1) << uint8(0x00);
-	}
+		GreedRolls.insert( std::make_pair(player->GetGUID(), roll) );
+		data << uint8(roll) << uint8(GREED);
+	} 
 	else
 	{
 		if(!_passedGuid)
@@ -782,8 +724,6 @@
 
 		data << uint8(128) << uint8(128);
 	}
-
-	data << uint8(roll) << uint8(choice);
 	
 	if(player->InGroup())
 		player->GetGroup()->SendPacketToAll(&data);
Index: game/LootMgr.h
===================================================================
--- game/LootMgr.h	(revision 2030)
+++ game/LootMgr.h	(working copy)
@@ -55,6 +55,8 @@
 	uint32 displayid;
 }_LootItem;
 
+typedef std::set<uint64> LooterSet;
+
 typedef struct
 {
 	_LootItem item;
@@ -63,6 +65,8 @@
 	ItemRandomSuffixEntry * iRandomSuffix;
 	LootRoll *roll;
 	bool passed;
+	LooterSet has_looted;
+	uint32 ffa_loot;
 }__LootItem;
 
 
@@ -73,6 +77,7 @@
 	float chance2;
 	uint32 mincount;
 	uint32 maxcount;
+	uint32 ffa_loot;
 }StoreLootItem;
 
 
@@ -82,8 +87,6 @@
 	StoreLootItem*items;
 }StoreLootList;
 
-typedef std::set<uint64> LooterSet;
-
 typedef struct
 {
 	std::vector<__LootItem> items;
@@ -98,6 +101,7 @@
 	float chance_2;
 	uint32 mincount;
 	uint32 maxcount;
+	uint32 ffa_loot;
 };
 
 
@@ -120,10 +124,11 @@
 	LootMgr();
 	~LootMgr();
 
-	void FillProfessionLoot(LootStore * store,Loot * loot,uint32 loot_id);
 	void FillCreatureLoot(Loot * loot,uint32 loot_id, bool heroic);
 	void FillGOLoot(Loot * loot,uint32 loot_id, bool heroic);
 	void FillItemLoot(Loot *loot, uint32 loot_id);
+	void FillFishingLoot(Loot * loot,uint32 loot_id);
+	void FillSkinningLoot(Loot * loot,uint32 loot_id);
 	void FillPickpocketingLoot(Loot *loot, uint32 loot_id);
 
 	bool CanGODrop(uint32 LootId,uint32 itemid);
Index: game/MiscHandler.cpp
===================================================================
--- game/MiscHandler.cpp	(revision 2030)
+++ game/MiscHandler.cpp	(working copy)
@@ -74,11 +74,26 @@
 
 	amt = pLoot->items.at(lootSlot).iItemsCount;
 
-	if (!amt)//Test for party loot
-	{  
-		GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
-		return;
-	} 
+	if (!pLoot->items.at(lootSlot).ffa_loot)
+	{
+		if (!amt)//Test for party loot
+		{  
+			GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
+			return;
+		}
+	}
+	else
+	{
+		//make sure this player can still loot it in case of ffa_loot
+		LooterSet::iterator itr = pLoot->items.at(lootSlot).has_looted.find(_player->GetGUID());
+
+		if (pLoot->items.at(lootSlot).has_looted.end() != itr)
+		{
+			GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
+			return;
+		}
+	}
+
 	itemid = pLoot->items.at(lootSlot).item.itemproto->ItemId;
 	ItemPrototype* it = pLoot->items.at(lootSlot).item.itemproto;
 
@@ -131,16 +146,29 @@
 		sQuestMgr.OnPlayerItemPickup(GetPlayer(),add);
 	}
 
-	pLoot->items.at(lootSlot).iItemsCount=0;
-	// this gets sent to all looters
-	WorldPacket data(1);
-	data.SetOpcode(SMSG_LOOT_REMOVED);
-	data << lootSlot;
-	Player * plr;
-	for(LooterSet::iterator itr = pLoot->looters.begin(); itr != pLoot->looters.end(); ++itr)
-	{
-		if((plr = _player->GetMapMgr()->GetPlayer(*itr)))
-			plr->GetSession()->SendPacket(&data);
+	//in case of ffa_loot update only the player who recives it.
+	if (!pLoot->items.at(lootSlot).ffa_loot)
+ 	{
+		pLoot->items.at(lootSlot).iItemsCount = 0;
+	
+		// this gets sent to all looters
+		WorldPacket data(1);
+		data.SetOpcode(SMSG_LOOT_REMOVED);
+		data << lootSlot;
+		Player * plr;
+		for(LooterSet::iterator itr = pLoot->looters.begin(); itr != pLoot->looters.end(); ++itr)
+		{
+			if((plr = _player->GetMapMgr()->GetPlayer(*itr)))
+				plr->GetSession()->SendPacket(&data);
+		}
+ 	}
+	else
+ 	{
+		pLoot->items.at(lootSlot).has_looted.insert(_player->GetGUID());
+		WorldPacket data(1);
+		data.SetOpcode(SMSG_LOOT_REMOVED);
+		data << lootSlot;
+		_player->GetSession()->SendPacket(&data);
 	}
 
     WorldPacket idata(45);
@@ -1605,11 +1633,26 @@
 
 	amt = pLoot->items.at(slotid).iItemsCount;
 
-	if (!amt)//Test for party loot
-	{  
-		GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
-		return;
-	} 
+	if (!pLoot->items.at(slotid).ffa_loot)
+	{
+		if (!amt)//Test for party loot
+		{  
+			GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
+			return;
+		} 
+	}
+	else
+	{
+		//make sure this player can still loot it in case of ffa_loot
+		LooterSet::iterator itr = pLoot->items.at(slotid).has_looted.find(player->GetGUID());
+
+		if (pLoot->items.at(slotid).has_looted.end() != itr)
+		{
+			GetPlayer()->GetItemInterface()->BuildInventoryChangeError(NULL, NULL,INV_ERR_ALREADY_LOOTED);
+			return;
+		}
+	}
+
 	itemid = pLoot->items.at(slotid).item.itemproto->ItemId;
 	ItemPrototype* it = pLoot->items.at(slotid).item.itemproto;
 
@@ -1648,19 +1691,26 @@
 	
 	sQuestMgr.OnPlayerItemPickup(player,item);
 
-	pLoot->items.at(slotid).iItemsCount=0;
+	if (!pLoot->items.at(slotid).ffa_loot)
+ 	{
+		pLoot->items.at(slotid).iItemsCount=0;
+ 
+		// this gets sent to all looters
+		WorldPacket data(1);
+		data.SetOpcode(SMSG_LOOT_REMOVED);
+		data << slotid;
+		Player * plr;
+		for(LooterSet::iterator itr = pLoot->looters.begin(); itr != pLoot->looters.end(); ++itr)
+		{
+			if((plr = _player->GetMapMgr()->GetPlayer(*itr)))
+				plr->GetSession()->SendPacket(&data);
+		}
+ 	}
+	else
+ 	{
+		pLoot->items.at(slotid).has_looted.insert(player->GetGUID());
+ 	}
 
-	// this gets sent to all looters
-	WorldPacket data(1);
-	data.SetOpcode(SMSG_LOOT_REMOVED);
-	data << slotid;
-	Player * plr;
-	for(LooterSet::iterator itr = pLoot->looters.begin(); itr != pLoot->looters.end(); ++itr)
-	{
-		if((plr = _player->GetMapMgr()->GetPlayer(*itr)))
-			plr->GetSession()->SendPacket(&data);
-	}
-
     WorldPacket idata(45);
     if(it->Class == ITEM_CLASS_QUEST)
     {
Index: game/MovementHandler.cpp
===================================================================
--- game/MovementHandler.cpp	(revision 2030)
+++ game/MovementHandler.cpp	(working copy)
@@ -97,8 +97,11 @@
 
 		if(GetPlayer()->GetSummon() != NULL)		// move pet too
 			GetPlayer()->GetSummon()->SetPosition((GetPlayer()->GetPositionX() + 2), (GetPlayer()->GetPositionY() + 2), GetPlayer()->GetPositionZ(), float(M_PI));
-		_player->m_position = _player->m_sentTeleportPosition;
-		_player->m_sentTeleportPosition.ChangeCoords(999999.0f,999999.0f,999999.0f);
+		if(_player->m_sentTeleportPosition.x != 999999.0f)
+		{
+			_player->m_position = _player->m_sentTeleportPosition;
+			_player->m_sentTeleportPosition.ChangeCoords(999999.0f,999999.0f,999999.0f);
+		}
 	}
 
 }
Index: game/Object.cpp
===================================================================
--- game/Object.cpp	(revision 2030)
+++ game/Object.cpp	(working copy)
@@ -2098,6 +2098,7 @@
 		Unit* caster = (Unit*)(this);
 		caster->RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_START_ATTACK);
 		int32 plus_damage = 0;
+		int32 plus_damage_victim = 0;
 		
 		if(caster->IsPlayer())
 		{
@@ -2106,10 +2107,10 @@
 		}
 //------------------------------by school---------------------------------------------------
 		plus_damage += caster->GetDamageDoneMod(school);
-		plus_damage += pVictim->DamageTakenMod[school];
+		plus_damage_victim += pVictim->DamageTakenMod[school];
 //------------------------------by victim type----------------------------------------------
 		if(((Creature*)pVictim)->GetCreatureName() && caster->IsPlayer()&& !pVictim->IsPlayer())
-			plus_damage += static_cast<Player*>(caster)->IncreaseDamageByType[((Creature*)pVictim)->GetCreatureName()->Type];
+			plus_damage_victim += static_cast<Player*>(caster)->IncreaseDamageByType[((Creature*)pVictim)->GetCreatureName()->Type];
 //==========================================================================================
 //==============================+Spell Damage Bonus Modifications===========================
 //==========================================================================================
@@ -2130,6 +2131,7 @@
 		if (spellInfo->NameHash == 0x695C4940 || spellInfo->NameHash == 0x3DD5C872 || spellInfo->NameHash == 0xddaf1ac7 || spellInfo->NameHash == 0xCB75E5D1)
 			dmgdoneaffectperc *= float (1.0f - (( td / 15000.0f ) / (( td / 15000.0f ) + dmgdoneaffectperc)));
 
+		float dmgdonepercdownrank = 1.0f;
 		if(spellInfo->baseLevel > 0 && spellInfo->maxLevel > 0)
 		{
 		   float downrank1 = 1.0f;
@@ -2138,12 +2140,20 @@
 		   float downrank2 = ( float(spellInfo->maxLevel + 5.0f) / float(static_cast<Player*>(this)->getLevel()) );
 		   if (downrank2 >= 1 || downrank2 < 0)
 		         downrank2 = 1.0f;
-			dmgdoneaffectperc *= downrank1 * downrank2;
+			dmgdonepercdownrank *= downrank1 * downrank2;
 		}
 //==========================================================================================
 //==============================Bonus Adding To Main Damage=================================
 //==========================================================================================
-		int32 bonus_damage = float2int32(plus_damage * dmgdoneaffectperc);
+		int32 bonus_damage = 0;
+		if(spellInfo->dmg_bonus)
+		{
+			bonus_damage = (int32)((plus_damage * spellInfo->dmg_bonus * dmgdonepercdownrank)/100);
+			bonus_damage += (int32)(plus_damage_victim * dmgdonepercdownrank);
+		}
+		else
+			bonus_damage = float2int32((plus_damage + plus_damage_victim) * dmgdoneaffectperc * dmgdonepercdownrank);
+
 		bonus_damage +=pVictim->DamageTakenMod[school];
 		if(spellInfo->SpellGroupType)
 		{
@@ -2260,14 +2270,10 @@
 	
 	if(this->IsUnit() && allowProc && spellInfo->Id != 25501)
 	{
+		static_cast<Unit*>(this)->HandleProc(aproc,pVictim,spellInfo, float2int32(res));
+		static_cast<Unit*>(this)->m_procCounter = 0;
 		pVictim->HandleProc(vproc,(Unit*)this,spellInfo, float2int32(res));
 		pVictim->m_procCounter = 0;
-
-		static_cast<Unit*>(this)->HandleProc(PROC_ON_CAST_SPECIFIC_SPELL | PROC_ON_CAST_SPELL,static_cast<Player*>(this), spellInfo);
-		static_cast<Unit*>(this)->m_procCounter = 0;
-
-		static_cast<Unit*>(this)->HandleProc(aproc,pVictim,spellInfo, float2int32(res));
-		static_cast<Unit*>(this)->m_procCounter = 0;
 	}
 	
 	DealDamage(pVictim, float2int32(res),  2, 0, spellID);
Index: game/ObjectMgr.cpp
===================================================================
--- game/ObjectMgr.cpp	(revision 2030)
+++ game/ObjectMgr.cpp	(working copy)
@@ -1817,6 +1817,32 @@
 	} while(result->NextRow());
 	delete result;
 	Log.Notice("ObjectMgr", "%u spell fixes loaded.", fixed_count);
+
+/*##########################################################################################*/
+
+	// Loads data from spell_data_extra table
+	QueryResult * result1 = WorldDatabase.Query("SELECT * FROM spell_data_extra");
+	if(result1 == 0) return;
+
+	uint32 override_count = 0;
+	do
+	{
+		Field * fields1 = result1->Fetch();
+		uint32 spell_id = fields1[0].GetUInt32();
+		SpellEntry * sp = dbcSpell.LookupEntry(spell_id);
+		if(sp == 0) 
+			continue;
+
+		if(sp->dmg_bonus == 0)
+		{
+			sp->dmg_bonus = fields1[1].GetUInt32();
+			override_count++;
+		}
+
+	} while (result1->NextRow());
+
+	delete result1;
+	Log.Notice("ObjectMgr", "%u spell data extra loaded.", override_count);
 }
 
 void ObjectMgr::LoadSpellOverride()
@@ -2441,9 +2467,19 @@
 			replimit = i->mob_rep_reward;
 		}
 
-		if(!value || (replimit && pPlayer->GetStanding(i->faction[team]) >= replimit))
+		if(!value)
 			continue;
 
+		if (pPlayer->iInstanceType != MODE_HEROIC)
+			if(replimit && pPlayer->GetStanding(i->faction[team]) >= replimit)
+				continue;
+
+		/*
+		Standing rank = pPlayer->GetReputationRankFromStanding(pPlayer->GetStanding(((Creature*)pVictim)->m_factionDBC->ID));
+		if(STANDING_EXALTED <= rank || STANDING_HATED >= rank)
+			continue;
+*/
+
 		//value *= sWorld.getRate(RATE_KILLREPUTATION);
 		value = float2int32(float(value) * sWorld.getRate(RATE_KILLREPUTATION));
 		pPlayer->ModStanding(i->faction[team], value);
Index: game/ObjectStorage.cpp
===================================================================
--- game/ObjectStorage.cpp	(revision 2030)
+++ game/ObjectStorage.cpp	(working copy)
@@ -34,7 +34,7 @@
 const char * gTeleportCoordFormat						= "uxufffx";
 const char * gPvPAreaFormat								= "ush";
 const char * gFishingFormat								= "uuu";
-const char * gWorldMapInfoFormat						= "uuuuufffusuuuuu";
+const char * gWorldMapInfoFormat						= "uuuuufffusuuuuuuu";
 const char * gZoneGuardsFormat							= "uuu";
 
 /** SQLStorage symbols
Index: game/Player.cpp
===================================================================
--- game/Player.cpp	(revision 2030)
+++ game/Player.cpp	(working copy)
@@ -352,7 +352,8 @@
 	m_ModInterrMRegenPCT = 0;
 	m_RegenManaOnSpellResist=0;
 	m_rap_mod_pct = 0;
-	m_modblockvalue = 0;
+	m_modblockabsorbvalue = 0;
+	m_modblockvaluefromspells = 0;
 	m_summoner = m_summonInstanceId = m_summonMapId = 0;
 	m_lastMoveType = 0;
 	m_tempSummon = 0;
@@ -3342,6 +3343,7 @@
 				ts.caster=this->GetGUID();
 				ts.procFlags=PROC_ON_MELEE_ATTACK;
 				ts.deleted = false;
+				ts.from_weapon = (item->GetProto()->Class == ITEM_CLASS_WEAPON)? true : false;
 				this->m_procSpells.push_front(ts);			
 			}
 		}
@@ -4075,7 +4077,7 @@
 	}
 	else
 		tmp = 0.0f;
-	SetFloatValue(PLAYER_BLOCK_PERCENTAGE,min(tmp,95.0));
+	SetFloatValue(PLAYER_BLOCK_PERCENTAGE,min(tmp,75.0));
 
 	tmp = 5.0f + this->GetParryFromSpell();
 	tmp+=CalcRating(3);
@@ -4855,6 +4857,10 @@
 		if (iter->iItemsCount == 0)
 			continue;
 
+		LooterSet::iterator itr = iter->has_looted.find(GetGUID());
+		if (iter->has_looted.end() != itr)
+			continue;
+
 		ItemPrototype* itemProto =iter->item.itemproto;
 		if (!itemProto)		   
 			continue;
@@ -4927,6 +4933,10 @@
 			/* if all people passed anyone can loot it? :P */
 			if(iter->passed)
 				slottype = 0;					// All players passed on the loot
+
+			//if it is ffa loot and not an masterlooter
+			if(iter->ffa_loot && slottype != 2)
+				slottype = 0;
 		}
 
 		data << uint8(x); 
@@ -4955,7 +4965,7 @@
 		
 		if(slottype == 1)
 		{
-			if(iter->roll == NULL && !iter->passed)
+			if(iter->roll == NULL && !iter->passed && !iter->ffa_loot)
 			{
 				int32 ipid = 0;
 				uint32 factor=0;
@@ -5134,6 +5144,22 @@
 	}
 }
 
+void Player::removeDeletedSpellByHashName(uint32 hash)
+{
+	SpellSet::iterator it,iter;
+	
+	for(iter= mDeletedSpells.begin();iter != mDeletedSpells.end();)
+	{
+		it = iter++;
+		uint32 SpellID = *it;
+		SpellEntry *e = dbcSpell.LookupEntry(SpellID);
+		if(e->NameHash == hash)
+		{
+			mDeletedSpells.erase(it);
+		}
+	}
+}
+
 void Player::removeSpellByHashName(uint32 hash)
 {
 	SpellSet::iterator it,iter;
@@ -5361,11 +5387,14 @@
 							//remove higher ranks of this spell too (like earth shield lvl 1 is talent and the rest is thought from trainer) 
 							SpellEntry *spellInfo2;
 							spellInfo2 = dbcSpell.LookupEntry( spellInfo->EffectTriggerSpell[k] );
-							if(spellInfo2)
-								removeSpellByHashName(spellInfo2->NameHash);
-						}
-					//remove them all in 1 shot
+							if(spellInfo2) {
+ 								removeSpellByHashName(spellInfo2->NameHash);
+								removeDeletedSpellByHashName(spellInfo2->NameHash);
+							}
+ 						}
+ 					//remove them all in 1 shot
 					removeSpellByHashName(spellInfo->NameHash);
+					removeDeletedSpellByHashName(spellInfo->NameHash);
 				}
 			}
 			else
@@ -5767,7 +5796,7 @@
 	const static float ClassFlatMod[12]={
 			0.0f,6.0f,6.0f,6.0f,2.0f,4.0f,0.0f,6.0f,4.0f,6.0f,0.0f,6.5f};
 
-	float amt;
+	float amt = 0.0f;
 	uint32 cur = GetUInt32Value(UNIT_FIELD_HEALTH);
 	uint32 mh = GetUInt32Value(UNIT_FIELD_MAXHEALTH);
 	if(cur >= mh)
@@ -6064,6 +6093,71 @@
 	}
 }
 
+void Player::ResetAllCooldowns()
+{
+	uint32 guid = (uint32)GetSelection();
+
+	switch(getClass())
+	{
+		case WARRIOR:
+		{
+			ClearCooldownsOnLine(26, guid);
+			ClearCooldownsOnLine(256, guid);
+			ClearCooldownsOnLine(257 , guid);
+		} break;
+		case PALADIN:
+		{
+			ClearCooldownsOnLine(594, guid);
+			ClearCooldownsOnLine(267, guid);
+			ClearCooldownsOnLine(184, guid);
+		} break;
+		case HUNTER:
+		{
+			ClearCooldownsOnLine(50, guid);
+			ClearCooldownsOnLine(51, guid);
+			ClearCooldownsOnLine(163, guid);
+		} break;
+		case ROGUE:
+		{
+			ClearCooldownsOnLine(253, guid);
+			ClearCooldownsOnLine(38, guid);
+			ClearCooldownsOnLine(39, guid);
+		} break;
+		case PRIEST:
+		{
+			ClearCooldownsOnLine(56, guid);
+			ClearCooldownsOnLine(78, guid);
+			ClearCooldownsOnLine(613, guid);
+		} break;
+		case SHAMAN:
+		{
+			ClearCooldownsOnLine(373, guid);
+			ClearCooldownsOnLine(374, guid);
+			ClearCooldownsOnLine(375, guid);
+		} break;
+		case MAGE:
+		{
+			ClearCooldownsOnLine(6, guid);
+			ClearCooldownsOnLine(8, guid);
+			ClearCooldownsOnLine(237, guid);
+		} break;
+		case WARLOCK:
+		{
+			ClearCooldownsOnLine(355, guid);
+			ClearCooldownsOnLine(354, guid);
+			ClearCooldownsOnLine(593, guid);
+		} break;
+		case DRUID:
+		{
+			ClearCooldownsOnLine(573, guid);
+			ClearCooldownsOnLine(574, guid);
+			ClearCooldownsOnLine(134, guid);
+		} break;
+
+		default: return; break;
+	}
+}
+
 void Player::PushUpdateData(ByteBuffer *data, uint32 updatecount)
 {
 	// imagine the bytebuffer getting appended from 2 threads at once! :D
Index: game/Player.h
===================================================================
--- game/Player.h	(revision 2030)
+++ game/Player.h	(working copy)
@@ -847,6 +847,7 @@
 	void smsg_InitialSpells();
 	void addSpell(uint32 spell_idy);
 	void removeSpellByHashName(uint32 hash);
+	void removeDeletedSpellByHashName(uint32 hash);
 	bool removeSpell(uint32 SpellID, bool MoveToDeleted, bool SupercededSpell, uint32 SupercededSpellID);
 
     // PLEASE DO NOT INLINE!
@@ -1256,7 +1257,8 @@
 	void EventAllowTiggerPort(bool enable);
 	int32 m_rangedattackspeedmod;
 	int32 m_meleeattackspeedmod;
-	uint32 m_modblockvalue;
+	uint32 m_modblockabsorbvalue;
+	uint32 m_modblockvaluefromspells;
 	void SendInitialLogonPackets();
 	void Reset_Spells();
 	void Reset_Talents();
@@ -1394,6 +1396,7 @@
 	uint32 GetGlobalCooldown() { return GlobalCooldown; }
 	void SetGlobalCooldown(uint32 time) { GlobalCooldown = time; }
 	void ClearCooldownsOnLine(uint32 skill_line, uint32 called_from);
+	void ResetAllCooldowns();
 	void ClearCooldownForSpell(uint32 spell_id);
 	bool bProcessPending;
 	Mutex _bufferS;
Index: game/ReputationHandler.cpp
===================================================================
--- game/ReputationHandler.cpp	(revision 2030)
+++ game/ReputationHandler.cpp	(working copy)
@@ -427,7 +427,7 @@
 		{
 			for(it = m_Group->GetSubGroup(i)->GetGroupMembersBegin(); it != m_Group->GetSubGroup(i)->GetGroupMembersEnd(); ++it)
 			{
-				if(it->player)
+				if(it->player && it->player->isInRange(this,100.0f))
 					it->player->Reputation_OnKilledUnit(pUnit, true);
 			}
 		}
@@ -446,12 +446,21 @@
 				continue;
 
 			/* rep limit? */
-			if((*itr).replimit)
+			if (!IS_INSTANCE(GetMapId()) || (IS_INSTANCE(GetMapId()) && this->iInstanceType != MODE_HEROIC))
 			{
-				if(GetStanding((*itr).faction[team]) >= (int32)(*itr).replimit)
-					continue;
+				if((*itr).replimit)
+				{
+					if(GetStanding((*itr).faction[team]) >= (int32)(*itr).replimit)
+						continue;
+				}
 			}
 
+			/*
+			Standing rank = GetReputationRankFromStanding(GetStanding(pUnit->m_factionDBC->ID));
+			if(STANDING_EXALTED <= rank || STANDING_HATED >= rank)
+				continue;
+			*/
+
 			int32 value = int32(float(itr->value) * sWorld.getRate(RATE_KILLREPUTATION));
 			//value *= sWorld.getRate(RATE_KILLREPUTATION);
 			ModStanding(itr->faction[team], value);
Index: game/SocialMgr.cpp
===================================================================
--- game/SocialMgr.cpp	(revision 2030)
+++ game/SocialMgr.cpp	(working copy)
@@ -165,9 +165,9 @@
 		plr->GetSession()->SendPacket( &data );
 		return;
 	}
-	if( friendInfo->team != playerInfo->team )
+	if( friendInfo->team != playerInfo->team && sWorld.FriendFactionLimitation )
 	{
-		sLog.outDebug("SocialMgr: %s tried to add an ennemy to his friendlist", plr->GetName());
+		sLog.outDebug("SocialMgr: %s tried to add an enemy to his friendlist", plr->GetName());
 		data << (uint8)FRIEND_ENEMY << (uint64)friendInfo->guid;
 		plr->GetSession()->SendPacket( &data );
 		return;
@@ -244,7 +244,7 @@
 
 	if( pGuid == iGuid )
 	{
-		sLog.outDebug("SocialMgr: %s tried to add himself to his friendlist", plr->GetName());
+		sLog.outDebug("SocialMgr: %s tried to add himself to his ignorelist", plr->GetName());
 		data << (uint8)FRIEND_IGNORE_SELF << (uint64)iGuid;
 		plr->GetSession()->SendPacket(&data);
 		return;
Index: game/Spell.cpp
===================================================================
--- game/Spell.cpp	(revision 2030)
+++ game/Spell.cpp	(working copy)
@@ -1217,10 +1217,11 @@
 								HandleEffects((*i),x);
                             }
 						}
-						else if(m_spellInfo->Effect[x] == SPELL_EFFECT_TELEPORT_UNITS)
-                        {
-							HandleEffects(m_caster->GetGUID(),x);
-                        }
+						else
+							{
+								if(m_spellInfo->Effect[x] == SPELL_EFFECT_TELEPORT_UNITS)
+ 									HandleEffects(m_caster->GetGUID(),x);
+							}
 					}
 				}
 	
@@ -1951,7 +1952,21 @@
 	if(m_spellInfo->ManaCostPercentage)//Percentage spells cost % of !!!BASE!!! mana
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
-			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)*m_spellInfo->ManaCostPercentage)/100;
+		{
+			uint32 mana_from_base_int = 0;
+			if(m_caster->IsPlayer())
+			{
+				Player * plr = static_cast<Player*>(m_caster);
+
+				LevelInfo * Info = objmgr.GetLevelInfo(plr->getRace(), plr->getClass(), plr->getLevel());
+				LevelInfo * InfoFirst = objmgr.GetLevelInfo(plr->getRace(), plr->getClass(), 1);
+
+				if(Info != 0 && InfoFirst != 0)
+					mana_from_base_int = (Info->Stat[3] - InfoFirst->Stat[3])*15;
+			}
+
+			cost = ((m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)-mana_from_base_int)*m_spellInfo->ManaCostPercentage)/100;
+		}
 		else
 			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_HEALTH)*m_spellInfo->ManaCostPercentage)/100;
 	}
@@ -1961,7 +1976,14 @@
 	}
 
 	if(m_spellInfo->powerType==POWER_TYPE_HEALTH)
-		cost -= m_spellInfo->baseLevel;//FIX for life tap	
+		{
+		// For Life Tap don't do repeat damage process
+		if (m_spellInfo->NameHash == 0x0807C866) return true;
+
+		// The caster doesnt have enough health to use this spell...stop casting
+		if (u_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= (uint32)cost) 
+			return false;
+	}
 	else if(u_caster)
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
@@ -2049,7 +2071,20 @@
 	if(m_spellInfo->ManaCostPercentage)//Percentage spells cost % of !!!BASE!!! mana
 	{
 		if(m_spellInfo->powerType==POWER_TYPE_MANA)
-			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)*m_spellInfo->ManaCostPercentage)/100;
+		{
+			uint32 mana_from_base_int = 0;
+			if(m_caster->IsPlayer())
+			{
+				Player * plr = static_cast<Player*>(m_caster);
+
+				LevelInfo * Info = objmgr.GetLevelInfo(plr->getRace(), plr->getClass(), plr->getLevel());
+				LevelInfo * InfoFirst = objmgr.GetLevelInfo(plr->getRace(), plr->getClass(), 1);
+
+				if(Info != 0 && InfoFirst != 0)
+					mana_from_base_int = (Info->Stat[3] - InfoFirst->Stat[3])*15;
+			}
+			cost = ((m_caster->GetUInt32Value(UNIT_FIELD_BASE_MANA)-mana_from_base_int)*m_spellInfo->ManaCostPercentage)/100;
+		}
 		else
 			cost = (m_caster->GetUInt32Value(UNIT_FIELD_BASE_HEALTH)*m_spellInfo->ManaCostPercentage)/100;
 	}
@@ -2654,6 +2689,14 @@
 
 	if(p_caster)
 	{
+		// Caster is confused. They can't cast any spells except...
+		if ((p_caster->HasFlag(UNIT_FIELD_FLAGS, U_FIELD_FLAG_UNKNOWN18)) && 
+			// Divine Protection, Divine Shield, Arcane Bubble, Ice Block
+			((m_spellInfo->EffectMiscValue[3] != SPELL_EFFECT_UNKNOWN5) && (m_spellInfo->Category != 37) || 
+			// Stoneform
+			(m_spellInfo->Id != 20594)))
+			return SPELL_FAILED_SILENCED;
+
 		if (p_caster->m_bgHasFlag)
 		{
 			switch(m_spellInfo->Id)
@@ -3390,7 +3433,11 @@
 
 		float healdoneaffectperc = castaff / 3500;
 		
-		amount += float2int32(u_caster->HealDoneMod[m_spellInfo->School] * healdoneaffectperc);
+		if(!m_spellInfo->dmg_bonus)
+			amount += float2int32(u_caster->HealDoneMod[m_spellInfo->School] * healdoneaffectperc);
+		else
+			amount += float2int32((u_caster->HealDoneMod[m_spellInfo->School]*m_spellInfo->dmg_bonus)/100);
+
 		amount += (amount*u_caster->HealDonePctMod[m_spellInfo->School])/100;
 		amount += unitTarget->HealTakenMod[m_spellInfo->School];//amt of health that u RECIVE, not heal
 		amount += float2int32(unitTarget->HealTakenPctMod[m_spellInfo->School]*amount);
@@ -3446,9 +3493,6 @@
 	else
 		unitTarget->ModUInt32Value(UNIT_FIELD_HEALTH, amount);
 
-	if(p_caster)
-		p_caster->HandleProc(PROC_ON_CAST_SPECIFIC_SPELL | PROC_ON_CAST_SPELL,p_caster, m_spellInfo);
-	
 	int doneTarget = 0;
 
 	// add threat
Index: game/SpellAuras.cpp
===================================================================
--- game/SpellAuras.cpp	(revision 2030)
+++ game/SpellAuras.cpp	(working copy)
@@ -170,7 +170,7 @@
 		&Aura::SpellAuraNULL,//SPELL_AURA_ADD_CREATURE_IMMUNITY = 147,//http://wow.allakhazam.com/db/spell.html?wspell=36798
 		&Aura::SpellAuraRetainComboPoints,//SPELL_AURA_RETAIN_COMBO_POINTS = 148,
 		&Aura::SpellAuraResistPushback,//SPELL_AURA_RESIST_PUSHBACK = 149,//	Resist Pushback //Simply resist spell casting delay
-		&Aura::SpellAuraModShieldBlockPCT,//SPELL_AURA_MOD_SHIELD_BLOCK_PCT = 150,//	Mod Shield Block %
+		&Aura::SpellAuraModShieldBlockPCT,//SPELL_AURA_MOD_SHIELD_BLOCK_PCT = 150,//	Mod Shield Absorbed dmg %
 		&Aura::SpellAuraTrackStealthed,//SPELL_AURA_TRACK_STEALTHED = 151,//	Track Stealthed
 		&Aura::SpellAuraModDetectedRange,//SPELL_AURA_MOD_DETECTED_RANGE = 152,//	Mod Detected Range
 		&Aura::SpellAuraSplitDamageFlat,//SPELL_AURA_SPLIT_DAMAGE_FLAT= 153,//	Split Damage Flat
@@ -559,6 +559,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.from_weapon = false;
 			m_target->m_procSpells.push_front(pts);
 		}
 		else
@@ -1057,7 +1058,7 @@
 			c->RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_START_ATTACK);
 			
 			float bonus_damage = c->GetDamageDoneMod(school);
-			bonus_damage += float(m_target->DamageTakenMod[school]);
+			float bonus_damage_victim = float(m_target->DamageTakenMod[school]);
 			if(c->IsPlayer())
 			{
 				bonus_damage += static_cast<Player*>(c)->SpellDmgDoneByInt[school] * c->GetUInt32Value(UNIT_FIELD_STAT3);
@@ -1073,8 +1074,18 @@
 			if(GetDuration())
 			{
 				int ticks= (amp) ? GetDuration()/amp : 0;
-				bonus += (ticks) ? bonus_damage/ticks : 0;
-				bonus *= GetDuration() / 15000.0f;
+
+				if (m_spellProto->dmg_bonus && m_spellProto->Effect[0] != SPELL_EFFECT_SCHOOL_DAMAGE && 
+					m_spellProto->Effect[1] != SPELL_EFFECT_SCHOOL_DAMAGE && m_spellProto->Effect[2] != SPELL_EFFECT_SCHOOL_DAMAGE )
+				{
+					bonus += (ticks) ? ((bonus_damage*m_spellProto->dmg_bonus*0.01)+bonus_damage_victim)/ticks : 0;
+				}
+				else
+				{
+					bonus += (ticks) ? (bonus_damage+bonus_damage_victim)/ticks : 0;
+					if(!m_spellProto->ChannelInterruptFlags)
+						bonus *= GetDuration() / 15000.0f;
+				}
 			}
 			else bonus = 0;
 			res += bonus;
@@ -1273,6 +1284,7 @@
 			pts.procCharges = GetSpellProto()->procCharges;
 			pts.LastTrigger = 0;
 			pts.deleted = false;
+			pts.from_weapon = false;
 			m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1649,6 +1661,7 @@
 				pts.procCharges = GetSpellProto()->procCharges;
 				pts.LastTrigger = 0;
 				pts.deleted = false;
+				pts.from_weapon = false;
 				m_target->m_procSpells.push_front(pts);
 			}
 			else
@@ -1791,9 +1804,14 @@
 
 		if(p_target)
 		{
+			static_cast<Player*>(m_target)->EventAttackStop();
 			m_target->setAItoUse(true);
+
+			WorldPacket data1(9);
+			data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
+			data1 << m_target->GetNewGUID() << uint8(0x00);
+			static_cast<Player*>(m_target)->GetSession()->SendPacket(&data1);
 		}
-		m_target->m_pacified++;
 		m_target->m_special_state |= UNIT_STATE_FEAR;
 		m_target->SetFlag(UNIT_FIELD_FLAGS, U_FIELD_FLAG_FEARED);
 		m_target->GetAIInterface()->HandleEvent(EVENT_FEAR, u_caster, 0);
@@ -1803,12 +1821,16 @@
 		m_target->GetAIInterface()->HandleEvent(EVENT_UNFEAR, u_caster, 0);
 		m_target->RemoveFlag(UNIT_FIELD_FLAGS, U_FIELD_FLAG_FEARED);
 		m_target->m_special_state &= ~UNIT_STATE_FEAR;
-		m_target->m_pacified--;
 
 		if(p_target)
 		{
 			m_target->setAItoUse(false);
 			sHookInterface.OnEnterCombat(p_target, u_caster);
+
+			WorldPacket data1(9);
+			data1.Initialize(SMSG_DEATH_NOTIFY_OBSOLETE);
+			data1 << m_target->GetNewGUID() << uint8(0x01);
+			static_cast<Player*>(m_target)->GetSession()->SendPacket(&data1);
 		}
 		else
 			m_target->GetAIInterface()->AttackReaction(u_caster, 1, 0);
@@ -1832,6 +1854,7 @@
 	Unit * c = GetUnitCaster();
 
 	int bonus = 0;
+	int bonus_target = 0;
 
 	if(c && c->IsPlayer())
 	{
@@ -1842,17 +1865,25 @@
 		if (static_cast<Player*>(c)->IsInFeralForm() && static_cast<Player*>(c)->GetShapeShift() == FORM_TREE)
 			bonus += float2int32(0.25f*((Player*)c)->GetUInt32Value(UNIT_FIELD_STAT4));
 	}
-	bonus += m_target->HealTakenMod[GetSpellProto()->School];
+	bonus_target += m_target->HealTakenMod[GetSpellProto()->School];
 
 	int amp = m_spellProto->EffectAmplitude[mod->i];
-	if(!amp) 
+	if(!amp)
 		amp=((EventableObject*)this)->event_GetEventPeriod(EVENT_AURA_PERIODIC_HEAL);
 
 	if(GetDuration())
 	{
 		int ticks= (amp) ? GetDuration()/amp : 0;
-		bonus= (ticks) ? bonus/ticks : 0;
-		bonus *= GetDuration() / 15000.0f;
+		if (!m_spellProto->dmg_bonus)
+		{
+			bonus = (ticks) ? (bonus+bonus_target)/ticks : 0;
+			if(!m_spellProto->ChannelInterruptFlags)
+				bonus *= GetDuration() / 15000.0f;
+		}
+		else
+		{
+			bonus = (ticks) ? ((bonus*m_spellProto->dmg_bonus/100)+bonus_target)/ticks : 0;
+		}
 	}
 	else bonus = 0;
 
@@ -2480,7 +2511,6 @@
 {
 	// Trigger Spell
 	// check for spell id
-
 	Unit *m_caster=GetUnitCaster();
 	if(!m_caster || !m_caster->IsInWorld())
 		return;
@@ -3343,6 +3373,7 @@
 		pts.procCharges = GetSpellProto()->procCharges;
 		pts.LastTrigger = 0;
 		pts.deleted = false;
+		pts.from_weapon = false;
 
 		if(m_spellProto->NameHash == 0xE4573D4A)
 		{
@@ -3524,7 +3555,6 @@
 		else 
 			amt = -mod->m_amount;
 
-		//static_cast<Player*>(m_target)->SetBlockFromSpellPCT(static_cast<Player*>(m_target)->GetBlockFromSpellPCT() + amt );
 		static_cast<Player*>(m_target)->SetBlockFromSpell(static_cast<Player*>(m_target)->GetBlockFromSpell() + amt);
 		static_cast<Player*>(m_target)->UpdateChances();
 	}
@@ -4542,7 +4572,17 @@
 void Aura::SpellAuraModRegenPercent(bool apply)
 {
 	if(apply)
+	{
 		m_target->PctRegenModifier += ((float)(mod->m_amount))/100.0;
+
+		if (GetSpellProto()->Flags3 & FLAGS3_FUNNEL) 
+		{
+			uint32 dmg = GetSpellProto()->manaPerSecond;
+			sEventMgr.AddEvent(this, &Aura::EventPeriodicDamage,dmg, 
+				EVENT_AURA_PERIODIC_DAMAGE,GetSpellProto()->EffectAmplitude[0],0,EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
+			SetNegative();
+		}
+	}
 	else
 		m_target->PctRegenModifier -= ((float)(mod->m_amount))/100.0;
 }
@@ -5648,25 +5688,17 @@
 
 void Aura::SpellAuraModShieldBlockPCT(bool apply)
 {
-	//old = this is wrong since we will overwrite it at first state recalc
-//	m_target->ModFloatValue(PLAYER_BLOCK_PERCENTAGE, apply ? mod->m_amount : -mod->m_amount);
-	//new
-	if (m_target->GetTypeId() == TYPEID_PLAYER)
+
+	if(p_target)
 	{
-		int32 amt;
 		if(apply)
 		{
-			amt = mod->m_amount;
-			if(amt<0)
-				SetNegative();
-			else 
-				SetPositive();
+			p_target->m_modblockabsorbvalue += (uint32)mod->m_amount;
 		}
-		else 
-			amt = -mod->m_amount;
-
-		static_cast<Player*>(m_target)->SetBlockFromSpell(static_cast<Player*>(m_target)->GetBlockFromSpell() + amt );
-		static_cast<Player*>(m_target)->UpdateChances();
+		else
+		{
+			p_target->m_modblockabsorbvalue -= (uint32)mod->m_amount;
+		}
 	}
 }
 
@@ -6695,16 +6727,21 @@
 
 void Aura::SpellAuraModBlockValue(bool apply)
 {
-	if(p_target)
+	if (p_target)
 	{
+		int32 amt;
 		if(apply)
 		{
-			p_target->m_modblockvalue += (uint32)mod->m_amount;
+			amt = mod->m_amount;
+			if(amt<0)
+				SetNegative();
+			else 
+				SetPositive();
 		}
-		else
-		{
-			p_target->m_modblockvalue -= (uint32)mod->m_amount;
-		}
+		else 
+			amt = -mod->m_amount;
+
+		p_target->m_modblockvaluefromspells += amt;
 	}
 }
 
Index: game/SpellAuras.h
===================================================================
--- game/SpellAuras.h	(revision 2030)
+++ game/SpellAuras.h	(working copy)
@@ -306,6 +306,7 @@
     uint32 LastTrigger;
 	uint32 ProcType; //0=talents/spells 1=weapon 2=armor  TODO: implement.
     bool deleted;
+	bool from_weapon;
 };
 
 struct SpellCharge
Index: game/SpellEffects.cpp
===================================================================
--- game/SpellEffects.cpp	(revision 2030)
+++ game/SpellEffects.cpp	(working copy)
@@ -517,6 +517,7 @@
 
 		uint32 damage = m_spellInfo->EffectBasePoints[i]+1;
 		uint32 man = (damage *(100+playerTarget->m_lifetapbonus))/100;
+		if (p_caster->GetUInt32Value(UNIT_FIELD_HEALTH) <= damage) return;
 		p_caster->DealDamage(playerTarget,damage,0,0,spellId);
 		playerTarget->ModUInt32Value(UNIT_FIELD_POWER1,man);
 		if(playerTarget->GetUInt32Value(UNIT_FIELD_POWER1) > playerTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1))
@@ -1085,6 +1086,7 @@
 			ILotP.procChance = 100;
 			ILotP.procFlags = PROC_ON_CRIT_ATTACK | PROC_TAGRGET_SELF;
 			ILotP.deleted = false;
+			ILotP.from_weapon = false;
 			ILotP.caster = u_caster->GetGUID();
 			ILotP.LastTrigger = 0;
 			u_caster->m_procSpells.push_back(ILotP);
@@ -1965,8 +1967,7 @@
 				{
 					if(gameObjTarget->loot.items.size() == 0)
 					{
-						lootmgr.FillProfessionLoot(&lootmgr.GOLoot,&gameObjTarget->loot,
-							gameObjTarget->GetEntry());
+						lootmgr.FillGOLoot(&gameObjTarget->loot,gameObjTarget->GetEntry(), gameObjTarget->GetMapMgr() ? (gameObjTarget->GetMapMgr()->iInstanceMode ? true : false) : false);
 					}
 					else
 						bAlreadyUsed = true;
@@ -3507,7 +3508,26 @@
 		pTotem->EnableAI();
 		pTotem->GetAIInterface()->Init(pTotem, AITYPE_TOTEM, MOVEMENTTYPE_NONE, p_caster);
 		pTotem->GetAIInterface()->totemspell = TotemSpell;
-		uint32 timer = 2000;	// need a proper resource for this.
+		uint32 timer = 2000;
+ 
+		switch(TotemSpell->Id)
+		{
+			case 8146: //Tremor Totem
+			case 8167: //Poison Cleansing Totem
+			case 8172: //Disease Cleansing Totem
+				timer =  5000;
+			break;
+			case 8349: //Fire Nova Totem 1
+			case 8502: //Fire Nova Totem 2
+			case 8503: //Fire Nova Totem 3
+			case 11306: //Fire Nova Totem 4
+			case 11307: //Fire Nova Totem 5
+			case 25535: //Fire Nova Totem 6
+			case 25537: //Fire Nova Totem 7
+				timer =  4000;
+			break;
+		default:break;
+		}
 
 		pTotem->GetAIInterface()->m_totemspelltimer = timer;
 		pTotem->GetAIInterface()->m_totemspelltime = timer;
@@ -3583,7 +3603,7 @@
 	if( (sk >= lvl*5)||((sk+100) >= lvl*10) )
 	{
 		//Fill loot for Skinning
-		lootmgr.FillProfessionLoot(&lootmgr.SkinningLoot,&((Creature*)unitTarget)->loot,unitTarget->GetEntry());
+		lootmgr.FillSkinningLoot(&((Creature*)unitTarget)->loot,unitTarget->GetEntry());
 		((Player*)m_caster)->SendLoot(unitTarget->GetGUID(),2);
 		
 		//Not skinable again
Index: game/Unit.cpp
===================================================================
--- game/Unit.cpp	(revision 2030)
+++ game/Unit.cpp	(working copy)
@@ -372,6 +372,7 @@
 
 	//Get Highest Level Player, Calc Xp and give it to each group member
 	Player *pHighLvlPlayer = NULL;
+	Player *pHighLvlPlayerNot70 = NULL;
 	Player *pGroupGuy = NULL;
 	  int active_player_count=0;
 	Player *active_player_list[MAX_GROUP_SIZE_RAID];//since group is small we can afford to do this ratehr then recheck again the whole active player set
@@ -413,13 +414,16 @@
 				active_player_list[active_player_count]=pGroupGuy;
 				active_player_count++;
 				total_level += pGroupGuy->getLevel();
-				if(pHighLvlPlayer)
+				if(pHighLvlPlayerNot70)
 				{
-					if(pGroupGuy->getLevel() > pHighLvlPlayer->getLevel())
-						pHighLvlPlayer = pGroupGuy;
+					if(pGroupGuy->getLevel() < 70)
+					{
+						if (pGroupGuy->getLevel() > pHighLvlPlayerNot70->getLevel())
+							pHighLvlPlayerNot70 = pGroupGuy;
+					}
 				}
-				else 
-					pHighLvlPlayer = pGroupGuy;
+				else if(pGroupGuy->getLevel() < 70)
+					pHighLvlPlayerNot70 = pGroupGuy;
 			}
 		}
 	}
@@ -444,12 +448,17 @@
 		}
 		else if(pGroup->GetGroupType() == GROUP_TYPE_RAID)
 			xp_mod=0.5f;
-		if(pHighLvlPlayer == 0) pHighLvlPlayer = pGroup->GetLeader();
+		if(pHighLvlPlayerNot70 == 0 || !pHighLvlPlayerNot70) pHighLvlPlayerNot70 = pGroup->GetLeader();
 
-		xp = CalculateXpToGive(pVictim, pHighLvlPlayer);
+		xp = CalculateXpToGive(pVictim, pHighLvlPlayerNot70);
 		//i'm not sure about this formula is correct or not. Maybe some brackets are wrong placed ?
 		for(int i=0;i<active_player_count;i++)
-			active_player_list[i]->GiveXP( float2int32(((xp*active_player_list[i]->getLevel()) / total_level)*xp_mod), pVictim->GetGUID(), true );
+		{
+			if (active_player_list[i]->getLevel() < 70)
+				active_player_list[i]->GiveXP( float2int32(((xp*active_player_list[i]->getLevel()) / total_level)*xp_mod), pVictim->GetGUID(), true );
+			else
+				active_player_list[i]->GiveXP( 0, pVictim->GetGUID(), true );
+		}
 	}
 		/* old code start before 2007 04 22
 		GroupMembersSet::iterator itr;
@@ -496,7 +505,7 @@
 	bool can_delete = !bProcInUse;
 	bProcInUse = true;
 
-	std::list<uint32> remove;
+	//std::list<uint32> remove;
 	std::list<struct ProcTriggerSpell>::iterator itr,itr2;
 	for( itr = m_procSpells.begin();itr != m_procSpells.end();)  // Proc Trigger Spells for Victim
 	{
@@ -577,6 +586,20 @@
 				//these are player talents. Fuckem they pull the emu speed down 
 				if(IsPlayer())
 				{
+					if (itr2->from_weapon && static_cast<Player*>(this)->IsInFeralForm()) 
+					{
+						switch (static_cast<Player*>(this)->GetShapeShift())
+						{
+							case FORM_CAT:	
+							case FORM_BEAR: 
+							case FORM_DIREBEAR:
+								continue;
+								break;
+							default:
+								break;
+						}
+					}
+
 					uint32 talentlevel=0;
 					switch(origId)
 					{
@@ -882,8 +905,6 @@
 								float dmg = static_cast<Player*>(this)->GetMainMeleeDamage(AP_owerride);
 								SpellEntry *sp_for_the_logs = dbcSpell.LookupEntry(spellId);
 								Strike(victim,MELEE,sp_for_the_logs,dmg,0,0,true);
-								Strike(victim,MELEE,sp_for_the_logs,dmg,0,0,true);
-								//nothing else to be done for this trigger
 								continue;
 							}break;
 						//rogue - Ruthlessness
@@ -1037,6 +1058,11 @@
 					if(!sd) continue; // this shouldnt happen though :P
 					switch(iter2->second.spellId)
 					{
+					case 14751:  // inner focus
+					{
+						if(CastingSpell->Id == iter2->second.spellId)
+							continue; 
+						}break;
 					case 12043:
 						{
 							//Presence of Mind and Nature's Swiftness should only get removed
@@ -1743,7 +1769,7 @@
 					{
 						targetEvent = 2;
 						pVictim->Emote(EMOTE_ONESHOT_PARRYSHIELD);// Animation
-						blocked_damage = uint32((shield->GetProto()->Block + ((Player*)pVictim)->m_modblockvalue)*(1.0+((Player*)pVictim)->GetBlockFromSpell()/100)+pVictim->GetUInt32Value(UNIT_FIELD_STAT0)/20);
+						blocked_damage = uint32( (shield->GetProto()->Block+((Player*)pVictim)->m_modblockvaluefromspells) * (1+(((Player*)pVictim)->m_modblockabsorbvalue*0.01)) + pVictim->GetUInt32Value(UNIT_FIELD_STAT0)/20 );
 
 						if(dmg.full_damage <= (int32)blocked_damage)
 						{
Index: game/World.cpp
===================================================================
--- game/World.cpp	(revision 2030)
+++ game/World.cpp	(working copy)
@@ -835,6 +835,16 @@
 						pr|=PROC_ON_MELEE_ATTACK_VICTIM;
 					if(strstr(desc,"target casts a spell"))
 						pr|=PROC_ON_CAST_SPELL;
+					if(strstr(desc,"your harmful spells land"))
+						pr|=PROC_ON_CAST_SPELL;
+					if(strstr(desc,"on spell critical hit"))
+						pr|=PROC_ON_SPELL_CRIT_HIT;
+					if(strstr(desc,"spell critical strikes"))
+						pr|=PROC_ON_SPELL_CRIT_HIT;
+					if(strstr(desc,"being able to resurrect"))
+						pr|=PROC_ON_DIE;
+					//if(strstr(desc,"successful block"))
+						//pr|=PROC_ON_BLOCK_VICTIM;
 					if(strstr(desc,"any damage caused"))
 						pr|=PROC_ON_ANY_DAMAGE_VICTIM;
 					if(strstr(desc,"the next melee attack against the caster"))
@@ -1596,7 +1606,7 @@
 	sp  = dbcSpell.LookupEntry(12042);
 	if (sp)
 	{
-		sp->EffectSpellGroupRelation[0]=5775504;
+		sp->EffectSpellGroupRelation[0]=552210455;
 		sp->EffectSpellGroupRelation[1]=10518528;
 	}
 	//mage: Fire Power
@@ -2111,7 +2121,19 @@
 		sp->EffectSpellGroupRelation[0] = Sanctity_group;
 		sp->EffectMiscValue[0] = SMT_SPELL_VALUE;
 	}
-
+	sp = dbcSpell.LookupEntry(20608); //Reincarnation
+	if(sp)
+	{
+		for(uint32 i=0;i<8;i++)
+		{
+			if(sp->Reagent[i])
+			{
+				sp->Reagent[i] = 0;
+				sp->ReagentCount[i] = 0;
+			}
+		}
+	}
+	
 ///////////////////////////////
 /*	// druid - Improved Mark of the Wild
 	uint32 imarkofthv_group=0;
@@ -2829,6 +2851,8 @@
 		new MailSystem;
 
 	channelmgr.seperatechannels = Config.MainConfig.GetBoolDefault("Server", "SeperateChatChannels", false);
+	PvpFactionLimitation = Config.MainConfig.GetBoolDefault("Server", "PvpFactionLimitation", true);
+	FriendFactionLimitation = Config.MainConfig.GetBoolDefault("Server", "FriendFactionLimitation", true);
 	sendRevisionOnJoin = Config.MainConfig.GetBoolDefault("Server", "SendBuildOnJoin", false);
 	MapPath = Config.MainConfig.GetStringDefault("Terrain", "MapPath", "maps");
 	UnloadMapFiles = Config.MainConfig.GetBoolDefault("Terrain", "UnloadMapFiles", true);
Index: game/World.h
===================================================================
--- game/World.h	(revision 2030)
+++ game/World.h	(working copy)
@@ -212,6 +212,8 @@
     uint32 lvl_mod_a;
 	uint32 required_quest;
 	uint32 required_item;
+	uint32 heroic_keyid_1;
+	uint32 heroic_keyid_2;
 
 	bool HasFlag(uint32 flag)
 	{
@@ -459,6 +461,8 @@
 
 	string MapPath;
 	bool UnloadMapFiles;
+	bool PvpFactionLimitation;
+	bool FriendFactionLimitation;
 	bool BreathingEnabled;
 	bool SpeedhackProtection;
 	void EventDeleteBattleground(Battleground * BG);
Index: shared/Database/DBCStores.h
===================================================================
--- shared/Database/DBCStores.h	(revision 2030)
+++ shared/Database/DBCStores.h	(working copy)
@@ -344,6 +344,7 @@
     uint32 RankNumber;                      //!!! CUSTOM, this protects players from having >1 rank of a spell
     uint32 NameHash;                        //!!! CUSTOM, related to custom spells, summon spell quest related spells
     float base_range_or_radius_sqr;         //!!! CUSTOM, needed for aoe spells most of the time
+	uint32 dmg_bonus;						//CUSTOM
 	uint32 talent_tree;
 };
 
